# -*- coding: utf-8 -*-
"""
.. codeauthor:: Jaume Bonet <jaume.bonet@gmail.com>

.. affiliation::
    Structural BioInformatics Lab <sbi.upf.edu>
    Baldo Oliva <baldo.oliva@upf.edu>
"""
# Standard Libraries
import os
from itertools import groupby

# External Libraries
import six
import numpy as np
import pandas as pd
import scipy.spatial as sp
from transforms3d.euler import euler2mat

# This Library
from SBI.core import core
from SBI.structure.header import Header
from .io import mmPDB

__all__ = ['Frame3D', 'Frame3DCreationError']

mandatory_fields = ['id', 'auth_asym_id', 'label_alt_id', 'label_asym_id', 'label_atom_id',
                    'label_comp_id', 'label_entity_id', 'label_seq_id', 'type_symbol']
"""Lists the fields (columns for :class:`~pandas.DataFrame`-derived classes and index for
:class:`~pandas.Series`-derived classes) that need to be present to guarantee functionality
for :class:`.Frame3D` or :class:`.AtomSeries`.

This list of fiels comes directly from the mandatory fields described in **version 50** of the
[mmCIF dictionary](http://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Categories/atom_site.html).

.. ipython::

    In [1]: from SBI.structure.Frame3D import mandatory_fields
       ...: print(mandatory_fields)

.. note::

    **Developers** should take this into account. Functions that depend on fields different than the ones
    present here should be pre-checked accordingly to generate an informative error if the required field
    is not present in the data.
"""


class Frame3D( pd.DataFrame ):
    """General :class:`~pandas.DataFrame`-derived class from which all
    structure objects inherit.

    .. attention::
        This a **developer level** object.

    :class:`.Frame3D` has the role to provide the attributes, functions and behaviours
    that are shared by any coordinate entry data managed with this library, that includes:

    Globally Shared Attributes
    ==========================

    These are the attributes that should be accessible for any derived class. :class:`.Frame3D`
    is in charge of properly assign them on object instantiation so that non-standard :mod:`pandas`
    keys affect the :class:`~pandas.DataFrame` instantiation. Regardless, individual classess are
    tasked with properly processing the information contained in the extra attributes.

    Current attributes are:

        1. **id:** Contains an identifier of the 3D structure
        2. **header:** Stores **official** header data, i.e. data provided by the official [PDB](https://www.rcsb.org/)
            releases.
        3. **extra:** Stores **processed** data generated by this library.

    Information Management
    ======================

    There are two levels of information management that need to be managed.

    Structure Model
    ---------------

    .. note::
        This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

    Refers to the **MODEL** record, which specifies the model serial number when multiple models of the same
    structure are presented in a single coordinate entry, as is often the case with structures determined by
    [NMR](https://en.wikipedia.org/wiki/Nuclear_magnetic_resonance_spectroscopy). Do not confuse this with
    **OCCUPANCY**, which references [the slight packing differences between crystal
    cells](https://pdb101.rcsb.org/learn/guide-to-understanding-pdb-data/dealing-with-coordinates).

    The selection of the working model is performed through the property :meth:`.Frame3D._current_model`.
    Effectively, to make sure that any selection or transformation is performed only on the selected model,
    one can internaly make a copy of the model of interest. See code of :meth:`.Frame3D.translate` or
    :meth:`.Frame3D.rotate` as examples.

    Structure Source
    ----------------

    .. note::
        This functionality depends on the :ref:`global configuration options <configuration>` ``structure.source``.

    With the rise of the [mmCIF](http://mmcif.wwpdb.org/) format as the new standard for coordinate entries in the
    [PDB](https://www.rcsb.org/), a discrepance appeared in terms of residue position, insertion code and chain between
    the **classic PDB format** and the new one. As a matter of fact, **mmCIF** stores the data for both sources of data,
    a clean, fully numerical, and continuous one (``label``) and a the classic identification used in deposition (``auth``).

    The two main differences are:
        1. The classic ``auth`` format allows for non-contiguous order of residues (number identifiers can jump up and down)
            and can contain text-based insertion identifiers. ``label`` does not allow for these kind of shenanigans.
        2. ``auth`` allows multiple molecules to have the same chain identifier assigned. Thus, a proteins and its small molecule
            ligand (and its attached waters) will all be assigned to the same chain. With ``label``, each molecule has its own
            unique chain identifier.

    As the two codes `might` not be the same for a given coordinate entry, :class:`.Frame3D` makes sure that the one selected
    by the user is consistently used. This is accomplished by systematically calling the columns referencing the data labeling
    not by they actual name but by properties that select the appropiate source: :meth:`.Frame3D._current_atom` for atom type,
    :meth:`.Frame3D._current_comp` for residue type, :meth:`.Frame3D._current_seq` for sequence numbering and
    :meth:`.Frame3D._current_asym` for chain identifier.

    Geometric Applications
    ======================

    All structure-based objects should behave the same when challenged with a geometrical application. As such, geometry is
    stablished in :class:`.Frame3D`, at the base of the class tree. If new geometric-based behaviours need to be implemented,
    this is the place to go. Of course, this will **not** include geometric measures. They should be added here when they are
    generalistic enough but in their appropiate context when specific of a certain class of coordinate entities.

    :raises:
        :Frame3DCreationError: If the generated :class:`.Frame3D` does not contain the mandatory columns to be considered as such.
    """
    _metadata = ['_id', '_header', '_extra']

    def __init__( self, *args, **kwargs ):
        id_ = kwargs.pop('id', '')
        header = kwargs.pop('header', Header())
        extra = kwargs.pop('extra', None)
        fields = kwargs.pop('empty_fields', mandatory_fields + self._coord_tags)

        super(Frame3D, self).__init__(*args, **kwargs)
        if self.empty:
            data = {}
            for f in fields:
                data.setdefault(f, [])
            super(Frame3D, self).__init__(data)

        if not set(mandatory_fields).issubset(self.columns):
            raise Frame3DCreationError('Frame3D requires a given set of columns to be present: {}'.format(','.join(mandatory_fields)))

        self._id = id_
        self._header = header
        self._extra = extra

    # ATTRIBUTES
    @property
    def id( self ):
        """Cordinate entity identifier

        :return: :class:`str`
        """
        return self._id

    @id.setter
    def id( self, pdbname ):
        """
        :param str pdbname: New coordinate entity identifier.

        :return: :class:`.Frame3D`
        """
        self._id = pdbname
        return self

    @property
    def NMR_ids( self ):
        """List the IDs of the NMR models in the coordinate entity.

        :return: :func:`list` of :class:`int`
        """
        if 'pdbx_PDB_model_num' not in self.columns:
            return [1, ]
        return list([int(x) for x in self['pdbx_PDB_model_num'].unique()])

    @property
    def NMR_count( self ):
        """Counts the number of NMR models in the coordinate entity.

        :return: :class:`int`
        """
        return len(self.NMR_ids)

    @property
    def header(self):
        """Provide the header of the coordinate entity.

        :return: :class:`.Header`
        """
        return self._header

    @property
    def x( self ):
        """Position in the X axis for **all models**.

        :return: :class:`~pandas.Series`

        .. seealso::
            :meth:`.Frame3D.y`
            :meth:`.Frame3D.z`
            :meth:`.Frame3D.coordinates`
        """
        return self["Cartn_x"]

    @property
    def y( self ):
        """Position in the Y axis for **all models**.

        :return: :class:`~pandas.Series`

        .. seealso::
            :meth:`.Frame3D.x`
            :meth:`.Frame3D.z`
            :meth:`.Frame3D.coordinates`
        """
        return self["Cartn_y"]

    @property
    def z( self ):
        """Position in the Z axis for **all models**.

        :return: :class:`~pandas.Series`

        .. seealso::
            :meth:`.Frame3D.x`
            :meth:`.Frame3D.y`
            :meth:`.Frame3D.coordinates`
        """
        return self["Cartn_z"]

    @property
    def coordinates( self ):
        """Position in the 3D space for **all models**.

        :return: :class:`~numpy.ndarray`

        .. seealso::
            :meth:`.Frame3D.x`
            :meth:`.Frame3D.y`
            :meth:`.Frame3D.z`
        """
        return self[self._coord_tags].values

    # BOOLEAN CHECKS
    @property
    def is_empty( self ):
        """Evaluate if the coordinate entity contains data.

        :return: :class:`bool`
        """
        return len(self) == 0

    @property
    def has_header( self ):
        """Evaluate if the coordinate entity contains a :class:`.Header`
        with data content.

        :return: :class:`bool`
        """
        return not self.header.is_empty

    @property
    def has_water( self ):
        """Evaluate the presence of ``HOH`` components in the coordinate entity.

        :return: :class:`bool`

        .. seealso::
            :meth:`.Frame3D.is_dehydrated`
        """
        return not self.is_dehydrated

    @property
    def is_dehydrated( self ):
        """Evaluate the lack of ``HOH`` components in the coordinate entity.

        :return: :class:`bool`

        .. seealso::
            :meth:`.Frame3D.has_water`
        """
        return self[self[self._current_comp] == "HOH"].shape[0] == 0

    @property
    def has_insertion_codes( self ):
        """Checks if the coordinate entity contains insertion codes.

        Ignores waters and ligands.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.source``.

        :return: :class:`bool`
        """
        if core.get_option('structure', 'source') == 'label':
            return False  # label NEVER has insertion code
        else:
            if 'pdbx_PDB_ins_code' not in self.columns:
                return False
            else:
                df = self.dehydrate(False).remove_heteroatoms(False)
                df = list(df['pdbx_PDB_ins_code'].unique())
                try:
                    df.remove(' ')
                    return len(df) > 0
                except ValueError:
                    return True

    @property
    def is_NMR( self ):
        """Identifies if the PDB contains NMRs
        @rtype: Boolean
        """
        return self.NMR_count != 1

    @property
    def is_centered( self ):
        """Evaluate if the geometric center of the coordinate entity matches
        the center of coordinates.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

        :return: :class:`bool`

        .. seealso::
            :meth:`.Frame3D.geometric_center`
        """
        return np.allclose(np.zeros(3, float), self.geometric_center())

    # GEOMETRY METHODS
    def geometric_center( self ):
        """Get the geometric center of the coordinate entity.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

        :return: :class:`~numpy.ndarray`
        """
        return np.asarray(self._current_model[self._coord_tags].mean())

    def eigenvectors( self, module=2.0 ):
        """Return the three eigenvectors defining the coordinate entity.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

        :param float module: Module for the vectors.

        :return: :class:`~numpy.ndarray` - 3 vectors, ordered as *perpendicular*, *side* and *major* eigenvectors. Each
            vector contains 3 points: starting, center and end points to match the expected module length.
        """
        from SBI.structure.geometry import distance

        center = self.geometric_center()
        coordinates = self.coordinates

        A  = np.asmatrix(np.zeros((3, 3)))
        P  = coordinates - center
        for p in P:
            r = np.asmatrix(p)
            A += r.transpose() * r
        val, EigVc = np.linalg.eigh(A)
        vectors = []
        for axis in range(3):
            t = np.asarray(EigVc[:, axis]).reshape(3)
            vectors.append([np.around(np.asarray(center + (module / 2.0) * t, dtype=np.float32), decimals=3),
                            np.around(center, decimals=3),
                            np.around(np.asarray(center - (module / 2.0) * t, dtype=np.float32), decimals=3)])

        # Correct direction Major Axis
        if distance(vectors[2][0], coordinates[-1]) < distance(vectors[2][0], coordinates[0]):
            vectors[2] = np.flip(vectors[2], axis=0)

        return np.asarray(vectors)

    def translate( self, vector=None, inplace=True ):
        """Translate the coordinate entity according to the provided vector.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

        :param vector: 3D vector to apply to the Frame3D.
        :param vector: Union[:func:`list`, :class:`~numpy.ndarray`]
        :param bool inplace: When :data:`True` (default), changes are applied
            to the object itself. When :data:`False`, a new copy object is
            returned with the applied changes.

        :return: :class:`.Frame3D`

        :raise:
            :AttributeError: If vector has the wrong dimensionality.

        .. seealso::
            :meth:`.Frame3D.translate_x`
            :meth:`.Frame3D.translate_y`
            :meth:`.Frame3D.translate_z`
            :meth:`.Frame3D.translate_to_origin`
        """
        # If nothing is provided, substitute by the empty vector
        vector = np.zeros(3, float) if vector is None else vector

        # Check proper dimensionality
        vector = np.asarray(vector)
        if len(vector.shape) != 1 and vector.shape[0] != 3:
            raise AttributeError("The provided vector is not a 3D vector.")

        # Apply
        df = self.copy()
        dm = self._current_model.copy()
        # Only if really needed
        if not np.allclose(np.zeros(3, float), vector):
            dm[self._coord_tags] = dm.transform(lambda x: x[self._coord_tags] + vector, axis=1)
            df.update(dm)

        return self._inplace(df, inplace)

    def translate_x( self, x, inplace=True ):
        """Translate the coordinate entity in the ``x`` dimension.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

        :param float x: Translate value in the ``x`` dimension.
        :param bool inplace: When :data:`True` (default), changes are applied
            to the object itself. When :data:`False`, a new copy object is
            returned with the applied changes.

        :return: :class:`.Frame3D`

        .. seealso::
            :meth:`.Frame3D.translate`
            :meth:`.Frame3D.translate_y`
            :meth:`.Frame3D.translate_z`
            :meth:`.Frame3D.translate_to_origin`
        """
        return self.translate([float(x), 0., 0.], inplace)

    def translate_y( self, y, inplace=True ):
        """Translate the coordinate entity in the ``y`` dimension.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

        :param float y: Translate value in the ``y`` dimension.
        :param bool inplace: When :data:`True` (default), changes are applied
            to the object itself. When :data:`False`, a new copy object is
            returned with the applied changes.

        .. seealso::
            :meth:`.Frame3D.translate`
            :meth:`.Frame3D.translate_x`
            :meth:`.Frame3D.translate_z`
            :meth:`.Frame3D.translate_to_origin`
        """
        return self.translate([0., float(y), 0.], inplace)

    def translate_z( self, z, inplace=True ):
        """Translate the coordinate entity in the ``z`` dimension.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

        :param float z: Translate value in the ``z`` dimension.
        :param bool inplace: When :data:`True` (default), changes are applied
            to the object itself. When :data:`False`, a new copy object is
            returned with the applied changes.

        :return: :class:`.Frame3D`

        .. seealso::
            :meth:`.Frame3D.translate`
            :meth:`.Frame3D.translate_x`
            :meth:`.Frame3D.translate_y`
            :meth:`.Frame3D.translate_to_origin`
        """
        return self.translate([0., 0., float(z)], inplace)

    def translate_to_origin( self, inplace=True ):
        """Translate the coordinate entity to the center of coordinates.

        This is a specific application of :meth:`.Frame3D.translate`.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

        :param bool inplace: When :data:`True` (default), changes are applied
            to the object itself. When :data:`False`, a new copy object is
            returned with the applied changes.

        :return: :class:`.Frame3D`

        .. seealso::
            :meth:`.Frame3D.translate`
            :meth:`.Frame3D.translate_x`
            :meth:`.Frame3D.translate_y`
            :meth:`.Frame3D.translate_z`
        """
        return self.translate(-self.geometric_center(), inplace=True)

    def rotate( self, matrix=None, center=None, inplace=True ):
        """Rotate the coordinate entity over a given point.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

        :param matrix: 3D matrix (3x3) to apply to the coordinate entity.
        :param matrix: Union[:func:`list`, :class:`~numpy.ndarray`]
        :param center: Point over which rotate. Default is the center of coordinates (``[0., 0., 0.]``).
        :param center: Union[:func:`list`, :class:`~numpy.ndarray`]
        :param bool inplace: When :data:`True` (default), changes are applied
            to the object itself. When :data:`False`, a new copy object is
            returned with the applied changes.

        :return: :class:`.Frame3D`

        :raise:
            :AttributeError: If ``matrix`` does not have the right dimensionality.

        .. seealso::
            :meth:`.Frame3D.rotate_degrees`
            :meth:`.Frame3D.rotate_radiants`
            :meth:`.Frame3D.spin`
            :meth:`.Frame3D.spin_degrees`
            :meth:`.Frame3D.spin_radiants`
        """
        # If nothing is provided, substitute by the non-rotating matrix
        matrix = np.identity(3, float) if matrix is None else matrix

        # Check proper dimensionality
        matrix = np.asarray(matrix)
        if len(matrix.shape) != 2 and matrix.shape != (3, 3):
            raise AttributeError("The provided matrix is not a 3D vector.")

        # Apply
        df = self.copy()
        dm = self._current_model.copy()
        # Only if really needed
        if not np.allclose(np.identity(3, float), matrix):
            # @TODO: Simplify calculations
            # @BODY: Avoid translation of non-selected models and improve apply speed
            df.translate(center if center is None else -center, inplace=True)
            dm[self._coord_tags] = dm.apply(lambda x: pd.Series(np.dot(x[self._coord_tags], matrix)), axis=1)
            df.translate(center, inplace=True)
            df.update(dm)
        return self._inplace(df, inplace)

    def rotate_degrees( self, x=0, y=0, z=0, center=None, inplace=True ):
        """Rotate the coordinate entity over a given point.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

        :param float x: Degrees to rotate in the ``x`` axis.
        :param float y: Degrees to rotate in the ``y`` axis.
        :param float z: Degrees to rotate in the ``z`` axis.
        :param center: Point over which rotate. Default is the center of coordinates (``[0., 0., 0.]``).
        :param bool inplace: When :data:`True` (default), changes are applied
            to the object itself. When :data:`False`, a new copy object is
            returned with the applied changes.

        :return: :class:`.Frame3D`

        .. seealso::
            :meth:`.Frame3D.rotate`
            :meth:`.Frame3D.rotate_radiants`
            :meth:`.Frame3D.spin`
            :meth:`.Frame3D.spin_degrees`
            :meth:`.Frame3D.spin_radiants`
        """
        if x == 0 and y == 0 and z == 0:
            return self if inplace else self.copy()
        return self.rotate_radiants(np.radians(x), np.radians(y), np.radians(z), center, inplace)

    def rotate_radiants( self, x=0, y=0, z=0, center=None, inplace=True ):
        """Rotate the coordinate entity over a given point.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

        :param float x: Radiants to rotate in the ``x`` axis.
        :param float y: Radiants to rotate in the ``y`` axis.
        :param float z: Radiants to rotate in the ``z`` axis.
        :param center: Point over which rotate. Default is the center of coordinates (``[0., 0., 0.]``).
        :param bool inplace: When :data:`True` (default), changes are applied
            to the object itself. When :data:`False`, a new copy object is
            returned with the applied changes.

        :return: :class:`.Frame3D`

        .. seealso::
            :meth:`.Frame3D.rotate`
            :meth:`.Frame3D.rotate_degrees`
            :meth:`.Frame3D.spin`
            :meth:`.Frame3D.spin_degrees`
            :meth:`.Frame3D.spin_radiants`
        """
        if x == 0 and y == 0 and z == 0:
            return self if inplace else self.copy()

        Rx = euler2mat(x, 0, 0, "sxyz")
        Ry = euler2mat(0, y, 0, "sxyz")
        Rz = euler2mat(0, 0, z, "sxyz")
        R  = np.dot(Rz, np.dot(Rx, Ry))
        return self.rotate(R, center, inplace)

    def spin( self, matrix=None, inplace=True ):
        """Rotate the coordinate entity over its center of mass.

        This is a specific application of :meth:`.Frame3D.rotate`.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

        :param matrix: 3D matrix (3x3) to apply to the coordinate entity.
        :param matrix: Union[:func:`list`, :class:`~numpy.ndarray`]
        :param bool inplace: When :data:`True` (default), changes are applied
            to the object itself. When :data:`False`, a new copy object is
            returned with the applied changes.

        :return: :class:`.Frame3D`

        :raise:
            :AttributeError: If ``matrix`` does not have the right dimensionality.

        .. seealso::
            :meth:`.Frame3D.rotate`
            :meth:`.Frame3D.rotate_degrees`
            :meth:`.Frame3D.rotate_radiants`
            :meth:`.Frame3D.spin_degrees`
            :meth:`.Frame3D.spin_radiants`
        """
        return self.rotate(matrix, self.geometric_center(), inplace)

    def spin_degrees( self, x=0, y=0, z=0, inplace=True ):
        """Rotate the coordinate entity over its center of mass.

        This is a specific application of :meth:`.Frame3D.rotate_degrees`.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

        :param float x: Degrees to rotate in the ``x`` axis.
        :param float y: Degrees to rotate in the ``y`` axis.
        :param float z: Degrees to rotate in the ``z`` axis.
        :param bool inplace: When :data:`True` (default), changes are applied
            to the object itself. When :data:`False`, a new copy object is
            returned with the applied changes.

        :return: :class:`.Frame3D`

        .. seealso::
            :meth:`.Frame3D.rotate`
            :meth:`.Frame3D.rotate_degrees`
            :meth:`.Frame3D.rotate_radiants`
            :meth:`.Frame3D.spin`
            :meth:`.Frame3D.spin_radiants`
        """
        return self.spin_radiants(np.radians(x), np.radians(y), np.radians(z), inplace)

    def spin_radiants( self, x=0, y=0, z=0, center=None, inplace=True ):
        """Rotate the coordinate entity over its center of mass.

        This is a specific application of :meth:`.Frame3D.rotate_radiants`.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.model``.

        :param float x: Radiants to rotate in the ``x`` axis.
        :param float y: Radiants to rotate in the ``y`` axis.
        :param float z: Radiants to rotate in the ``z`` axis.
        :param bool inplace: When :data:`True` (default), changes are applied
            to the object itself. When :data:`False`, a new copy object is
            returned with the applied changes.

        :return: :class:`.Frame3D`

        .. seealso::
            :meth:`.Frame3D.rotate`
            :meth:`.Frame3D.rotate_degrees`
            :meth:`.Frame3D.rotate_radiants`
            :meth:`.Frame3D.spin`
            :meth:`.Frame3D.spin_degrees`
        """
        return self.rotate_radiants(x, y, z, self.geometric_center(), inplace)

    def distance_matrix( self, other ):
        """Generate a matrix with all vs. all distance for all availabe atoms.

        :param other: Other container against which to compare.
        :type other: :class:`.Frame3D`

        :return: :class:`~pandas.DataFrame`
        """
        return pd.DataFrame(sp.distance.cdist(self._current_model.coordinates,
                                              other._current_model.coordinates))

    # METHODS
    def current_model( self, inplace=True ):
        """Provide only the current working model.
        :param bool inplace: When True (default), changes are applied
            to the object itself. When False, a new copy object is
            returned with the applied changes.
        :return: Frame3D
        """
        df = self._current_model
        return self._inplace(df, inplace)

    def remove_heteroatoms( self, inplace=True ):
        """Remove all HETATM from the 3D structure. This excludes HETATM
        belonging to a polypeptide chain (protein/nucleotide) and waters.
        Applies to all models.

        :param bool inplace: When :data:`True` (default), changes are applied
            to the object itself. When :data:`False`, a new copy object is
            returned with the applied changes.

        :return: :class:`.Frame3D`

        :raises:
            :AttributeError: If ``group_PDB`` column is not present.
        """
        # Check if we only have HETATM; keep only waters, if any.
        if 'group_PDB' not in self.columns:
            raise AttributeError('Coordinate entity does not have enough data '
                                 'to differentiate ATOMS vs. HETATM.')
        if self.shape[0] == self[self['group_PDB'] == 'HETATM'].shape[0]:
            df = self[self[self._current_comp] == 'HOH']
        # Then, either we have multple chains or polypeptides with HETATM.
        # We fix in label source as that is the one that separates compounds
        # from polypeptides.
        else:
            ht_chains = set(self[(self["group_PDB"] == "HETATM")]["label_asym_id"].unique())
            at_chains = set(self[(self["group_PDB"] == "ATOM")]["label_asym_id"].unique())
            ht_chains.difference_update(at_chains)
            df = self[~self["label_asym_id"].isin(ht_chains)]
            dh = self[self["label_asym_id"].isin(ht_chains) & (self[self._current_comp] == "HOH")]
            df = pd.concat([df, dh], sort=False)

        if self.has_header:
            if inplace:
                self._header = self.header.remove_heteroatoms()
            else:
                df._header = self.header.remove_heteroatoms()
        return self._inplace(df, inplace, False)

    def dehydrate( self, inplace=True ):
        """Remove all the water atoms from the 3D structure. Applies to
        all models.

        :param bool inplace: When :data:`True` (default), changes are applied
            to the object itself. When :data:`False`, a new copy object is
            returned with the applied changes.

        :return: :class:`.Frame3D`
        """
        df = self[(self[self._current_comp] != 'HOH')]
        if self.has_header:
            if inplace:
                self._header = self.header.dehydrate()
            else:
                df._header = self.header.dehydrate()
        return self._inplace(df, inplace, False)

    def renumber( self, start=1, inplace=True ):
        """Renumber the residues of the :class:'.Frame3D'.

        .. note::
            This functionality depends on the :ref:`global configuration options <configuration>` ``structure.source``.
        """
        # @TODO: make renumber chain-aware in Frame3D
        src = core.get_option('structure', 'source')

        df = self

        gf = [list(group) for key, group in groupby(df[df._residue_columns].values.tolist())]
        max_value = len(gf)
        atoms = np.asarray([(len(x)) for x in gf])

        numbers = [[x, ] * atoms[i] for i, x in enumerate(range(start, start + max_value))]

        df[df._current_seq] = np.asarray(numbers).flatten()
        if src == 'auth' and 'pdbx_PDB_ins_code' in df.columns:
            df['pdbx_PDB_ins_code'] = np.asarray(['', ] * df.shape[0])

        df['id'] = list(range(1, df.shape[0] + 1))

        return self._inplace(df, inplace, False)

    # PRINT METHODS
    def write( self, output_file=None, format=None, force=None, clean=False ):
        """Dump the structure into a file.

        If the :class:`.Frame3D` is empty it just skips.

        :param str output_file: Name of the output file.
        :param str format: Structure format to output. If None, pick the default set format
            from the options.
        :param bool force: If True, overwrite existing file. Default picks from the global
            options.
        :param bool clean: If True, renumber atoms starting with one.

        :return: :class:`.Frame3D`

        :raise:
            :IOError: If trying to overwrite when not allowed.
        """
        force = force if force is not None else core.get_option("io", "overwrite")
        if not force and os.path.isfile(output_file):
            raise IOError("Unable to overwrite {}".format(output_file))

        if format is not None:
            core.check_option("structure", "format", format.lower())
        else:
            format = core.get_option("structure", "format")

        if self.is_empty:
            return self

        # TODO: clean

        if format.lower() == "pdb":
            mmPDB.write(self, output_file)

        return self

    # PRIVATE PROPERTIES
    @property
    def _coord_tags( self ):
        return ["Cartn_x", "Cartn_y", "Cartn_z"]

    @property
    def _current_comp( self ):
        current = "{}_comp_id".format(core.get_option("structure", "source"))
        return current if current in self.columns else 'auth_comp_id'

    @property
    def _current_seq( self ):
        current = '{}_seq_id'.format(core.get_option('structure', 'source'))
        return current if current in self.columns else 'auth_seq_id'

    @property
    def _current_atom( self ):
        current = "{}_atom_id".format(core.get_option("structure", "source"))
        return current if current in self.columns else 'auth_atom_id'

    @property
    def _current_asym( self ):
        return "{}_asym_id".format(core.get_option("structure", "source"))

    @property
    def _current_model( self ):
        # Some structure do not have MODEL==1: see 1KLD
        if core.get_option("structure", "model") == 0:
            return self
        try:
            cm = core.get_option("structure", "model")
            cm = cm if cm > 0 else self["pdbx_PDB_model_num"].min()
            return self[self["pdbx_PDB_model_num"] == cm]
        except KeyError:
            return self

    @property
    def _residue_columns( self ):
        if core.get_option("structure", "source") == 'auth' and 'pdbx_PDB_ins_code' in self.columns:
            return [self._current_seq, 'pdbx_PDB_ins_code']
        else:
            return [self._current_seq]

    # PRIVATE METHODS
    def _inplace( self, df, inplace, verify_is_copy=True ):
        if inplace:
            self._update_inplace(df, verify_is_copy)
            return self
        else:
            return df

    # MAGIC METHODS
    def __eq__( self, other ):
        """Evaluate if the content of two coordinate entities is the same.

        :param other: Object to compare with.
        :type other: Union[:class:`.Frame3D`, :class:`.AtomSeries`]

        :return: :class:`bool`

        :raises:
            :NotImplementedError: If an unexpected object type is provided.
        """
        from SBI.structure import AtomSeries
        if not isinstance(other, (Frame3D, AtomSeries)):
            raise NotImplementedError('Unable to compare incompatible objects')
        return ((super(Frame3D, self.sort_index().sort_index(axis=1)).__eq__(other.sort_index().sort_index(axis=1))).all()).all()

    def __add__( self, other ):
        """Implements inplace=False translate
        """
        return self.translate( other, inplace=False )

    def __iadd__( self, other ):
        """Implements inplace=True translate
        """
        return self.translate( other, inplace=True )

    def __mul__( self, other ):
        """Implements inplace=False rotation
        """
        return self.rotate( other, inplace=False)

    def __imul__( self, other ):
        """Implements inplace=False rotation
        """
        return self.rotate( other, inplace=True)

    def __getitem__( self, key ):
        """Implements positional access.
        """
        from SBI.structure.selectors import SelectionFormatError, SelectionTypeError
        if callable(getattr(key, 'selection', None)):
            return key.selection(self)
        if isinstance(key, six.string_types) and key not in self.columns:
            from SBI.structure import Selector
            try:
                return Selector(key).selection(self)
            except (SelectionFormatError, SelectionTypeError):
                pass
        return super(Frame3D, self).__getitem__(key)

    def __str__(self):
        return pd.DataFrame(self).__str__()

    # PANDAS METHODS
    @property
    def _constructor( self ):
        def f(*args, **kwargs):
            try:
                return frame3D_classify(Frame3D(*args, **kwargs))
            except Frame3DCreationError:
                return frame3D_classify(pd.DataFrame(*args, **kwargs))
        return f

    @property
    def _constructor_sliced( self ):
        def f(*args, **kwargs):
            return frame3D_classify(pd.Series(*args, **kwargs))
        return f

    def _repr_html_( self ):
        return pd.DataFrame(self)._repr_html_()

    def __finalize__( self, other, method=None, **kwargs ):
        if method == 'concat':
            df = frame3D_classify(self)
            df._id = other.objs[0]._id
            df._header = other.objs[0].header
            for o in range(1, len(other.objs)):
                if not other.objs[o].header.is_empty:
                    df._header = df.header.concat(other.objs[o].header)
            return df
        else:
            df = super(Frame3D, self).__finalize__(other, method, **kwargs)
            df._id = self._id
            if self.has_header:
                self._header = self.header.filter_by_entities(self[self._current_asym].unique())
            return df

    def equals( self, other ):
        """
        Determines if two :class:`.Frame3D` objects contain the same elements. NaNs in
        the same location are considered equal.
        """
        # equals needs to be overwritten from regular DataFrames, as Frame3D derived
        # classes do not provide classes for constructors but functions. This is a very
        # specific issue, as this happens even when dimensionality is kept.
        return self._data.equals(other._data)


def frame3D_classify( frame ):
    """For slicing and expanding, decide the class that the coordinate entity must have.

    .. note::
        This functionality depends on the :ref:`global configuration options <configuration>` ``structure.source``.

    The logic to decide the classing of the data will go as follows:

    1. The coordinate entity is a base :class:`~pandas.DataFrame` or :class:`~pandas.Series`
        if it does not have all the expected columns/index that define derived classes.
    2. If the coordinate entity is empty, it is of whatever class it was entering the function.
    3. The coordinate entity is a :class:`.PDBFrame` if there is more than one chain present
        according to the selected ``structure.source``.
    4. The coordinate entity is a :class:`.ChainFrame` if there is only one chain present but more
        than one residue in it. Decision between regular :class:`.ChainFrame` or the special classes
        :class:`.ProteinChainFrame` and :class:`.NucleotideChainFrame` will be taken according to the
        chain presenting residue types related to those classes.

    :param frame: Coordinate entity that needs to be evaluated.
    :type frame: Union[:class:`~pandas.DataFrame`, :class:`~pandas.Series`]

    :return: :class:`.Frame3D`

    :raises:
        :AttributeError: If ``frame`` is not in the allowed input classes.
    """
    from SBI.data import alphabet
    from SBI.structure import (PDBFrame,
                               ChainFrame, ProteinChainFrame, NucleotideChainFrame,
                               ResidueFrame, ProteinResidueFrame, NucleotideResidueFrame,
                               AtomSeries, VirtualAtom)
    if not isinstance(frame, (pd.Series, pd.DataFrame)):
        raise AttributeError('Class of type {} cannot be casted to Frame3D-derived class.'.format(type(frame)))

    # Work separately depending on the type.
    if isinstance(frame, pd.DataFrame):
        # Discard when it cannot fit our requirements
        # This is also necessary when printing, as columns might be skipped and can generate errors.
        if not set(mandatory_fields).issubset(frame.columns):
            return pd.DataFrame(frame)
        # At this point, the thing has to derive from Frame3D
        if not isinstance(frame, Frame3D):
            frame = Frame3D(frame)
        # If it is empty, returs as is
        if frame.empty:
            return frame
        # If we have more than one chain, give a PDBContainer
        if len(frame[frame._current_asym].unique()) > 1 or frame.is_empty:
            return PDBFrame(frame)
        else:
            # If we have more than one residue, we will provide a chain.
            # By the residue types, we should be able to guess which chain type.
            if len(frame[frame._current_seq].unique()) > 1:
                if (frame[frame._current_comp].isin(alphabet.aminoacids_main3) == True).any():
                    return ProteinChainFrame(frame)
                elif (frame[frame._current_comp].isin(alphabet.nucleotide_main) == True).any():
                    return NucleotideChainFrame(frame)
                else:
                    return ChainFrame(frame)
            else:
                name = frame[frame._current_comp].unique()[0]
                if alphabet.is_aminoacid(name):
                    return ProteinResidueFrame(frame)
                elif alphabet.is_nucleotide(name):
                    return NucleotideResidueFrame(frame)
                else:
                    return ResidueFrame(frame)

    if isinstance(frame, pd.Series):
        # Discard when it cannot fit our requirements
        # This is also necessary when printing, as columns might be skipped and can generate errors.
        if not set(mandatory_fields).issubset(frame.index):
            return pd.Series(frame)
        frame = AtomSeries(frame)
        if 'group_PDB' in frame.index:
            if frame['group_PDB'] == 'VIRATOM':
                return VirtualAtom(frame)
        return frame


class Frame3DCreationError( Exception ):
    """Raises an error when a :class:`.Frame3` cannot be created.
    """
