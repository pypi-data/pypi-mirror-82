from ._1 import *

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GlipCreatePost(DataClassJsonMixin):
    activity: Optional[str] = None
    title: Optional[str] = None
    """ Title of a message. (Can be set for bot's messages only). """
    
    text: Optional[str] = None
    """ Text of a post """
    
    group_id: Optional[str] = None
    """ Internal identifier of a group """
    
    attachments: Optional[List[GlipCreatePostAttachmentsItem]] = None
    """ List of attachments to be posted """
    
    person_ids: Optional[List[str]] = None
    system: Optional[bool] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GlipPostTeamBody(DataClassJsonMixin):
    """
    Required Properties:
     - name
    
    Generated by Python OpenAPI Parser
    """
    
    name: str
    """ Team name. """
    
    public: Optional[bool] = None
    """ Team access level. """
    
    description: Optional[str] = None
    """ Team description. """
    
    members: Optional[List[dict]] = None
    """ List of glip members """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GlipPatchTeamBody(DataClassJsonMixin):
    public: Optional[bool] = None
    """ Team access level """
    
    name: Optional[str] = None
    """ Team name. Maximum number of characters supported is 250 """
    
    description: Optional[str] = None
    """ Team description. Maximum number of characters supported is 1000 """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GlipPostsList(DataClassJsonMixin):
    """
    Required Properties:
     - records
    
    Generated by Python OpenAPI Parser
    """
    
    records: list
    """ List of posts """
    

class GetGlipNoteInfoStatus(Enum):
    """
    Note publishing status. Any note is created in 'Draft' status. After it is posted it becomes
    'Active'
    
    Generated by Python OpenAPI Parser
    """
    
    Active = 'Active'
    Draft = 'Draft'

class GetGlipNoteInfoType(Enum):
    Note = 'Note'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetGlipNoteInfo(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a note """
    
    title: Optional[str] = None
    """ Title of a note """
    
    chat_ids: Optional[List[str]] = None
    """ Internal identifiers of the chat(s) where the note is posted or shared. """
    
    preview: Optional[str] = None
    """ Preview of a note (first 150 characters of a body) """
    
    body: Optional[str] = None
    """ Text of a note """
    
    creator: Optional[dict] = None
    """ Note creator information """
    
    last_modified_by: Optional[dict] = None
    """ Note last modification information """
    
    locked_by: Optional[dict] = None
    """
    Returned for the note being edited (locked) at the current moment. Information on the user
    editing the note
    """
    
    status: Optional[GetGlipNoteInfoStatus] = None
    """
    Note publishing status. Any note is created in 'Draft' status. After it is posted it becomes
    'Active'
    """
    
    creation_time: Optional[str] = None
    """ Creation time """
    
    last_modified_time: Optional[str] = None
    """ Datetime of the note last update """
    
    type: Optional[GetGlipNoteInfoType] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class EditGroupRequest(DataClassJsonMixin):
    added_person_ids: Optional[List[str]] = None
    """ List of users to be added to a team """
    
    added_person_emails: Optional[List[str]] = None
    """ List of user email addresses to be added to a team (i.e. as guests) """
    
    removed_person_ids: Optional[List[str]] = None
    """ List of users to be removed from a team """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GlipChatsList(DataClassJsonMixin):
    """
    Required Properties:
     - records
    
    Generated by Python OpenAPI Parser
    """
    
    records: list
    """ List of chats """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateGlipEveryoneRequest(DataClassJsonMixin):
    name: Optional[int] = None
    """ Everyone chat name. Maximum number of characters supported is 250 """
    
    description: Optional[str] = None
    """ Everyone chat description. Maximum number of characters supported is 1000 """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GlipNotesInfo(DataClassJsonMixin):
    records: Optional[list] = None

class MeetingResponseResourceMeetingType(Enum):
    Instant = 'Instant'
    Scheduled = 'Scheduled'
    ScheduledRecurring = 'ScheduledRecurring'
    Recurring = 'Recurring'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingResponseResourceLinks(DataClassJsonMixin):
    start_uri: Optional[str] = None
    join_uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingResponseResourceScheduleTimeZone(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingResponseResourceSchedule(DataClassJsonMixin):
    start_time: Optional[str] = None
    duration_in_minutes: Optional[int] = None
    time_zone: Optional[MeetingResponseResourceScheduleTimeZone] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingResponseResourceHost(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to the meeting host resource """
    
    id: Optional[str] = None
    """
    Internal identifier of an extension which is assigned to be a meeting host. The default value
    is currently logged-in extension identifier
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingResponseResourceOccurrencesItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Identifier of a meeting occurrence """
    
    start_time: Optional[str] = None
    """ Starting time of a meeting occurrence """
    
    duration_in_minutes: Optional[int] = None
    """ Duration of a meeting occurrence """
    
    status: Optional[str] = None
    """ Status of a meeting occurrence """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingResponseResource(DataClassJsonMixin):
    uri: Optional[str] = None
    uuid: Optional[str] = None
    id: Optional[str] = None
    topic: Optional[str] = None
    meeting_type: Optional[MeetingResponseResourceMeetingType] = None
    password: Optional[str] = None
    h323_password: Optional[str] = None
    status: Optional[str] = None
    links: Optional[MeetingResponseResourceLinks] = None
    schedule: Optional[MeetingResponseResourceSchedule] = None
    host: Optional[MeetingResponseResourceHost] = None
    allow_join_before_host: Optional[bool] = False
    start_host_video: Optional[bool] = False
    start_participants_video: Optional[bool] = False
    audio_options: Optional[List[str]] = None
    occurrences: Optional[List[MeetingResponseResourceOccurrencesItem]] = None
    """ List of meeting occurrences """
    

class MeetingUserSettingsResponseRecordingAutoRecording(Enum):
    """ Automatical recording (local/cloud/none) of meetings as they start """
    
    Local = 'local'
    Cloud = 'cloud'
    None_ = 'none'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingUserSettingsResponseRecording(DataClassJsonMixin):
    local_recording: Optional[bool] = None
    """ Allows hosts and participants to record a meeting to a local file """
    
    cloud_recording: Optional[bool] = None
    """ Allows hosts to record and save a meeting/webinar in the cloud """
    
    record_speaker_view: Optional[bool] = False
    """ Allows to record active speaker with the shared screen """
    
    record_gallery_view: Optional[bool] = False
    """ Allows to record gallery view with the shared screen """
    
    record_audio_file: Optional[bool] = False
    """ Allows to record an audio-only file """
    
    save_chat_text: Optional[bool] = False
    """ Allows to save chat text from a meeting """
    
    show_timestamp: Optional[bool] = False
    """ Allows to show timestamp on video """
    
    auto_recording: Optional[MeetingUserSettingsResponseRecordingAutoRecording] = 'local'
    """ Automatical recording (local/cloud/none) of meetings as they start """
    
    auto_delete_cmr: Optional[str] = False
    """ Automatical deletion of cloud recordings """
    
    auto_delete_cmr_days: Optional[int] = None
    """
    A specified number of days for automatical deletion of cloud recordings, the value range is
    1-60
    """
    

class MeetingUserSettingsResponseScheduleMeetingAudioOptionsItem(Enum):
    Phone = 'Phone'
    ComputerAudio = 'ComputerAudio'

class MeetingUserSettingsResponseScheduleMeetingRequirePasswordForPmiMeetings(Enum):
    """
    Specifies whether to require a password for meetings using Personal Meeting ID (PMI). The
    supported values are: 'none', 'all' and 'jbhOnly' (joined before host only)
    
    Generated by Python OpenAPI Parser
    """
    
    All = 'all'
    None_ = 'none'
    JbhOnly = 'jbhOnly'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingUserSettingsResponseScheduleMeeting(DataClassJsonMixin):
    """ Settings defining how to schedule user meetings """
    
    start_host_video: Optional[bool] = None
    """ Starting meetings with host video on/off (true/false) """
    
    start_participants_video: Optional[bool] = None
    """ Starting meetings with participant video on/off (true/false) """
    
    audio_options: Optional[List[MeetingUserSettingsResponseScheduleMeetingAudioOptionsItem]] = None
    """ Determines how participants can join the audio channel of a meeting """
    
    allow_join_before_host: Optional[bool] = None
    """ Allows participants to join the meeting before the host arrives """
    
    use_pmi_for_scheduled_meetings: Optional[bool] = None
    """ Determines whether to use Personal Meeting ID (PMI) when scheduling a meeting """
    
    use_pmi_for_instant_meetings: Optional[bool] = None
    """ Determines whether to use Personal Meeting ID (PMI) when starting an instant meeting """
    
    require_password_for_scheduling_new_meetings: Optional[bool] = None
    """
    A password will be generated when scheduling a meeting and participants will require password
    to join a meeting. The Personal Meeting ID (PMI) meetings are not included
    """
    
    require_password_for_scheduled_meetings: Optional[bool] = None
    """ Specifies whether to require a password for meetings which have already been scheduled """
    
    default_password_for_scheduled_meetings: Optional[str] = None
    """ Password for already scheduled meetings. Users can set it individually """
    
    require_password_for_instant_meetings: Optional[bool] = None
    """
    A random password will be generated for an instant meeting, if set to 'True'. If you use PMI
    for your instant meetings, this option will be disabled
    """
    
    require_password_for_pmi_meetings: Optional[MeetingUserSettingsResponseScheduleMeetingRequirePasswordForPmiMeetings] = None
    """
    Specifies whether to require a password for meetings using Personal Meeting ID (PMI). The
    supported values are: 'none', 'all' and 'jbhOnly' (joined before host only)
    """
    
    pmi_password: Optional[str] = None
    """ The default password for Personal Meeting ID (PMI) meetings """
    
    pstn_password_protected: Optional[bool] = None
    """ Specifies whether to generate and require a password for participants joining by phone """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingUserSettingsResponse(DataClassJsonMixin):
    recording: Optional[MeetingUserSettingsResponseRecording] = None
    schedule_meeting: Optional[MeetingUserSettingsResponseScheduleMeeting] = None
    """ Settings defining how to schedule user meetings """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingServiceInfoRequestExternalUserInfo(DataClassJsonMixin):
    uri: Optional[str] = None
    user_id: Optional[str] = None
    account_id: Optional[str] = None
    user_type: Optional[int] = None
    user_token: Optional[str] = None
    host_key: Optional[str] = None
    personal_meeting_id: Optional[str] = None
    personal_link: Optional[str] = None
    """
    Link to the user's personal meeting room, used as an alias for personal meeting URL (with
    personal meeting ID)
    
    Example: `https://meetings.ringcentral.com/my/jsmith`
    """
    
    use_pmi_for_instant_meetings: Optional[bool] = False
    """ Enables using personal meeting ID for instant meetings """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingServiceInfoRequest(DataClassJsonMixin):
    external_user_info: Optional[MeetingServiceInfoRequestExternalUserInfo] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AssistedUsersResourceRecordsItem(DataClassJsonMixin):
    id: Optional[str] = None
    name: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AssistedUsersResource(DataClassJsonMixin):
    records: Optional[List[AssistedUsersResourceRecordsItem]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingsResourcePaging(DataClassJsonMixin):
    page: Optional[int] = None
    total_pages: Optional[int] = None
    per_page: Optional[int] = None
    total_elements: Optional[int] = None
    page_start: Optional[int] = None
    page_end: Optional[int] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingsResourceNavigationNextPage(DataClassJsonMixin):
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingsResourceNavigation(DataClassJsonMixin):
    next_page: Optional[MeetingsResourceNavigationNextPage] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingsResource(DataClassJsonMixin):
    uri: Optional[str] = None
    records: Optional[list] = None
    paging: Optional[MeetingsResourcePaging] = None
    navigation: Optional[MeetingsResourceNavigation] = None

class MeetingRequestResourceMeetingType(Enum):
    Instant = 'Instant'
    Scheduled = 'Scheduled'
    ScheduledRecurring = 'ScheduledRecurring'
    Recurring = 'Recurring'

class MeetingRequestResourceRecurrenceFrequency(Enum):
    """ Recurrence time frame """
    
    Daily = 'Daily'
    Weekly = 'Weekly'
    Monthly = 'Monthly'

class MeetingRequestResourceRecurrenceMonthlyByWeek(Enum):
    """ Supported together with `weeklyByDay` """
    
    Last = 'Last'
    First = 'First'
    Second = 'Second'
    Third = 'Third'
    Fourth = 'Fourth'

class MeetingRequestResourceRecurrenceWeeklyByDay(Enum):
    Sunday = 'Sunday'
    Monday = 'Monday'
    Tuesday = 'Tuesday'
    Wednesday = 'Wednesday'
    Thursday = 'Thursday'
    Friday = 'Friday'
    Saturday = 'Saturday'

class MeetingRequestResourceRecurrenceWeeklyByDays(Enum):
    """ Multiple values are supported, should be specified separated by comma """
    
    Sunday = 'Sunday'
    Monday = 'Monday'
    Tuesday = 'Tuesday'
    Wednesday = 'Wednesday'
    Thursday = 'Thursday'
    Friday = 'Friday'
    Saturday = 'Saturday'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingRequestResourceRecurrence(DataClassJsonMixin):
    """ Recurrence settings """
    
    frequency: Optional[MeetingRequestResourceRecurrenceFrequency] = None
    """ Recurrence time frame """
    
    interval: Optional[int] = None
    """
    Reccurence interval. The supported ranges are: 1-90 for `Daily`; 1-12 for `Weekly`; 1-3 for
    `Monthly`
    """
    
    monthly_by_week: Optional[MeetingRequestResourceRecurrenceMonthlyByWeek] = None
    """ Supported together with `weeklyByDay` """
    
    weekly_by_day: Optional[MeetingRequestResourceRecurrenceWeeklyByDay] = None
    weekly_by_days: Optional[MeetingRequestResourceRecurrenceWeeklyByDays] = None
    """ Multiple values are supported, should be specified separated by comma """
    
    monthly_by_day: Optional[int] = None
    """ The supported range is 1-31 """
    
    count: Optional[int] = None
    """ Number of occurences """
    
    until: Optional[str] = None
    """ Meeting expiration datetime """
    

class MeetingRequestResourceAutoRecordType(Enum):
    """ Automatic record type """
    
    Local = 'local'
    Cloud = 'cloud'
    None_ = 'none'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingRequestResource(DataClassJsonMixin):
    topic: Optional[str] = None
    meeting_type: Optional[MeetingRequestResourceMeetingType] = None
    password: Optional[str] = None
    allow_join_before_host: Optional[bool] = False
    start_host_video: Optional[bool] = False
    start_participants_video: Optional[bool] = False
    use_personal_meeting_id: Optional[bool] = None
    audio_options: Optional[List[str]] = None
    recurrence: Optional[MeetingRequestResourceRecurrence] = None
    """ Recurrence settings """
    
    auto_record_type: Optional[MeetingRequestResourceAutoRecordType] = 'local'
    """ Automatic record type """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AccountLockedSettingResponse(DataClassJsonMixin):
    schedule_meeting: Optional[dict] = None
    """ Scheduling meeting settings locked on account level """
    
    recording: Optional[dict] = None
    """ Meeting recording settings locked on account level """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingServiceInfoResourceDialInNumbersItemCountry(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    iso_code: Optional[str] = None
    calling_code: Optional[str] = None
    emergency_calling: Optional[bool] = False
    number_selling: Optional[bool] = False
    login_allowed: Optional[bool] = False

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingServiceInfoResourceDialInNumbersItem(DataClassJsonMixin):
    phone_number: Optional[str] = None
    formatted_number: Optional[str] = None
    location: Optional[str] = None
    country: Optional[MeetingServiceInfoResourceDialInNumbersItemCountry] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class MeetingServiceInfoResource(DataClassJsonMixin):
    uri: Optional[str] = None
    support_uri: Optional[str] = None
    intl_dial_in_numbers_uri: Optional[str] = None
    dial_in_numbers: Optional[List[MeetingServiceInfoResourceDialInNumbersItem]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AssistantsResourceRecordsItem(DataClassJsonMixin):
    id: Optional[str] = None
    name: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AssistantsResource(DataClassJsonMixin):
    records: Optional[List[AssistantsResourceRecordsItem]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class PublicMeetingInvitationResponse(DataClassJsonMixin):
    invitation: Optional[str] = None
    """ Meeting invitation """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class RecordsCollectionResourceSubscriptionResponseRecordsItemDisabledFiltersItem(DataClassJsonMixin):
    filter: Optional[str] = None
    """ Event filter that is disabled for the user """
    
    reason: Optional[str] = None
    """ Reason why the filter is disabled for the user """
    
    message: Optional[str] = None
    """ Error message """
    

class RecordsCollectionResourceSubscriptionResponseRecordsItemStatus(Enum):
    """ Subscription status """
    
    Active = 'Active'
    Suspended = 'Suspended'
    Blacklisted = 'Blacklisted'

class RecordsCollectionResourceSubscriptionResponseRecordsItemDeliveryModeTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class RecordsCollectionResourceSubscriptionResponseRecordsItemDeliveryMode(DataClassJsonMixin):
    """ Delivery mode data """
    
    encryption: Optional[bool] = None
    """ Optional parameter. Specifies if the message will be encrypted or not """
    
    address: Optional[str] = None
    """ PubNub channel name """
    
    subscriber_key: Optional[str] = None
    """ PubNub subscriber credentials required to subscribe to the channel """
    
    secret_key: Optional[str] = None
    """
    PubNub subscriber credentials required to subscribe to the channel. Optional (for PubNub
    transport type only)
    """
    
    encryption_algorithm: Optional[str] = None
    """ Encryption algorithm 'AES' (for PubNub transport type only) """
    
    encryption_key: Optional[str] = None
    """ Key for notification message decryption (for PubNub transport type only) """
    
    transport_type: Optional[RecordsCollectionResourceSubscriptionResponseRecordsItemDeliveryModeTransportType] = None
    """ Notifications transportation provider name """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class RecordsCollectionResourceSubscriptionResponseRecordsItemBlacklistedData(DataClassJsonMixin):
    """ Returned if WebHook subscription is blacklisted """
    
    blacklisted_at: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Time of adding subscrition to a black list in [ISO
    8601](https://en.wikipedia.org/wiki/ISO_8601) format including timezone, for example
    *2016-03-10T18:07:52.534Z*
    """
    
    reason: Optional[str] = None
    """ Reason for adding subscrition to a black list """
    

class RecordsCollectionResourceSubscriptionResponseRecordsItemTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class RecordsCollectionResourceSubscriptionResponseRecordsItem(DataClassJsonMixin):
    """
    Required Properties:
     - delivery_mode
    
    Generated by Python OpenAPI Parser
    """
    
    delivery_mode: RecordsCollectionResourceSubscriptionResponseRecordsItemDeliveryMode
    """ Delivery mode data """
    
    id: Optional[str] = None
    """ Internal identifier of a subscription """
    
    uri: Optional[str] = None
    """ Canonical URI of a subscription """
    
    event_filters: Optional[List[str]] = None
    """
    Collection of API resources (message-store/presence/detailed presence) corresponding to events
    the user is subscribed to
    """
    
    disabled_filters: Optional[List[RecordsCollectionResourceSubscriptionResponseRecordsItemDisabledFiltersItem]] = None
    """
    Collection of API resources (message-store/presence/detailed presence) corresponding to events
    the user is not subscribed to due to certain limitations
    """
    
    expiration_time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Subscription expiration datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format
    including timezone, for example 2016-03-10T18:07:52.534Z
    """
    
    expires_in: Optional[int] = 900
    """ Subscription lifetime in seconds """
    
    status: Optional[RecordsCollectionResourceSubscriptionResponseRecordsItemStatus] = None
    """ Subscription status """
    
    creation_time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Subscription creation datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format
    including timezone, for example 2016-03-10T18:07:52.534Z
    """
    
    blacklisted_data: Optional[RecordsCollectionResourceSubscriptionResponseRecordsItemBlacklistedData] = None
    """ Returned if WebHook subscription is blacklisted """
    
    transport_type: Optional[RecordsCollectionResourceSubscriptionResponseRecordsItemTransportType] = None
    """ Notifications transportation provider name """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class RecordsCollectionResourceSubscriptionResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    records: Optional[List[RecordsCollectionResourceSubscriptionResponseRecordsItem]] = None

class CreateSubscriptionRequestDeliveryModeTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSubscriptionRequestDeliveryMode(DataClassJsonMixin):
    """ Notification delivery settings """
    
    transport_type: Optional[CreateSubscriptionRequestDeliveryModeTransportType] = None
    """ Notifications transportation provider name """
    
    address: Optional[str] = None
    """
    Mandatory for 'WebHook' transport type, URL of a consumer service (cannot be changed during
    subscription update)
    """
    
    encryption: Optional[bool] = None
    """
    Optional parameter. Specifies if the message will be encrypted or not. If request contains any
    presence event filter the value by default is 'True' (even if specified as 'false'). If request
    contains only message event filters the value by default is 'False'
    """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    verification_token: Optional[str] = None
    """
    Verification key of a subscription ensuring data security. Supported for 'Webhook' transport
    type
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSubscriptionRequest(DataClassJsonMixin):
    """
    Required Properties:
     - delivery_mode
     - event_filters
    
    Generated by Python OpenAPI Parser
    """
    
    event_filters: List[str]
    """ Collection of URIs to API resources """
    
    delivery_mode: CreateSubscriptionRequestDeliveryMode
    """ Notification delivery settings """
    
    expires_in: Optional[int] = 604800
    """
    Subscription lifetime in seconds. Max value is 7 days (604800 sec). For *WebHook* transport
    type max value might be set up to 630720000 seconds (20 years)
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ModifySubscriptionRequest(DataClassJsonMixin):
    """
    Required Properties:
     - event_filters
    
    Generated by Python OpenAPI Parser
    """
    
    event_filters: List[str]
    """ Collection of URIs to API resources """
    
    delivery_mode: Optional[dict] = None
    """ Notification delivery settings """
    
    expires_in: Optional[int] = 604800
    """
    Subscription lifetime in seconds. Max value is 7 days (604800 sec). For *WebHook* transport
    type max value might be set up to 630720000 seconds (20 years)
    """
    

class AuthProfileResourcePermissionsItemPermissionSiteCompatible(Enum):
    """ Site compatibility flag set for permission """
    
    Compatible = 'Compatible'
    Incompatible = 'Incompatible'
    Independent = 'Independent'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AuthProfileResourcePermissionsItemPermission(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None
    site_compatible: Optional[AuthProfileResourcePermissionsItemPermissionSiteCompatible] = None
    """ Site compatibility flag set for permission """
    
    read_only: Optional[bool] = None
    """ Specifies if the permission is editable on UI (if set to 'True') or not (if set to 'False') """
    
    assignable: Optional[bool] = None
    """ Specifies if the permission can be assigned by the account administrator """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AuthProfileResourcePermissionsItemEffectiveRole(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None

class AuthProfileResourcePermissionsItemScopesItem(Enum):
    Account = 'Account'
    AllExtensions = 'AllExtensions'
    Federation = 'Federation'
    NonUserExtensions = 'NonUserExtensions'
    RoleBased = 'RoleBased'
    Self = 'Self'
    UserExtensions = 'UserExtensions'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AuthProfileResourcePermissionsItem(DataClassJsonMixin):
    permission: Optional[AuthProfileResourcePermissionsItemPermission] = None
    effective_role: Optional[AuthProfileResourcePermissionsItemEffectiveRole] = None
    scopes: Optional[List[AuthProfileResourcePermissionsItemScopesItem]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AuthProfileResource(DataClassJsonMixin):
    uri: Optional[str] = None
    permissions: Optional[List[AuthProfileResourcePermissionsItem]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AuthProfileCheckResource(DataClassJsonMixin):
    uri: Optional[str] = None
    successful: Optional[bool] = False

class AnsweringRuleInfoType(Enum):
    """ Type of an answering rule """
    
    BusinessHours = 'BusinessHours'
    AfterHours = 'AfterHours'
    Custom = 'Custom'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoScheduleWeeklyRangesMondayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoScheduleWeeklyRanges(DataClassJsonMixin):
    """ Weekly schedule """
    
    monday: Optional[List[AnsweringRuleInfoScheduleWeeklyRangesMondayItem]] = None
    """ Time intervals for a particular day """
    
    tuesday: Optional[list] = None
    """ Time intervals for a particular day """
    
    wednesday: Optional[list] = None
    """ Time intervals for a particular day """
    
    thursday: Optional[list] = None
    """ Time intervals for a particular day """
    
    friday: Optional[list] = None
    """ Time intervals for a particular day """
    
    saturday: Optional[list] = None
    """ Time intervals for a particular day """
    
    sunday: Optional[list] = None
    """ Time intervals for a particular day """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoScheduleRangesItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """
    Starting datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601), for example
    *2018-10-29T14:00:00*, *2018-10-29T14:00:00Z*, *2018-10-29T14:00:00+0100*
    """
    
    to: Optional[str] = None
    """
    Ending datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601), for example
    *2018-10-29T14:00:00*, *2018-10-29T14:00:00Z*, *2018-10-29T14:00:00+0100*
    """
    

class AnsweringRuleInfoScheduleRef(Enum):
    """
    The user's schedule specified for business hours or after hours; it can also be set/retrieved
    calling the corresponding method
    
    Generated by Python OpenAPI Parser
    """
    
    BusinessHours = 'BusinessHours'
    AfterHours = 'AfterHours'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoSchedule(DataClassJsonMixin):
    """ Schedule when an answering rule should be applied """
    
    weekly_ranges: Optional[AnsweringRuleInfoScheduleWeeklyRanges] = None
    """ Weekly schedule """
    
    ranges: Optional[List[AnsweringRuleInfoScheduleRangesItem]] = None
    """ Specific data ranges """
    
    ref: Optional[AnsweringRuleInfoScheduleRef] = None
    """
    The user's schedule specified for business hours or after hours; it can also be set/retrieved
    calling the corresponding method
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoCalledNumbersItem(DataClassJsonMixin):
    phone_number: Optional[str] = None
    """ Called phone number """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoCallersItem(DataClassJsonMixin):
    caller_id: Optional[str] = None
    """ Phone number of a caller """
    
    name: Optional[str] = None
    """ Contact name of a caller """
    

class AnsweringRuleInfoCallHandlingAction(Enum):
    """ Specifies how incoming calls are forwarded """
    
    ForwardCalls = 'ForwardCalls'
    UnconditionalForwarding = 'UnconditionalForwarding'
    AgentQueue = 'AgentQueue'
    TransferToExtension = 'TransferToExtension'
    TakeMessagesOnly = 'TakeMessagesOnly'
    PlayAnnouncementOnly = 'PlayAnnouncementOnly'
    SharedLines = 'SharedLines'

class AnsweringRuleInfoForwardingRingingMode(Enum):
    """
    Specifies the order in which forwarding numbers ring. 'Sequentially' means that forwarding
    numbers are ringing one at a time, in order of priority. 'Simultaneously' means that forwarding
    numbers are ring all at the same time
    
    Generated by Python OpenAPI Parser
    """
    
    Sequentially = 'Sequentially'
    Simultaneously = 'Simultaneously'

class AnsweringRuleInfoForwardingRulesItemForwardingNumbersItemLabel(Enum):
    """ Forwarding/Call flip number title """
    
    Business_Mobile_Phone = 'Business Mobile Phone'

class AnsweringRuleInfoForwardingRulesItemForwardingNumbersItemType(Enum):
    """ Type of a forwarding number """
    
    Home = 'Home'
    Mobile = 'Mobile'
    Work = 'Work'
    PhoneLine = 'PhoneLine'
    Outage = 'Outage'
    Other = 'Other'
    BusinessMobilePhone = 'BusinessMobilePhone'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoForwardingRulesItemForwardingNumbersItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a forwarding number """
    
    uri: Optional[str] = None
    """ Canonical URI of a forwarding/call flip phone number """
    
    phone_number: Optional[str] = None
    """ Forwarding/Call flip phone number """
    
    label: Optional[AnsweringRuleInfoForwardingRulesItemForwardingNumbersItemLabel] = None
    """ Forwarding/Call flip number title """
    
    type: Optional[AnsweringRuleInfoForwardingRulesItemForwardingNumbersItemType] = None
    """ Type of a forwarding number """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoForwardingRulesItem(DataClassJsonMixin):
    index: Optional[int] = None
    """ Forwarding number (or group) ordinal """
    
    ring_count: Optional[int] = None
    """ Number of rings for a forwarding number (or group) """
    
    enabled: Optional[bool] = None
    """ Forwarding number status. Returned only if `showInactiveNumbers` is set to `true` """
    
    forwarding_numbers: Optional[List[AnsweringRuleInfoForwardingRulesItemForwardingNumbersItem]] = None
    """ Forwarding number (or group) data """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoForwarding(DataClassJsonMixin):
    """
    Forwarding parameters. Returned if 'ForwardCalls' is specified in 'callHandlingAction'. These
    settings determine the forwarding numbers to which the call will be forwarded
    
    Generated by Python OpenAPI Parser
    """
    
    notify_my_soft_phones: Optional[bool] = None
    """
    Specifies if the user's softphone(s) are notified before forwarding the incoming call to desk
    phones and forwarding numbers
    """
    
    notify_admin_soft_phones: Optional[bool] = None
    """
    Specifies if the administrator's softphone is notified before forwarding the incoming call to
    desk phones and forwarding numbers. The default value is 'False'
    """
    
    soft_phones_ring_count: Optional[int] = None
    """ Number of rings before forwarding starts """
    
    ringing_mode: Optional[AnsweringRuleInfoForwardingRingingMode] = None
    """
    Specifies the order in which forwarding numbers ring. 'Sequentially' means that forwarding
    numbers are ringing one at a time, in order of priority. 'Simultaneously' means that forwarding
    numbers are ring all at the same time
    """
    
    rules: Optional[List[AnsweringRuleInfoForwardingRulesItem]] = None
    """ Information on a call forwarding rule """
    
    mobile_timeout: Optional[bool] = None
    """ Specifies if mobile timeout is activated for the rule """
    

class AnsweringRuleInfoUnconditionalForwardingAction(Enum):
    """ Event that initiates forwarding to the specified phone number """
    
    HoldTimeExpiration = 'HoldTimeExpiration'
    MaxCallers = 'MaxCallers'
    NoAnswer = 'NoAnswer'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoUnconditionalForwarding(DataClassJsonMixin):
    """
    Unconditional forwarding parameters. Returned if 'UnconditionalForwarding' is specified in
    'callHandlingAction'
    
    Generated by Python OpenAPI Parser
    """
    
    phone_number: Optional[str] = None
    """
    Phone number to which the call is forwarded. In addition to common e.164 format, the following
    number patterns are supported: 11xxxxxxxxxxx, 444xxxxxxxxxxx, 616xxxxxxxxxxx; where xxxxxxxxxxx
    is a phone number in e.164 format (without '+' sign)
    """
    
    action: Optional[AnsweringRuleInfoUnconditionalForwardingAction] = None
    """ Event that initiates forwarding to the specified phone number """
    

class AnsweringRuleInfoQueueTransferMode(Enum):
    """ Specifies how calls are transferred to group members """
    
    Rotating = 'Rotating'
    Simultaneous = 'Simultaneous'
    FixedOrder = 'FixedOrder'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoQueueTransferItemExtension(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of an extension the call is transferred to """
    
    name: Optional[str] = None
    """ Extension name """
    
    extension_number: Optional[str] = None
    """ Extension number """
    

class AnsweringRuleInfoQueueTransferItemAction(Enum):
    """ Event that initiates transferring to the specified extension """
    
    HoldTimeExpiration = 'HoldTimeExpiration'
    MaxCallers = 'MaxCallers'
    NoAnswer = 'NoAnswer'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoQueueTransferItem(DataClassJsonMixin):
    extension: Optional[AnsweringRuleInfoQueueTransferItemExtension] = None
    action: Optional[AnsweringRuleInfoQueueTransferItemAction] = None
    """ Event that initiates transferring to the specified extension """
    

class AnsweringRuleInfoQueueNoAnswerAction(Enum):
    """
    Specifies the type of action to be taken if: members are available but no one answers, or all
    members are busy/unavailable. This option is available for Business hours only. For
    simultaneous transfer mode only 'WaitPrimaryMembers' and 'WaitPrimaryAndOverflowMembers' are
    supported
    
    Generated by Python OpenAPI Parser
    """
    
    WaitPrimaryMembers = 'WaitPrimaryMembers'
    WaitPrimaryAndOverflowMembers = 'WaitPrimaryAndOverflowMembers'
    Voicemail = 'Voicemail'
    TransferToExtension = 'TransferToExtension'
    UnconditionalForwarding = 'UnconditionalForwarding'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoQueueFixedOrderAgentsItemExtension(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of an extension """
    
    uri: Optional[str] = None
    """ Canonical URI of an extension """
    
    extension_number: Optional[str] = None
    """ Number of department extension """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoQueueFixedOrderAgentsItem(DataClassJsonMixin):
    extension: Optional[AnsweringRuleInfoQueueFixedOrderAgentsItemExtension] = None
    index: Optional[int] = None
    """ Ordinal of an agent (call queue member) """
    

class AnsweringRuleInfoQueueHoldAudioInterruptionMode(Enum):
    """ Connecting audio interruption mode """
    
    Never = 'Never'
    WhenMusicEnds = 'WhenMusicEnds'
    Periodically = 'Periodically'

class AnsweringRuleInfoQueueHoldTimeExpirationAction(Enum):
    """
    Specifies the type of action to be taken after the hold time (waiting for an available call
    queue member) expires. If 'TransferToExtension' option is selected, the extension specified in
    `transfer` field is used. The default value is `Voicemail`
    
    Generated by Python OpenAPI Parser
    """
    
    TransferToExtension = 'TransferToExtension'
    UnconditionalForwarding = 'UnconditionalForwarding'
    Voicemail = 'Voicemail'

class AnsweringRuleInfoQueueMaxCallersAction(Enum):
    """
    Specifies the type of action to be taken if count of callers on hold exceeds the supported
    maximum
    
    Generated by Python OpenAPI Parser
    """
    
    Voicemail = 'Voicemail'
    Announcement = 'Announcement'
    TransferToExtension = 'TransferToExtension'
    UnconditionalForwarding = 'UnconditionalForwarding'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoQueue(DataClassJsonMixin):
    """
    Queue settings applied for department (call queue) extension type, with the 'AgentQueue' value
    specified as a call handling action
    
    Generated by Python OpenAPI Parser
    """
    
    transfer_mode: Optional[AnsweringRuleInfoQueueTransferMode] = None
    """ Specifies how calls are transferred to group members """
    
    transfer: Optional[List[AnsweringRuleInfoQueueTransferItem]] = None
    """ Call transfer information """
    
    no_answer_action: Optional[AnsweringRuleInfoQueueNoAnswerAction] = None
    """
    Specifies the type of action to be taken if: members are available but no one answers, or all
    members are busy/unavailable. This option is available for Business hours only. For
    simultaneous transfer mode only 'WaitPrimaryMembers' and 'WaitPrimaryAndOverflowMembers' are
    supported
    """
    
    fixed_order_agents: Optional[List[AnsweringRuleInfoQueueFixedOrderAgentsItem]] = None
    """ Information on a call forwarding rule """
    
    hold_audio_interruption_mode: Optional[AnsweringRuleInfoQueueHoldAudioInterruptionMode] = None
    """ Connecting audio interruption mode """
    
    hold_audio_interruption_period: Optional[int] = None
    """ Connecting audio interruption message period in seconds """
    
    hold_time_expiration_action: Optional[AnsweringRuleInfoQueueHoldTimeExpirationAction] = 'Voicemail'
    """
    Specifies the type of action to be taken after the hold time (waiting for an available call
    queue member) expires. If 'TransferToExtension' option is selected, the extension specified in
    `transfer` field is used. The default value is `Voicemail`
    """
    
    agent_timeout: Optional[int] = None
    """ Maximum time in seconds to wait for a call queue member before trying the next member """
    
    wrap_up_time: Optional[int] = None
    """
    Minimum post-call wrap up time in seconds before agent status is automatically set; the value
    range is from 180 to 300
    """
    
    hold_time: Optional[int] = None
    """ Maximum hold time in seconds to wait for an available call queue member """
    
    max_callers: Optional[int] = None
    """ Maximum count of callers on hold; the limitation is 25 callers """
    
    max_callers_action: Optional[AnsweringRuleInfoQueueMaxCallersAction] = None
    """
    Specifies the type of action to be taken if count of callers on hold exceeds the supported
    maximum
    """
    
    unconditional_forwarding: Optional[List[dict]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoTransferExtension(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of an extension """
    
    uri: Optional[str] = None
    """ Canonical URI of an extension """
    
    extension_number: Optional[str] = None
    """ Number of department extension """
    
    partner_id: Optional[str] = None
    """
    For Partner Applications Internal identifier of an extension created by partner. The
    RingCentral supports the mapping of accounts and stores the corresponding account ID/extension
    ID for each partner ID of a client application. In request URIs partner IDs are accepted
    instead of regular RingCentral native IDs as path parameters using pid = XXX clause. Though in
    response URIs contain the corresponding account IDs and extension IDs. In all request and
    response bodies these values are reflected via partnerId attributes of account and extension
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoTransfer(DataClassJsonMixin):
    """
    Transfer settings applied for department (call queue) extension type, with
    'TransferToExtension' call handling action
    
    Generated by Python OpenAPI Parser
    """
    
    extension: Optional[AnsweringRuleInfoTransferExtension] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoVoicemailRecipient(DataClassJsonMixin):
    """ Recipient data """
    
    uri: Optional[str] = None
    """ Link to a recipient extension resource """
    
    id: Optional[int] = None
    """ Internal identifier of a recipient extension """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoVoicemail(DataClassJsonMixin):
    """ Specifies whether to take a voicemail and who should do it """
    
    enabled: Optional[bool] = None
    """ If 'True' then voicemails are allowed to be received """
    
    recipient: Optional[AnsweringRuleInfoVoicemailRecipient] = None
    """ Recipient data """
    

class AnsweringRuleInfoGreetingsItemType(Enum):
    """ Type of a greeting, specifying the case when the greeting is played. """
    
    Introductory = 'Introductory'
    Announcement = 'Announcement'
    ConnectingMessage = 'ConnectingMessage'
    ConnectingAudio = 'ConnectingAudio'
    Voicemail = 'Voicemail'
    Unavailable = 'Unavailable'
    InterruptPrompt = 'InterruptPrompt'
    HoldMusic = 'HoldMusic'
    Custom = 'Custom'
    Company = 'Company'
    BlockedCallersSpecific = 'BlockedCallersSpecific'
    BlockedCallersAll = 'BlockedCallersAll'
    BlockedNoCallerId = 'BlockedNoCallerId'
    BlockedPayPhones = 'BlockedPayPhones'
    StartRecording = 'StartRecording'
    StopRecording = 'StopRecording'
    AutomaticRecording = 'AutomaticRecording'

class AnsweringRuleInfoGreetingsItemUsageType(Enum):
    """
    Usage type of a greeting, specifying if the greeting is applied to user extension or department
    extension.
    
    Generated by Python OpenAPI Parser
    """
    
    UserExtensionAnsweringRule = 'UserExtensionAnsweringRule'
    ExtensionAnsweringRule = 'ExtensionAnsweringRule'
    DepartmentExtensionAnsweringRule = 'DepartmentExtensionAnsweringRule'
    CompanyAnsweringRule = 'CompanyAnsweringRule'
    CompanyAfterHoursAnsweringRule = 'CompanyAfterHoursAnsweringRule'
    VoicemailExtensionAnsweringRule = 'VoicemailExtensionAnsweringRule'
    AnnouncementExtensionAnsweringRule = 'AnnouncementExtensionAnsweringRule'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoGreetingsItemPreset(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to a greeting resource """
    
    id: Optional[str] = None
    """ Internal identifier of a greeting """
    
    name: Optional[str] = None
    """ Name of a greeting """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoGreetingsItemCustom(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to a custom user greeting """
    
    id: Optional[str] = None
    """ Internal identifier of a custom user greeting """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoGreetingsItem(DataClassJsonMixin):
    type: Optional[AnsweringRuleInfoGreetingsItemType] = None
    """ Type of a greeting, specifying the case when the greeting is played. """
    
    usage_type: Optional[AnsweringRuleInfoGreetingsItemUsageType] = None
    """
    Usage type of a greeting, specifying if the greeting is applied to user extension or department
    extension.
    """
    
    preset: Optional[AnsweringRuleInfoGreetingsItemPreset] = None
    custom: Optional[AnsweringRuleInfoGreetingsItemCustom] = None

class AnsweringRuleInfoScreening(Enum):
    """
    Call screening status. 'Off' - no call screening; 'NoCallerId' - if caller ID is missing, then
    callers are asked to say their name before connecting; 'UnknownCallerId' - if caller ID is not
    in contact list, then callers are asked to say their name before connecting; 'Always' - the
    callers are always asked to say their name before connecting. The default value is 'Off'
    
    Generated by Python OpenAPI Parser
    """
    
    Off = 'Off'
    NoCallerId = 'NoCallerId'
    UnknownCallerId = 'UnknownCallerId'
    Always = 'Always'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfoSharedLines(DataClassJsonMixin):
    """ SharedLines call handling action settings """
    
    timeout: Optional[int] = None
    """ Number of seconds to wait before forwarding unanswered calls. The value range is 10 - 80 """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AnsweringRuleInfo(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Canonical URI to an answering rule resource """
    
    id: Optional[str] = None
    """ Internal identifier of an answering rule """
    
    type: Optional[AnsweringRuleInfoType] = None
    """ Type of an answering rule """
    
    name: Optional[str] = None
    """ Name of an answering rule specified by user """
    
    enabled: Optional[bool] = None
    """ Specifies if an answering rule is active or inactive """
    
    schedule: Optional[AnsweringRuleInfoSchedule] = None
    """ Schedule when an answering rule should be applied """
    
    called_numbers: Optional[List[AnsweringRuleInfoCalledNumbersItem]] = None
    """ Answering rules are applied when calling to selected number(s) """
    
    callers: Optional[List[AnsweringRuleInfoCallersItem]] = None
    """ Answering rules are applied when calls are received from specified caller(s) """
    
    call_handling_action: Optional[AnsweringRuleInfoCallHandlingAction] = None
    """ Specifies how incoming calls are forwarded """
    
    forwarding: Optional[AnsweringRuleInfoForwarding] = None
    """
    Forwarding parameters. Returned if 'ForwardCalls' is specified in 'callHandlingAction'. These
    settings determine the forwarding numbers to which the call will be forwarded
    """
    
    unconditional_forwarding: Optional[AnsweringRuleInfoUnconditionalForwarding] = None
    """
    Unconditional forwarding parameters. Returned if 'UnconditionalForwarding' is specified in
    'callHandlingAction'
    """
    
    queue: Optional[AnsweringRuleInfoQueue] = None
    """
    Queue settings applied for department (call queue) extension type, with the 'AgentQueue' value
    specified as a call handling action
    """
    
    transfer: Optional[AnsweringRuleInfoTransfer] = None
    """
    Transfer settings applied for department (call queue) extension type, with
    'TransferToExtension' call handling action
    """
    
    voicemail: Optional[AnsweringRuleInfoVoicemail] = None
    """ Specifies whether to take a voicemail and who should do it """
    
    greetings: Optional[List[AnsweringRuleInfoGreetingsItem]] = None
    """
    Greetings applied for an answering rule; only predefined greetings can be applied, see
    Dictionary Greeting List
    """
    
    screening: Optional[AnsweringRuleInfoScreening] = None
    """
    Call screening status. 'Off' - no call screening; 'NoCallerId' - if caller ID is missing, then
    callers are asked to say their name before connecting; 'UnknownCallerId' - if caller ID is not
    in contact list, then callers are asked to say their name before connecting; 'Always' - the
    callers are always asked to say their name before connecting. The default value is 'Off'
    """
    
    shared_lines: Optional[AnsweringRuleInfoSharedLines] = None
    """ SharedLines call handling action settings """
    

class CustomCompanyGreetingInfoType(Enum):
    """ Type of a company greeting """
    
    Company = 'Company'
    StartRecording = 'StartRecording'
    StopRecording = 'StopRecording'
    AutomaticRecording = 'AutomaticRecording'

class CustomCompanyGreetingInfoContentType(Enum):
    """ Content media type """
    
    AudioMpeg = 'audio/mpeg'
    AudioWav = 'audio/wav'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CustomCompanyGreetingInfoAnsweringRule(DataClassJsonMixin):
    """ Information on an answering rule that the greeting is applied to """
    
    uri: Optional[str] = None
    """ Canonical URI of an answering rule """
    
    id: Optional[str] = None
    """ Internal identifier of an answering rule """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CustomCompanyGreetingInfoLanguage(DataClassJsonMixin):
    """
    Information on a greeting language. Supported for types 'StopRecording', 'StartRecording',
    'AutomaticRecording'
    
    Generated by Python OpenAPI Parser
    """
    
    id: Optional[str] = None
    """ Internal identifier of a greeting language """
    
    uri: Optional[str] = None
    """ Link to a greeting language """
    
    name: Optional[str] = None
    """ Name of a greeting language """
    
    locale_code: Optional[str] = None
    """ Locale code of a greeting language """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CustomCompanyGreetingInfo(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to an extension custom greeting """
    
    id: Optional[str] = None
    """ Internal identifier of an answering rule """
    
    type: Optional[CustomCompanyGreetingInfoType] = None
    """ Type of a company greeting """
    
    content_type: Optional[CustomCompanyGreetingInfoContentType] = None
    """ Content media type """
    
    content_uri: Optional[str] = None
    """ Link to a greeting content (audio file) """
    
    answering_rule: Optional[CustomCompanyGreetingInfoAnsweringRule] = None
    """ Information on an answering rule that the greeting is applied to """
    
    language: Optional[CustomCompanyGreetingInfoLanguage] = None
    """
    Information on a greeting language. Supported for types 'StopRecording', 'StartRecording',
    'AutomaticRecording'
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateIVRPromptRequest(DataClassJsonMixin):
    filename: Optional[str] = None
    """ Name of a file to be uploaded as a prompt """
    

class GetExtensionForwardingNumberListResponseRecordsItemLabel(Enum):
    """ Forwarding/Call flip number title """
    
    Business_Mobile_Phone = 'Business Mobile Phone'

class GetExtensionForwardingNumberListResponseRecordsItemFeaturesItem(Enum):
    CallFlip = 'CallFlip'
    CallForwarding = 'CallForwarding'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetExtensionForwardingNumberListResponseRecordsItemDevice(DataClassJsonMixin):
    """ Forwarding device information """
    
    id: Optional[str] = None
    """ Internal identifier of the other extension device """
    

class GetExtensionForwardingNumberListResponseRecordsItemType(Enum):
    """ Forwarding phone number type """
    
    Home = 'Home'
    Mobile = 'Mobile'
    Work = 'Work'
    PhoneLine = 'PhoneLine'
    Outage = 'Outage'
    Other = 'Other'
    BusinessMobilePhone = 'BusinessMobilePhone'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetExtensionForwardingNumberListResponseRecordsItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a forwarding/call flip phone number """
    
    uri: Optional[str] = None
    """ Canonical URI of a forwarding/call flip phone number """
    
    phone_number: Optional[str] = None
    """ Forwarding/Call flip phone number """
    
    label: Optional[GetExtensionForwardingNumberListResponseRecordsItemLabel] = None
    """ Forwarding/Call flip number title """
    
    features: Optional[List[GetExtensionForwardingNumberListResponseRecordsItemFeaturesItem]] = None
    """ Type of option this phone number is used for. Multiple values are accepted """
    
    flip_number: Optional[str] = None
    """ Number assigned to the call flip phone number, corresponds to the shortcut dial number """
    
    device: Optional[GetExtensionForwardingNumberListResponseRecordsItemDevice] = None
    """ Forwarding device information """
    
    type: Optional[GetExtensionForwardingNumberListResponseRecordsItemType] = None
    """ Forwarding phone number type """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetExtensionForwardingNumberListResponseNavigationFirstPage(DataClassJsonMixin):
    """ Canonical URI for the first page of the list """
    
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetExtensionForwardingNumberListResponseNavigation(DataClassJsonMixin):
    """ Information on navigation """
    
    first_page: Optional[GetExtensionForwardingNumberListResponseNavigationFirstPage] = None
    """ Canonical URI for the first page of the list """
    
    next_page: Optional[dict] = None
    """ Canonical URI for the next page of the list """
    
    previous_page: Optional[dict] = None
    """ Canonical URI for the previous page of the list """
    
    last_page: Optional[dict] = None
    """ Canonical URI for the last page of the list """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetExtensionForwardingNumberListResponsePaging(DataClassJsonMixin):
    """ Information on paging """
    
    page: Optional[int] = None
    """
    The current page number. 1-indexed, so the first page is 1 by default. May be omitted if result
    is empty (because non-existent page was specified or perPage=0 was requested)
    """
    
    per_page: Optional[int] = None
    """
    Current page size, describes how many items are in each page. Default value is 100. Maximum
    value is 1000. If perPage value in the request is greater than 1000, the maximum value (1000)
    is applied
    """
    
    page_start: Optional[int] = None
    """
    The zero-based number of the first element on the current page. Omitted if the page is omitted
    or result is empty
    """
    
    page_end: Optional[int] = None
    """
    The zero-based index of the last element on the current page. Omitted if the page is omitted or
    result is empty
    """
    
    total_pages: Optional[int] = None
    """
    The total number of pages in a dataset. May be omitted for some resources due to performance
    reasons
    """
    
    total_elements: Optional[int] = None
    """
    The total number of elements in a dataset. May be omitted for some resource due to performance
    reasons
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetExtensionForwardingNumberListResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to the forwarding number list resource """
    
    records: Optional[List[GetExtensionForwardingNumberListResponseRecordsItem]] = None
    """ List of forwarding phone numbers """
    
    navigation: Optional[GetExtensionForwardingNumberListResponseNavigation] = None
    """ Information on navigation """
    
    paging: Optional[GetExtensionForwardingNumberListResponsePaging] = None
    """ Information on paging """
    

class BlockedAllowedPhoneNumbersListRecordsItemStatus(Enum):
    """ Status of a phone number """
    
    Blocked = 'Blocked'
    Allowed = 'Allowed'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class BlockedAllowedPhoneNumbersListRecordsItem(DataClassJsonMixin):
    """ Information on a blocked/allowed phone number """
    
    uri: Optional[str] = None
    """ Link to a blocked/allowed phone number """
    
    id: Optional[str] = None
    """ Internal identifier of a blocked/allowed phone number """
    
    phone_number: Optional[str] = None
    """ A blocked/allowed phone number in [E.164](https://www.itu.int/rec/T-REC-E.164-201011-I) format """
    
    label: Optional[str] = None
    """ Custom name of a blocked/allowed phone number """
    
    status: Optional[BlockedAllowedPhoneNumbersListRecordsItemStatus] = None
    """ Status of a phone number """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class BlockedAllowedPhoneNumbersList(DataClassJsonMixin):
    """ List of blocked or allowed phone numbers """
    
    uri: Optional[str] = None
    """ Link to a list of blocked/allowed phone numbers resource """
    
    records: Optional[List[BlockedAllowedPhoneNumbersListRecordsItem]] = None
    navigation: Optional[dict] = None
    """ Information on navigation """
    
    paging: Optional[dict] = None
    """ Information on paging """
    

class CreateForwardingNumberRequestType(Enum):
    """
    Forwarding/Call flip phone type. If specified, 'label' attribute value is ignored. The default
    value is 'Other'
    
    Generated by Python OpenAPI Parser
    """
    
    PhoneLine = 'PhoneLine'
    Home = 'Home'
    Mobile = 'Mobile'
    Work = 'Work'
    Other = 'Other'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateForwardingNumberRequest(DataClassJsonMixin):
    flip_number: Optional[int] = None
    """ Number assigned to the call flip phone number, corresponds to the shortcut dial number """
    
    phone_number: Optional[str] = None
    """ Forwarding/Call flip phone number """
    
    label: Optional[str] = None
    """ Forwarding/Call flip number title """
    
    type: Optional[CreateForwardingNumberRequestType] = None
    """
    Forwarding/Call flip phone type. If specified, 'label' attribute value is ignored. The default
    value is 'Other'
    """
    
    device: Optional[dict] = None
    """
    Reference to the other extension device. Applicable for 'PhoneLine' type only. Cannot be
    specified together with 'phoneNumber' parameter.
    """
    

class CustomAnsweringRuleInfoType(Enum):
    """ Type of an answering rule """
    
    BusinessHours = 'BusinessHours'
    AfterHours = 'AfterHours'
    Custom = 'Custom'

class CustomAnsweringRuleInfoCallHandlingAction(Enum):
    """ Specifies how incoming calls are forwarded """
    
    ForwardCalls = 'ForwardCalls'
    UnconditionalForwarding = 'UnconditionalForwarding'
    AgentQueue = 'AgentQueue'
    TransferToExtension = 'TransferToExtension'
    TakeMessagesOnly = 'TakeMessagesOnly'
    PlayAnnouncementOnly = 'PlayAnnouncementOnly'
    SharedLines = 'SharedLines'

class CustomAnsweringRuleInfoScreening(Enum):
    """
    Call screening status. 'Off' - no call screening; 'NoCallerId' - if caller ID is missing, then
    callers are asked to say their name before connecting; 'UnknownCallerId' - if caller ID is not
    in contact list, then callers are asked to say their name before connecting; 'Always' - the
    callers are always asked to say their name before connecting. The default value is 'Off'
    
    Generated by Python OpenAPI Parser
    """
    
    Off = 'Off'
    NoCallerId = 'NoCallerId'
    UnknownCallerId = 'UnknownCallerId'
    Always = 'Always'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CustomAnsweringRuleInfo(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Canonical URI to an answering rule resource """
    
    id: Optional[str] = None
    """ Internal identifier of an answering rule """
    
    type: Optional[CustomAnsweringRuleInfoType] = None
    """ Type of an answering rule """
    
    name: Optional[str] = None
    """ Name of an answering rule specified by user """
    
    enabled: Optional[bool] = None
    """ Specifies if an answering rule is active or inactive """
    
    schedule: Optional[dict] = None
    """ Schedule when an answering rule should be applied """
    
    called_numbers: Optional[list] = None
    """ Answering rules are applied when calling to selected number(s) """
    
    callers: Optional[list] = None
    """ Answering rules are applied when calls are received from specified caller(s) """
    
    call_handling_action: Optional[CustomAnsweringRuleInfoCallHandlingAction] = None
    """ Specifies how incoming calls are forwarded """
    
    forwarding: Optional[dict] = None
    """
    Forwarding parameters. Returned if 'ForwardCalls' is specified in 'callHandlingAction'. These
    settings determine the forwarding numbers to which the call will be forwarded
    """
    
    unconditional_forwarding: Optional[dict] = None
    """
    Unconditional forwarding parameters. Returned if 'UnconditionalForwarding' is specified in
    'callHandlingAction'
    """
    
    queue: Optional[dict] = None
    """
    Queue settings applied for department (call queue) extension type, with the 'AgentQueue' value
    specified as a call handling action
    """
    
    transfer: Optional[dict] = None
    """
    Transfer settings applied for department (call queue) extension type, with
    'TransferToExtension' call handling action
    """
    
    voicemail: Optional[dict] = None
    """ Specifies whether to take a voicemail and who should do it """
    
    greetings: Optional[list] = None
    """
    Greetings applied for an answering rule; only predefined greetings can be applied, see
    Dictionary Greeting List
    """
    
    screening: Optional[CustomAnsweringRuleInfoScreening] = None
    """
    Call screening status. 'Off' - no call screening; 'NoCallerId' - if caller ID is missing, then
    callers are asked to say their name before connecting; 'UnknownCallerId' - if caller ID is not
    in contact list, then callers are asked to say their name before connecting; 'Always' - the
    callers are always asked to say their name before connecting. The default value is 'Off'
    """
    
    shared_lines: Optional[dict] = None
    """ SharedLines call handling action settings """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyBusinessHoursSchedule(DataClassJsonMixin):
    """ Schedule when an answering rule is applied """
    
    weekly_ranges: Optional[dict] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyBusinessHours(DataClassJsonMixin):
    """
    Example:
        ```json
        {
            "uri": "https.../restapi/v1.0/account/401800045008/business-hours",
            "schedule": {
                "weeklyRanges": {
                    "wednesday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "friday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "tuesday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "monday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "thursday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ]
                }
            }
        }
        ```
    
    Generated by Python OpenAPI Parser
    """
    
    uri: Optional[str] = None
    """ Canonical URI of a business-hours resource """
    
    schedule: Optional[CompanyBusinessHoursSchedule] = None
    """ Schedule when an answering rule is applied """
    

class CustomUserGreetingInfoType(Enum):
    """ Type of a custom user greeting """
    
    Introductory = 'Introductory'
    Announcement = 'Announcement'
    InterruptPrompt = 'InterruptPrompt'
    ConnectingAudio = 'ConnectingAudio'
    ConnectingMessage = 'ConnectingMessage'
    Voicemail = 'Voicemail'
    Unavailable = 'Unavailable'
    HoldMusic = 'HoldMusic'
    PronouncedName = 'PronouncedName'

class CustomUserGreetingInfoContentType(Enum):
    """ Content media type """
    
    AudioMpeg = 'audio/mpeg'
    AudioWav = 'audio/wav'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CustomUserGreetingInfo(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to a custom user greeting """
    
    id: Optional[str] = None
    """ Internal identifier of a custom user greeting """
    
    type: Optional[CustomUserGreetingInfoType] = None
    """ Type of a custom user greeting """
    
    content_type: Optional[CustomUserGreetingInfoContentType] = None
    """ Content media type """
    
    content_uri: Optional[str] = None
    """ Link to a greeting content (audio file) """
    
    answering_rule: Optional[dict] = None
    """ Information on an answering rule that the greeting is applied to """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class PromptInfo(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Internal identifier of a prompt """
    
    id: Optional[str] = None
    """ Link to a prompt metadata """
    
    content_type: Optional[str] = None
    """ Type of a prompt media content """
    
    content_uri: Optional[str] = None
    """ Link to a prompt media content """
    
    filename: Optional[str] = None
    """ Name of a prompt """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UserBusinessHoursUpdateResponseSchedule(DataClassJsonMixin):
    """ Schedule when an answering rule is applied """
    
    weekly_ranges: Optional[dict] = None
    """ Weekly schedule """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UserBusinessHoursUpdateResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Canonical URI of a business-hours resource """
    
    schedule: Optional[UserBusinessHoursUpdateResponseSchedule] = None
    """ Schedule when an answering rule is applied """
    

class CallerBlockingSettingsUpdateMode(Enum):
    """ Call blocking options: either specific or all calls and faxes """
    
    Specific = 'Specific'
    All = 'All'

class CallerBlockingSettingsUpdateNoCallerId(Enum):
    """ Determines how to handle calls with no caller ID in 'Specific' mode """
    
    BlockCallsAndFaxes = 'BlockCallsAndFaxes'
    BlockFaxes = 'BlockFaxes'
    Allow = 'Allow'

class CallerBlockingSettingsUpdatePayPhones(Enum):
    """ Blocking settings for pay phones """
    
    Block = 'Block'
    Allow = 'Allow'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CallerBlockingSettingsUpdateGreetingsItem(DataClassJsonMixin):
    type: Optional[str] = None
    """ Type of a greeting """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CallerBlockingSettingsUpdate(DataClassJsonMixin):
    """ Returns the lists of blocked and allowed phone numbers """
    
    mode: Optional[CallerBlockingSettingsUpdateMode] = None
    """ Call blocking options: either specific or all calls and faxes """
    
    no_caller_id: Optional[CallerBlockingSettingsUpdateNoCallerId] = None
    """ Determines how to handle calls with no caller ID in 'Specific' mode """
    
    pay_phones: Optional[CallerBlockingSettingsUpdatePayPhones] = None
    """ Blocking settings for pay phones """
    
    greetings: Optional[List[CallerBlockingSettingsUpdateGreetingsItem]] = None
    """ List of greetings played for blocked callers """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestCallersItem(DataClassJsonMixin):
    caller_id: Optional[str] = None
    """ Phone number of a caller """
    
    name: Optional[str] = None
    """ Contact name of a caller """
    

class CreateAnsweringRuleRequestCallHandlingAction(Enum):
    """ Specifies how incoming calls are forwarded """
    
    ForwardCalls = 'ForwardCalls'
    UnconditionalForwarding = 'UnconditionalForwarding'
    AgentQueue = 'AgentQueue'
    TransferToExtension = 'TransferToExtension'
    TakeMessagesOnly = 'TakeMessagesOnly'
    PlayAnnouncementOnly = 'PlayAnnouncementOnly'
    SharedLines = 'SharedLines'

class CreateAnsweringRuleRequestScreening(Enum):
    """
    Call screening status. 'Off' - no call screening; 'NoCallerId' - if caller ID is missing, then
    callers are asked to say their name before connecting; 'UnknownCallerId' - if caller ID is not
    in contact list, then callers are asked to say their name before connecting; 'Always' - the
    callers are always asked to say their name before connecting. The default value is 'Off'
    
    Generated by Python OpenAPI Parser
    """
    
    Off = 'Off'
    NoCallerId = 'NoCallerId'
    UnknownCallerId = 'UnknownCallerId'
    Always = 'Always'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequest(DataClassJsonMixin):
    enabled: Optional[bool] = None
    """ Specifies if the rule is active or inactive. The default value is 'True' """
    
    type: Optional[str] = None
    """ Type of an answering rule. The 'Custom' value should be specified """
    
    name: Optional[str] = None
    """ Name of an answering rule specified by user """
    
    callers: Optional[List[CreateAnsweringRuleRequestCallersItem]] = None
    """ Answering rule will be applied when calls are received from the specified caller(s) """
    
    called_numbers: Optional[list] = None
    """ Answering rules are applied when calling to selected number(s) """
    
    schedule: Optional[dict] = None
    """ Schedule when an answering rule should be applied """
    
    call_handling_action: Optional[CreateAnsweringRuleRequestCallHandlingAction] = None
    """ Specifies how incoming calls are forwarded """
    
    forwarding: Optional[dict] = None
    """
    Forwarding parameters. Returned if 'ForwardCalls' is specified in 'callHandlingAction'. These
    settings determine the forwarding numbers to which the call will be forwarded
    """
    
    unconditional_forwarding: Optional[dict] = None
    """
    Unconditional forwarding parameters. Returned if 'UnconditionalForwarding' is specified in
    'callHandlingAction'
    """
    
    queue: Optional[dict] = None
    """
    Queue settings applied for department (call queue) extension type, with the 'AgentQueue' value
    specified as a call handling action
    """
    
    transfer: Optional[dict] = None
    """
    Transfer settings applied for department (call queue) extension type, with
    'TransferToExtension' call handling action
    """
    
    voicemail: Optional[dict] = None
    """ Specifies whether to take a voicemail and who should do it """
    
    greetings: Optional[list] = None
    """
    Greetings applied for an answering rule; only predefined greetings can be applied, see
    Dictionary Greeting List
    """
    
    screening: Optional[CreateAnsweringRuleRequestScreening] = None
    """
    Call screening status. 'Off' - no call screening; 'NoCallerId' - if caller ID is missing, then
    callers are asked to say their name before connecting; 'UnknownCallerId' - if caller ID is not
    in contact list, then callers are asked to say their name before connecting; 'Always' - the
    callers are always asked to say their name before connecting. The default value is 'Off'
    """
    

class DictionaryGreetingListRecordsItemUsageType(Enum):
    """
    Usage type of a greeting, specifying if the greeting is applied for user extension or
    department extension.
    
    Generated by Python OpenAPI Parser
    """
    
    UserExtensionAnsweringRule = 'UserExtensionAnsweringRule'
    ExtensionAnsweringRule = 'ExtensionAnsweringRule'
    DepartmentExtensionAnsweringRule = 'DepartmentExtensionAnsweringRule'
    BlockedCalls = 'BlockedCalls'
    CallRecording = 'CallRecording'
    CompanyAnsweringRule = 'CompanyAnsweringRule'
    CompanyAfterHoursAnsweringRule = 'CompanyAfterHoursAnsweringRule'
    LimitedExtensionAnsweringRule = 'LimitedExtensionAnsweringRule'
    VoicemailExtensionAnsweringRule = 'VoicemailExtensionAnsweringRule'
    AnnouncementExtensionAnsweringRule = 'AnnouncementExtensionAnsweringRule'
    SharedLinesGroupAnsweringRule = 'SharedLinesGroupAnsweringRule'

class DictionaryGreetingListRecordsItemType(Enum):
    """ Type of a greeting, specifying the case when the greeting is played. """
    
    Introductory = 'Introductory'
    Announcement = 'Announcement'
    AutomaticRecording = 'AutomaticRecording'
    BlockedCallersAll = 'BlockedCallersAll'
    BlockedCallersSpecific = 'BlockedCallersSpecific'
    BlockedNoCallerId = 'BlockedNoCallerId'
    BlockedPayPhones = 'BlockedPayPhones'
    ConnectingMessage = 'ConnectingMessage'
    ConnectingAudio = 'ConnectingAudio'
    StartRecording = 'StartRecording'
    StopRecording = 'StopRecording'
    Voicemail = 'Voicemail'
    Unavailable = 'Unavailable'
    InterruptPrompt = 'InterruptPrompt'
    HoldMusic = 'HoldMusic'
    Company = 'Company'

class DictionaryGreetingListRecordsItemCategory(Enum):
    """
    Category of a greeting, specifying data form. The category value 'None' specifies that
    greetings of a certain type ('Introductory', 'ConnectingAudio', etc.) are switched off for an
    extension = ['Music', 'Message', 'RingTones', 'None']
    
    Generated by Python OpenAPI Parser
    """
    
    Music = 'Music'
    Message = 'Message'
    RingTones = 'RingTones'
    None_ = 'None'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class DictionaryGreetingListRecordsItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a greeting """
    
    uri: Optional[str] = None
    """ Link to a greeting """
    
    name: Optional[str] = None
    """ Name of a greeting """
    
    usage_type: Optional[DictionaryGreetingListRecordsItemUsageType] = None
    """
    Usage type of a greeting, specifying if the greeting is applied for user extension or
    department extension.
    """
    
    text: Optional[str] = None
    """ Text of a greeting, if any """
    
    content_uri: Optional[str] = None
    """ Link to a greeting content (audio file), if any """
    
    type: Optional[DictionaryGreetingListRecordsItemType] = None
    """ Type of a greeting, specifying the case when the greeting is played. """
    
    category: Optional[DictionaryGreetingListRecordsItemCategory] = None
    """
    Category of a greeting, specifying data form. The category value 'None' specifies that
    greetings of a certain type ('Introductory', 'ConnectingAudio', etc.) are switched off for an
    extension = ['Music', 'Message', 'RingTones', 'None']
    """
    
    navigation: Optional[dict] = None
    """ Information on navigation """
    
    paging: Optional[dict] = None
    """ Information on paging """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class DictionaryGreetingList(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Canonical URI of greetings list resource """
    
    records: Optional[List[DictionaryGreetingListRecordsItem]] = None
    """ List of greetings """
    
    navigation: Optional[dict] = None
    """ Information on navigation """
    
    paging: Optional[dict] = None
    """ Information on paging """
    

class BulkAccountCallRecordingsResourceAddedExtensionsItemCallDirection(Enum):
    """ Direction of call """
    
    Outbound = 'Outbound'
    Inbound = 'Inbound'
    All = 'All'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class BulkAccountCallRecordingsResourceAddedExtensionsItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of an extension """
    
    uri: Optional[str] = None
    extension_number: Optional[str] = None
    type: Optional[str] = None
    call_direction: Optional[BulkAccountCallRecordingsResourceAddedExtensionsItemCallDirection] = None
    """ Direction of call """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class BulkAccountCallRecordingsResource(DataClassJsonMixin):
    added_extensions: Optional[List[BulkAccountCallRecordingsResourceAddedExtensionsItem]] = None
    updated_extensions: Optional[List[dict]] = None
    removed_extensions: Optional[List[dict]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UserBusinessHoursUpdateRequest(DataClassJsonMixin):
    schedule: Optional[dict] = None
    """ Schedule when an answering rule is applied """
    

class UpdateForwardingNumberRequestLabel(Enum):
    """ Forwarding/Call flip number title """
    
    Business_Mobile_Phone = 'Business Mobile Phone'

class UpdateForwardingNumberRequestType(Enum):
    """ Forwarding phone number type """
    
    Home = 'Home'
    Mobile = 'Mobile'
    Work = 'Work'
    PhoneLine = 'PhoneLine'
    Outage = 'Outage'
    Other = 'Other'
    BusinessMobilePhone = 'BusinessMobilePhone'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateForwardingNumberRequest(DataClassJsonMixin):
    phone_number: Optional[str] = None
    """ Forwarding/Call flip phone number """
    
    label: Optional[UpdateForwardingNumberRequestLabel] = None
    """ Forwarding/Call flip number title """
    
    flip_number: Optional[str] = None
    """ Number assigned to the call flip phone number, corresponds to the shortcut dial number """
    
    type: Optional[UpdateForwardingNumberRequestType] = None
    """ Forwarding phone number type """
    

class UserAnsweringRuleListRecordsItemType(Enum):
    """ Type of an answering rule """
    
    BusinessHours = 'BusinessHours'
    AfterHours = 'AfterHours'
    Custom = 'Custom'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UserAnsweringRuleListRecordsItem(DataClassJsonMixin):
    uri: Optional[str] = None
    """
    Canonical URI to an answering rule resource
    
    Example: `https://platform.ringcentral.com/restapi/v1.0/account/240913004/extension/240972004/answering-rule/business-hours-rule`
    """
    
    id: Optional[str] = None
    """
    Internal identifier of an asnwering rule
    
    Example: `business-hours-rule`
    """
    
    type: Optional[UserAnsweringRuleListRecordsItemType] = None
    """ Type of an answering rule """
    
    name: Optional[str] = None
    """ Name of an answering rule specified by user """
    
    enabled: Optional[bool] = None
    """ Specifies if an answering rule is active or inactive """
    
    shared_lines: Optional[dict] = None
    """ SharedLines call handling action settings """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UserAnsweringRuleListPaging(DataClassJsonMixin):
    page: Optional[int] = None
    """
    The current page number. 1-indexed, so the first page is 1 by default. May be omitted if result
    is empty (because non-existent page was specified or perPage=0 was requested)
    
    Example: `1`
    """
    
    total_pages: Optional[int] = None
    """
    The total number of pages in a dataset.
    
    Example: `1`
    """
    
    per_page: Optional[int] = None
    """
    Current page size, describes how many items are in each page. Default value is 100. Maximum
    value is 1000. If perPage value in the request is greater than 1000, the maximum value (1000)
    is applied
    
    Example: `100`
    """
    
    total_elements: Optional[int] = None
    """
    The total number of elements in a dataset.
    
    Example: `1`
    """
    
    page_start: Optional[int] = None
    """
    The zero-based number of the first element on the current page. Omitted if the page is omitted
    or result is empty
    
    Example: `0`
    """
    
    page_end: Optional[int] = None
    """
    The zero-based index of the last element on the current page. Omitted if the page is omitted or
    result is empty
    
    Example: `0`
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UserAnsweringRuleListNavigationFirstPage(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Example: `https://platform.ringcentral.com/restapi/v1.0/account/240913004/extension/240972004/answering-rule?page=1&perPage=100` """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UserAnsweringRuleListNavigation(DataClassJsonMixin):
    first_page: Optional[UserAnsweringRuleListNavigationFirstPage] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UserAnsweringRuleList(DataClassJsonMixin):
    uri: Optional[str] = None
    """
    Canonical URI of an answering rule list resource
    
    Example: `https://platform.ringcentral.com/restapi/v1.0/account/240913004/extension/240972004/answering-rule?page=1&perPage=100`
    """
    
    records: Optional[List[UserAnsweringRuleListRecordsItem]] = None
    """ List of answering rules """
    
    paging: Optional[UserAnsweringRuleListPaging] = None
    navigation: Optional[UserAnsweringRuleListNavigation] = None

class IVRMenuInfoPromptMode(Enum):
    """ Prompt mode: custom media or text """
    
    Audio = 'Audio'
    TextToSpeech = 'TextToSpeech'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class IVRMenuInfoPromptAudio(DataClassJsonMixin):
    """ For 'Audio' mode only. Prompt media reference """
    
    uri: Optional[str] = None
    """ Link to a prompt audio file """
    
    id: Optional[str] = None
    """ Internal identifier of a prompt """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class IVRMenuInfoPromptLanguage(DataClassJsonMixin):
    """ For 'TextToSpeech' mode only. Prompt language metadata """
    
    uri: Optional[str] = None
    """ Link to a prompt language """
    
    id: Optional[str] = None
    """ Internal identifier of a language """
    
    name: Optional[str] = None
    """ Language name """
    
    locale_code: Optional[str] = None
    """ Language locale code """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class IVRMenuInfoPrompt(DataClassJsonMixin):
    """ Prompt metadata """
    
    mode: Optional[IVRMenuInfoPromptMode] = None
    """ Prompt mode: custom media or text """
    
    audio: Optional[IVRMenuInfoPromptAudio] = None
    """ For 'Audio' mode only. Prompt media reference """
    
    text: Optional[str] = None
    """ For 'TextToSpeech' mode only. Prompt text """
    
    language: Optional[IVRMenuInfoPromptLanguage] = None
    """ For 'TextToSpeech' mode only. Prompt language metadata """
    

class IVRMenuInfoActionsItemAction(Enum):
    """ Internal identifier of an answering rule """
    
    Connect = 'Connect'
    Voicemail = 'Voicemail'
    DialByName = 'DialByName'
    Transfer = 'Transfer'
    Repeat = 'Repeat'
    ReturnToRoot = 'ReturnToRoot'
    ReturnToPrevious = 'ReturnToPrevious'
    Disconnect = 'Disconnect'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class IVRMenuInfoActionsItemExtension(DataClassJsonMixin):
    """ For 'Connect' or 'Voicemail' actions only. Extension reference """
    
    uri: Optional[str] = None
    """ Link to an extension resource """
    
    id: Optional[str] = None
    """ Internal identifier of an extension """
    
    name: Optional[str] = None
    """ Name of an extension """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class IVRMenuInfoActionsItem(DataClassJsonMixin):
    input: Optional[str] = None
    """ Key. The following values are supported: numeric: '1' to '9' Star Hash NoInput """
    
    action: Optional[IVRMenuInfoActionsItemAction] = None
    """ Internal identifier of an answering rule """
    
    extension: Optional[IVRMenuInfoActionsItemExtension] = None
    """ For 'Connect' or 'Voicemail' actions only. Extension reference """
    
    phone_number: Optional[str] = None
    """ For 'Transfer' action only. PSTN number in E.164 format """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class IVRMenuInfo(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of an IVR Menu extension """
    
    uri: Optional[str] = None
    """ Link to an IVR Menu extension resource """
    
    name: Optional[str] = None
    """ First name of an IVR Menu user """
    
    extension_number: Optional[str] = None
    """ Number of an IVR Menu extension """
    
    site: Optional[str] = None
    """ Site data """
    
    prompt: Optional[IVRMenuInfoPrompt] = None
    """ Prompt metadata """
    
    actions: Optional[List[IVRMenuInfoActionsItem]] = None
    """ Keys handling settings """
    

class CallRecordingCustomGreetingsRecordsItemType(Enum):
    StartRecording = 'StartRecording'
    StopRecording = 'StopRecording'
    AutomaticRecording = 'AutomaticRecording'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CallRecordingCustomGreetingsRecordsItemCustom(DataClassJsonMixin):
    """ Custom greeting data """
    
    uri: Optional[str] = None
    """ Link to a custom company greeting """
    
    id: Optional[str] = None
    """ Internal identifier of a custom company greeting """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CallRecordingCustomGreetingsRecordsItemLanguage(DataClassJsonMixin):
    """ Custom greeting language """
    
    uri: Optional[str] = None
    """ Link to a language """
    
    id: Optional[str] = None
    """ Internal identifier of a language """
    
    name: Optional[str] = None
    """ Language name """
    
    locale_code: Optional[str] = None
    """ Language locale code """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CallRecordingCustomGreetingsRecordsItem(DataClassJsonMixin):
    type: Optional[CallRecordingCustomGreetingsRecordsItemType] = None
    custom: Optional[CallRecordingCustomGreetingsRecordsItemCustom] = None
    """ Custom greeting data """
    
    language: Optional[CallRecordingCustomGreetingsRecordsItemLanguage] = None
    """ Custom greeting language """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CallRecordingCustomGreetings(DataClassJsonMixin):
    """ Returns data on call recording custom greetings. """
    
    records: Optional[List[CallRecordingCustomGreetingsRecordsItem]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyBusinessHoursUpdateRequest(DataClassJsonMixin):
    """
    Example:
        ```json
        {
            "schedule": {
                "weeklyRanges": {
                    "tuesday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "friday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "thursday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "wednesday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "monday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ]
                }
            }
        }
        ```
    
    Generated by Python OpenAPI Parser
    """
    
    schedule: Optional[dict] = None
    """ Schedule when an answering rule is applied """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CallRecordingExtensionsRecordsItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of an extension """
    
    uri: Optional[str] = None
    """ Link to an extension resource """
    
    extension_number: Optional[str] = None
    """ Number of an extension """
    
    name: Optional[str] = None
    """ Name of an extension """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CallRecordingExtensions(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to call recording extension list resource """
    
    records: Optional[List[CallRecordingExtensionsRecordsItem]] = None
    navigation: Optional[dict] = None
    """ Information on navigation """
    
    paging: Optional[dict] = None
    """ Information on paging """
    

class CompanyAnsweringRuleRequestType(Enum):
    """
    Type of an answering rule, the default value is 'Custom' = ['BusinessHours', 'AfterHours',
    'Custom']
    
    Generated by Python OpenAPI Parser
    """
    
    BusinessHours = 'BusinessHours'
    AfterHours = 'AfterHours'
    Custom = 'Custom'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyAnsweringRuleRequestCallersItem(DataClassJsonMixin):
    caller_id: Optional[str] = None
    """ Phone number of a caller """
    
    name: Optional[str] = None
    """ Displayed name for a caller ID """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyAnsweringRuleRequestCalledNumbersItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of an account phone number """
    
    phone_number: Optional[str] = None
    """ Phone number of a callee """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyAnsweringRuleRequestScheduleWeeklyRangesMondayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyAnsweringRuleRequestScheduleWeeklyRanges(DataClassJsonMixin):
    """ Weekly schedule. If specified, ranges cannot be specified """
    
    monday: Optional[List[CompanyAnsweringRuleRequestScheduleWeeklyRangesMondayItem]] = None
    """ Time interval for a particular day """
    
    tuesday: Optional[list] = None
    """ Time interval for a particular day """
    
    wednesday: Optional[list] = None
    """ Time interval for a particular day """
    
    thursday: Optional[list] = None
    """ Time interval for a particular day """
    
    friday: Optional[list] = None
    """ Time interval for a particular day """
    
    saturday: Optional[list] = None
    """ Time interval for a particular day """
    
    sunday: Optional[list] = None
    """ Time interval for a particular day """
    

class CompanyAnsweringRuleRequestScheduleRef(Enum):
    """ Reference to Business Hours or After Hours schedule """
    
    BusinessHours = 'BusinessHours'
    AfterHours = 'AfterHours'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyAnsweringRuleRequestSchedule(DataClassJsonMixin):
    """ Schedule when an answering rule should be applied """
    
    weekly_ranges: Optional[CompanyAnsweringRuleRequestScheduleWeeklyRanges] = None
    """ Weekly schedule. If specified, ranges cannot be specified """
    
    ranges: Optional[list] = None
    """ Specific data ranges. If specified, weeklyRanges cannot be specified """
    
    ref: Optional[CompanyAnsweringRuleRequestScheduleRef] = None
    """ Reference to Business Hours or After Hours schedule """
    

class CompanyAnsweringRuleRequestCallHandlingAction(Enum):
    """
    Specifies how incoming calls are forwarded. The default value is 'Operator' 'Operator' - play
    company greeting and forward to operator extension 'Disconnect' - play company greeting and
    disconnect 'Bypass' - bypass greeting to go to selected extension = ['Operator', 'Disconnect',
    'Bypass']
    
    Generated by Python OpenAPI Parser
    """
    
    Operator = 'Operator'
    Disconnect = 'Disconnect'
    Bypass = 'Bypass'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyAnsweringRuleRequest(DataClassJsonMixin):
    name: Optional[str] = None
    """
    Name of an answering rule specified by user. Max number of symbols is 30. The default value is
    'My Rule N' where 'N' is the first free number
    """
    
    enabled: Optional[bool] = True
    """ Specifies if the rule is active or inactive. The default value is 'True' """
    
    type: Optional[CompanyAnsweringRuleRequestType] = None
    """
    Type of an answering rule, the default value is 'Custom' = ['BusinessHours', 'AfterHours',
    'Custom']
    """
    
    callers: Optional[List[CompanyAnsweringRuleRequestCallersItem]] = None
    """ Answering rule will be applied when calls are received from the specified caller(s) """
    
    called_numbers: Optional[List[CompanyAnsweringRuleRequestCalledNumbersItem]] = None
    """ Answering rule will be applied when calling the specified number(s) """
    
    schedule: Optional[CompanyAnsweringRuleRequestSchedule] = None
    """ Schedule when an answering rule should be applied """
    
    call_handling_action: Optional[CompanyAnsweringRuleRequestCallHandlingAction] = None
    """
    Specifies how incoming calls are forwarded. The default value is 'Operator' 'Operator' - play
    company greeting and forward to operator extension 'Disconnect' - play company greeting and
    disconnect 'Bypass' - bypass greeting to go to selected extension = ['Operator', 'Disconnect',
    'Bypass']
    """
    
    extension: Optional[str] = None
    """ Extension to which the call is forwarded in 'Bypass' mode """
    
    greetings: Optional[list] = None
    """
    Greetings applied for an answering rule; only predefined greetings can be applied, see
    Dictionary Greeting List
    """
    

class CompanyAnsweringRuleUpdateCallHandlingAction(Enum):
    """
    Specifies how incoming calls are forwarded. The default value is 'Operator' 'Operator' - play
    company greeting and forward to operator extension 'Disconnect' - play company greeting and
    disconnect 'Bypass' - bypass greeting to go to selected extension = ['Operator', 'Disconnect',
    'Bypass']
    
    Generated by Python OpenAPI Parser
    """
    
    Operator = 'Operator'
    Disconnect = 'Disconnect'
    Bypass = 'Bypass'

class CompanyAnsweringRuleUpdateType(Enum):
    """ Type of an answering rule """
    
    BusinessHours = 'BusinessHours'
    AfterHours = 'AfterHours'
    Custom = 'Custom'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyAnsweringRuleUpdate(DataClassJsonMixin):
    enabled: Optional[bool] = True
    """ Specifies if the rule is active or inactive. The default value is 'True' """
    
    name: Optional[str] = None
    """
    Name of an answering rule specified by user. Max number of symbols is 30. The default value is
    'My Rule N' where 'N' is the first free number
    """
    
    callers: Optional[list] = None
    """ Answering rule will be applied when calls are received from the specified caller(s) """
    
    called_numbers: Optional[list] = None
    """ Answering rule will be applied when calling the specified number(s) """
    
    schedule: Optional[dict] = None
    """ Schedule when an answering rule should be applied """
    
    call_handling_action: Optional[CompanyAnsweringRuleUpdateCallHandlingAction] = None
    """
    Specifies how incoming calls are forwarded. The default value is 'Operator' 'Operator' - play
    company greeting and forward to operator extension 'Disconnect' - play company greeting and
    disconnect 'Bypass' - bypass greeting to go to selected extension = ['Operator', 'Disconnect',
    'Bypass']
    """
    
    type: Optional[CompanyAnsweringRuleUpdateType] = 'Custom'
    """ Type of an answering rule """
    
    extension: Optional[str] = None
    """
    Internal identifier of the extension the call is forwarded to. Supported for 'Bypass' mode only
    (that should be specified in `callHandlingAction` field)
    """
    
    greetings: Optional[list] = None
    """
    Greetings applied for an answering rule; only predefined greetings can be applied, see
    Dictionary Greeting List
    """
    

class CompanyAnsweringRuleInfoType(Enum):
    """ Type of an answering rule """
    
    BusinessHours = 'BusinessHours'
    AfterHours = 'AfterHours'
    Custom = 'Custom'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyAnsweringRuleInfoCalledNumbersItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of an account phone number """
    
    phone_number: Optional[str] = None
    """ Phone number of a callee """
    

class CompanyAnsweringRuleInfoScheduleRef(Enum):
    """ Reference to Business Hours or After Hours schedule = ['BusinessHours', 'AfterHours'] """
    
    BusinessHours = 'BusinessHours'
    AfterHours = 'AfterHours'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyAnsweringRuleInfoSchedule(DataClassJsonMixin):
    """ Schedule when an answering rule should be applied """
    
    weekly_ranges: Optional[dict] = None
    """ Weekly schedule. If specified, ranges cannot be specified """
    
    ranges: Optional[list] = None
    """ Specific data ranges. If specified, weeklyRanges cannot be specified """
    
    ref: Optional[CompanyAnsweringRuleInfoScheduleRef] = None
    """ Reference to Business Hours or After Hours schedule = ['BusinessHours', 'AfterHours'] """
    

class CompanyAnsweringRuleInfoCallHandlingAction(Enum):
    """
    Specifies how incoming calls are forwarded. The default value is 'Operator' 'Operator' - play
    company greeting and forward to operator extension 'Disconnect' - play company greeting and
    disconnect 'Bypass' - bypass greeting to go to selected extension = ['Operator', 'Disconnect',
    'Bypass']
    
    Generated by Python OpenAPI Parser
    """
    
    Operator = 'Operator'
    Disconnect = 'Disconnect'
    Bypass = 'Bypass'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyAnsweringRuleInfoExtension(DataClassJsonMixin):
    """ Extension to which the call is forwarded in 'Bypass' mode """
    
    id: Optional[str] = None
    """ Internal identifier of an extension """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyAnsweringRuleInfo(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of an answering rule """
    
    uri: Optional[str] = None
    """ Canonical URI of an answering rule """
    
    enabled: Optional[bool] = True
    """ Specifies if the rule is active or inactive """
    
    type: Optional[CompanyAnsweringRuleInfoType] = 'Custom'
    """ Type of an answering rule """
    
    name: Optional[str] = None
    """
    Name of an answering rule specified by user. Max number of symbols is 30. The default value is
    'My Rule N' where 'N' is the first free number
    """
    
    callers: Optional[list] = None
    """ Answering rule will be applied when calls are received from the specified caller(s) """
    
    called_numbers: Optional[List[CompanyAnsweringRuleInfoCalledNumbersItem]] = None
    """ Answering rule will be applied when calling the specified number(s) """
    
    schedule: Optional[CompanyAnsweringRuleInfoSchedule] = None
    """ Schedule when an answering rule should be applied """
    
    call_handling_action: Optional[CompanyAnsweringRuleInfoCallHandlingAction] = None
    """
    Specifies how incoming calls are forwarded. The default value is 'Operator' 'Operator' - play
    company greeting and forward to operator extension 'Disconnect' - play company greeting and
    disconnect 'Bypass' - bypass greeting to go to selected extension = ['Operator', 'Disconnect',
    'Bypass']
    """
    
    extension: Optional[CompanyAnsweringRuleInfoExtension] = None
    """ Extension to which the call is forwarded in 'Bypass' mode """
    
    greetings: Optional[list] = None
    """
    Greetings applied for an answering rule; only predefined greetings can be applied, see
    Dictionary Greeting List
    """
    

class CallerBlockingSettingsMode(Enum):
    """ Call blocking options: either specific or all calls and faxes """
    
    Specific = 'Specific'
    All = 'All'

class CallerBlockingSettingsNoCallerId(Enum):
    """ Determines how to handle calls with no caller ID in 'Specific' mode """
    
    BlockCallsAndFaxes = 'BlockCallsAndFaxes'
    BlockFaxes = 'BlockFaxes'
    Allow = 'Allow'

class CallerBlockingSettingsPayPhones(Enum):
    """ Blocking settings for pay phones """
    
    Block = 'Block'
    Allow = 'Allow'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CallerBlockingSettings(DataClassJsonMixin):
    """ Returns the lists of blocked and allowed phone numbers """
    
    mode: Optional[CallerBlockingSettingsMode] = None
    """ Call blocking options: either specific or all calls and faxes """
    
    no_caller_id: Optional[CallerBlockingSettingsNoCallerId] = None
    """ Determines how to handle calls with no caller ID in 'Specific' mode """
    
    pay_phones: Optional[CallerBlockingSettingsPayPhones] = None
    """ Blocking settings for pay phones """
    
    greetings: Optional[list] = None
    """ List of greetings played for blocked callers """
    

class AddBlockedAllowedPhoneNumberStatus(Enum):
    """ Status of a phone number """
    
    Blocked = 'Blocked'
    Allowed = 'Allowed'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class AddBlockedAllowedPhoneNumber(DataClassJsonMixin):
    """ Updates either blocked or allowed phone number list with a new phone number. """
    
    phone_number: Optional[str] = None
    """ A blocked/allowed phone number in [E.164](https://www.itu.int/rec/T-REC-E.164-201011-I) format """
    
    label: Optional[str] = None
    """ Custom name of a blocked/allowed phone number """
    
    status: Optional[AddBlockedAllowedPhoneNumberStatus] = 'Blocked'
    """ Status of a phone number """
    

class UpdateAnsweringRuleRequestForwardingRingingMode(Enum):
    """
    Specifies the order in which forwarding numbers ring. 'Sequentially' means that forwarding
    numbers are ringing one at a time, in order of priority. 'Simultaneously' means that forwarding
    numbers are ringing all at the same time. The default value is 'Sequentially'
    
    Generated by Python OpenAPI Parser
    """
    
    Sequentially = 'Sequentially'
    Simultaneously = 'Simultaneously'

class UpdateAnsweringRuleRequestForwardingRulesItemForwardingNumbersItemType(Enum):
    """ Forwarding phone number type """
    
    Home = 'Home'
    Mobile = 'Mobile'
    Work = 'Work'
    PhoneLine = 'PhoneLine'
    Outage = 'Outage'
    Other = 'Other'
    BusinessMobilePhone = 'BusinessMobilePhone'

class UpdateAnsweringRuleRequestForwardingRulesItemForwardingNumbersItemLabel(Enum):
    """ Forwarding/Call flip number title """
    
    Business_Mobile_Phone = 'Business Mobile Phone'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateAnsweringRuleRequestForwardingRulesItemForwardingNumbersItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a forwarding number """
    
    type: Optional[UpdateAnsweringRuleRequestForwardingRulesItemForwardingNumbersItemType] = None
    """ Forwarding phone number type """
    
    uri: Optional[str] = None
    """ Canonical URI of a forwarding/call flip phone number """
    
    phone_number: Optional[str] = None
    """ Forwarding/Call flip phone number """
    
    label: Optional[UpdateAnsweringRuleRequestForwardingRulesItemForwardingNumbersItemLabel] = None
    """ Forwarding/Call flip number title """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateAnsweringRuleRequestForwardingRulesItem(DataClassJsonMixin):
    index: Optional[int] = None
    """ Forwarding number (or group) ordinal. Not returned for inactive numbers """
    
    ring_count: Optional[int] = None
    """
    Number of rings for a forwarding number (or group). For inactive numbers the default value
    ('4') is returned
    """
    
    enabled: Optional[bool] = None
    """ Phone number status """
    
    forwarding_numbers: Optional[List[UpdateAnsweringRuleRequestForwardingRulesItemForwardingNumbersItem]] = None
    """ Forwarding number (or group) data """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateAnsweringRuleRequestForwarding(DataClassJsonMixin):
    """
    Forwarding parameters. Returned if 'ForwardCalls' is specified in 'callHandlingAction'. These
    settings determine the forwarding numbers to which the call will be forwarded
    
    Generated by Python OpenAPI Parser
    """
    
    notify_my_soft_phones: Optional[bool] = None
    """ Specifies if the first ring on desktop/mobile apps is enabled. The default value is 'True' """
    
    notify_admin_soft_phones: Optional[bool] = None
    """
    Specifies if the administrator's softphone (desktop application) is notified before forwarding
    the incoming call to desk phones and forwarding numbers. The default value is 'True'
    """
    
    soft_phones_ring_count: Optional[int] = 1
    """ Specifies delay between ring on apps and starting of a call forwarding """
    
    ringing_mode: Optional[UpdateAnsweringRuleRequestForwardingRingingMode] = None
    """
    Specifies the order in which forwarding numbers ring. 'Sequentially' means that forwarding
    numbers are ringing one at a time, in order of priority. 'Simultaneously' means that forwarding
    numbers are ringing all at the same time. The default value is 'Sequentially'
    """
    
    rules: Optional[List[UpdateAnsweringRuleRequestForwardingRulesItem]] = None
    """ Information on a call forwarding rule """
    
    mobile_timeout: Optional[bool] = None
    """ Specifies if mobile timeout is activated for the rule """
    

class UpdateAnsweringRuleRequestCallHandlingAction(Enum):
    """ Specifies how incoming calls are forwarded """
    
    ForwardCalls = 'ForwardCalls'
    UnconditionalForwarding = 'UnconditionalForwarding'
    AgentQueue = 'AgentQueue'
    TransferToExtension = 'TransferToExtension'
    TakeMessagesOnly = 'TakeMessagesOnly'
    PlayAnnouncementOnly = 'PlayAnnouncementOnly'
    SharedLines = 'SharedLines'

class UpdateAnsweringRuleRequestType(Enum):
    """ Type of an answering rule """
    
    BusinessHours = 'BusinessHours'
    AfterHours = 'AfterHours'
    Custom = 'Custom'

class UpdateAnsweringRuleRequestScreening(Enum):
    """
    Call screening status. 'Off' - no call screening; 'NoCallerId' - if caller ID is missing, then
    callers are asked to say their name before connecting; 'UnknownCallerId' - if caller ID is not
    in contact list, then callers are asked to say their name before connecting; 'Always' - the
    callers are always asked to say their name before connecting. The default value is 'Off'
    
    Generated by Python OpenAPI Parser
    """
    
    Off = 'Off'
    NoCallerId = 'NoCallerId'
    UnknownCallerId = 'UnknownCallerId'
    Always = 'Always'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateAnsweringRuleRequest(DataClassJsonMixin):
    id: Optional[str] = None
    """ Identifier of an answering rule """
    
    forwarding: Optional[UpdateAnsweringRuleRequestForwarding] = None
    """
    Forwarding parameters. Returned if 'ForwardCalls' is specified in 'callHandlingAction'. These
    settings determine the forwarding numbers to which the call will be forwarded
    """
    
    enabled: Optional[bool] = None
    """ Specifies if the rule is active or inactive. The default value is 'True' """
    
    name: Optional[str] = None
    """ Name of an answering rule specified by user """
    
    callers: Optional[list] = None
    """ Answering rule will be applied when calls are received from the specified caller(s) """
    
    called_numbers: Optional[list] = None
    """ Answering rules are applied when calling to selected number(s) """
    
    schedule: Optional[dict] = None
    """ Schedule when an answering rule should be applied """
    
    call_handling_action: Optional[UpdateAnsweringRuleRequestCallHandlingAction] = None
    """ Specifies how incoming calls are forwarded """
    
    type: Optional[UpdateAnsweringRuleRequestType] = None
    """ Type of an answering rule """
    
    unconditional_forwarding: Optional[dict] = None
    """
    Unconditional forwarding parameters. Returned if 'UnconditionalForwarding' is specified in
    'callHandlingAction'
    """
    
    queue: Optional[dict] = None
    """
    Queue settings applied for department (call queue) extension type, with the 'AgentQueue' value
    specified as a call handling action
    """
    
    voicemail: Optional[dict] = None
    """ Specifies whether to take a voicemail and who should do it """
    
    greetings: Optional[list] = None
    """
    Greetings applied for an answering rule; only predefined greetings can be applied, see
    Dictionary Greeting List
    """
    
    screening: Optional[UpdateAnsweringRuleRequestScreening] = None
    """
    Call screening status. 'Off' - no call screening; 'NoCallerId' - if caller ID is missing, then
    callers are asked to say their name before connecting; 'UnknownCallerId' - if caller ID is not
    in contact list, then callers are asked to say their name before connecting; 'Always' - the
    callers are always asked to say their name before connecting. The default value is 'Off'
    """
    
    show_inactive_numbers: Optional[bool] = None
    """ Indicates whether inactive numbers should be returned or not """
    
    transfer: Optional[dict] = None
    """
    Transfer settings applied for department (call queue) extension type, with
    'TransferToExtension' call handling action
    """
    

class CompanyAnsweringRuleListRecordsItemType(Enum):
    """
    Type of an answering rule, the default value is 'Custom' = ['BusinessHours', 'AfterHours',
    'Custom']
    
    Generated by Python OpenAPI Parser
    """
    
    BusinessHours = 'BusinessHours'
    AfterHours = 'AfterHours'
    Custom = 'Custom'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyAnsweringRuleListRecordsItemExtension(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of an extension """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyAnsweringRuleListRecordsItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of an answering rule """
    
    uri: Optional[str] = None
    """ Canonical URI of an answering rule """
    
    enabled: Optional[bool] = True
    """ Specifies if the rule is active or inactive. The default value is 'True' """
    
    type: Optional[CompanyAnsweringRuleListRecordsItemType] = None
    """
    Type of an answering rule, the default value is 'Custom' = ['BusinessHours', 'AfterHours',
    'Custom']
    """
    
    name: Optional[str] = None
    """
    Name of an answering rule specified by user. Max number of symbols is 30. The default value is
    'My Rule N' where 'N' is the first free number
    """
    
    called_numbers: Optional[list] = None
    """ Answering rules are applied when calling to selected number(s) """
    
    extension: Optional[CompanyAnsweringRuleListRecordsItemExtension] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CompanyAnsweringRuleList(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to an answering rule resource """
    
    records: Optional[List[CompanyAnsweringRuleListRecordsItem]] = None
    """ List of company answering rules """
    
    paging: Optional[dict] = None
    """ Information on paging """
    
    navigation: Optional[dict] = None
    """ Information on navigation """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class IVRPrompts(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to prompts library resource """
    
    records: Optional[list] = None
    """ List of Prompts """
    
    navigation: Optional[dict] = None
    """ Information on navigation """
    
    paging: Optional[dict] = None
    """ Information on paging """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetUserBusinessHoursResponseSchedule(DataClassJsonMixin):
    """ Schedule when an answering rule is applied """
    
    weekly_ranges: Optional[dict] = None
    """ Weekly schedule """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetUserBusinessHoursResponse(DataClassJsonMixin):
    """
    Example:
        ```json
        {
            "uri": "https.../restapi/v1.0/account/401800045008/extension/401800045008/business-hours",
            "schedule": {
                "weeklyRanges": {
                    "wednesday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "friday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "tuesday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "monday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "thursday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ]
                }
            }
        }
        ```
    
    Generated by Python OpenAPI Parser
    """
    
    uri: Optional[str] = None
    """ Canonical URI of a business-hours resource """
    
    schedule: Optional[GetUserBusinessHoursResponseSchedule] = None
    """ Schedule when an answering rule is applied """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CallRecordingSettingsResourceOnDemand(DataClassJsonMixin):
    enabled: Optional[bool] = None
    """ Flag for controlling OnDemand Call Recording settings """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CallRecordingSettingsResourceAutomatic(DataClassJsonMixin):
    enabled: Optional[bool] = None
    """ Flag for controling Automatic Call Recording settings """
    
    outbound_call_tones: Optional[bool] = None
    """ Flag for controlling 'Play Call Recording Announcement for Outbound Calls' settings """
    
    outbound_call_announcement: Optional[bool] = None
    """ Flag for controlling 'Play periodic tones for outbound calls' settings """
    
    allow_mute: Optional[bool] = None
    """ Flag for controlling 'Allow mute in auto call recording' settings """
    
    extension_count: Optional[int] = None
    """ Total amount of extension that are used in call recordings """
    

class CallRecordingSettingsResourceGreetingsItemType(Enum):
    StartRecording = 'StartRecording'
    StopRecording = 'StopRecording'
    AutomaticRecording = 'AutomaticRecording'

class CallRecordingSettingsResourceGreetingsItemMode(Enum):
    """
    'Default' value specifies that all greetings of that type (in all languages) are default, if at
    least one greeting (in any language) of the specified type is custom, then 'Custom' value is
    returned.
    
    Generated by Python OpenAPI Parser
    """
    
    Default = 'Default'
    Custom = 'Custom'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CallRecordingSettingsResourceGreetingsItem(DataClassJsonMixin):
    type: Optional[CallRecordingSettingsResourceGreetingsItemType] = None
    mode: Optional[CallRecordingSettingsResourceGreetingsItemMode] = None
    """
    'Default' value specifies that all greetings of that type (in all languages) are default, if at
    least one greeting (in any language) of the specified type is custom, then 'Custom' value is
    returned.
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CallRecordingSettingsResource(DataClassJsonMixin):
    on_demand: Optional[CallRecordingSettingsResourceOnDemand] = None
    automatic: Optional[CallRecordingSettingsResourceAutomatic] = None
    greetings: Optional[List[CallRecordingSettingsResourceGreetingsItem]] = None
    """ Collection of Greeting Info """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationRequestDevice(DataClassJsonMixin):
    """ Device unique description """
    
    id: Optional[str] = None
    """ Device unique identifier, retrieved on previous session (if any) """
    
    app_external_id: Optional[str] = None
    """
    Supported for iOS devices only. Certificate name (used by iOS applications for APNS
    subscription)
    """
    
    computer_name: Optional[str] = None
    """ Supported for SoftPhone only. Computer name """
    
    serial: Optional[str] = None
    """
    Serial number for HardPhone; endpoint_id for softphone and mobile applications. Returned only
    when the phone is shipped and provisioned
    """
    

class CreateSipRegistrationRequestSipInfoItemTransport(Enum):
    """ Supported transport. SIP info will be returned for this transport if supported """
    
    UDP = 'UDP'
    TCP = 'TCP'
    TLS = 'TLS'
    WS = 'WS'
    WSS = 'WSS'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationRequestSipInfoItem(DataClassJsonMixin):
    transport: Optional[CreateSipRegistrationRequestSipInfoItemTransport] = None
    """ Supported transport. SIP info will be returned for this transport if supported """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationRequest(DataClassJsonMixin):
    device: Optional[CreateSipRegistrationRequestDevice] = None
    """ Device unique description """
    
    sip_info: Optional[List[CreateSipRegistrationRequestSipInfoItem]] = None
    """ SIP settings for device """
    

class CreateSipRegistrationResponseDeviceType(Enum):
    """ Device type """
    
    HardPhone = 'HardPhone'
    SoftPhone = 'SoftPhone'
    OtherPhone = 'OtherPhone'
    Paging = 'Paging'
    WebPhone = 'WebPhone'

class CreateSipRegistrationResponseDeviceStatus(Enum):
    Online = 'Online'
    Offline = 'Offline'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseDeviceModelAddonsItem(DataClassJsonMixin):
    id: Optional[str] = None
    name: Optional[str] = None
    count: Optional[str] = None

class CreateSipRegistrationResponseDeviceModelFeaturesItem(Enum):
    BLA = 'BLA'
    Intercom = 'Intercom'
    Paging = 'Paging'
    HELD = 'HELD'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseDeviceModel(DataClassJsonMixin):
    """
    HardPhone model information
    
    Required Properties:
     - addons
    
    Generated by Python OpenAPI Parser
    """
    
    addons: List[CreateSipRegistrationResponseDeviceModelAddonsItem]
    """ Addons description """
    
    id: Optional[str] = None
    """
    Addon identifier. For HardPhones of certain types, which are compatible with this addon
    identifier
    """
    
    name: Optional[str] = None
    """ Device name """
    
    features: Optional[List[CreateSipRegistrationResponseDeviceModelFeaturesItem]] = None
    """ Device feature or multiple features supported """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseDeviceExtension(DataClassJsonMixin):
    """ Internal identifier of an extension the device should be assigned to """
    
    id: Optional[int] = None
    """ Internal identifier of an extension """
    
    uri: Optional[str] = None
    """ Link to an extension resource """
    
    extension_number: Optional[str] = None
    """ Number of extension """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseDeviceEmergencyServiceAddress(DataClassJsonMixin):
    """
    Address for emergency cases. The same emergency address is assigned to all the numbers of one
    device
    
    Generated by Python OpenAPI Parser
    """
    
    street: Optional[str] = None
    street2: Optional[str] = None
    city: Optional[str] = None
    zip: Optional[str] = None
    customer_name: Optional[str] = None
    state: Optional[str] = None
    """ State/province name """
    
    state_id: Optional[str] = None
    """ Internal identifier of a state """
    
    state_iso_code: Optional[str] = None
    """ ISO code of a state """
    
    state_name: Optional[str] = None
    """ Full name of a state """
    
    country_id: Optional[str] = None
    """ Internal identifier of a country """
    
    country_iso_code: Optional[str] = None
    """ ISO code of a country """
    
    country: Optional[str] = None
    """ Country name """
    
    country_name: Optional[str] = None
    """ Full name of a country """
    
    out_of_country: Optional[bool] = None
    """ Specifies if emergency address is out of country """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseDeviceEmergencyLocation(DataClassJsonMixin):
    """ Company emergency response location details """
    
    id: Optional[str] = None
    """ Internal identifier of an emergency response location """
    
    name: Optional[str] = None
    """ Emergency response location name """
    

class CreateSipRegistrationResponseDeviceEmergencyAddressStatus(Enum):
    """ Emergency address status """
    
    Valid = 'Valid'
    Invalid = 'Invalid'

class CreateSipRegistrationResponseDeviceEmergencySyncStatus(Enum):
    """
    Resulting status of emergency address synchronization. Returned if `syncEmergencyAddress`
    parameter is set to 'True'
    
    Generated by Python OpenAPI Parser
    """
    
    Verified = 'Verified'
    Updated = 'Updated'
    Deleted = 'Deleted'
    NotRequired = 'NotRequired'
    Unsupported = 'Unsupported'
    Failed = 'Failed'

class CreateSipRegistrationResponseDeviceEmergencyAddressEditableStatus(Enum):
    """
    Ability to register new emergency address for a phone line using devices sharing this line or
    only main device (line owner)
    
    Generated by Python OpenAPI Parser
    """
    
    MainDevice = 'MainDevice'
    AnyDevice = 'AnyDevice'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseDeviceEmergency(DataClassJsonMixin):
    """ Emergency response location settings of a device """
    
    address: Optional[dict] = None
    location: Optional[CreateSipRegistrationResponseDeviceEmergencyLocation] = None
    """ Company emergency response location details """
    
    out_of_country: Optional[bool] = None
    """ Specifies if emergency address is out of country """
    
    address_status: Optional[CreateSipRegistrationResponseDeviceEmergencyAddressStatus] = None
    """ Emergency address status """
    
    sync_status: Optional[CreateSipRegistrationResponseDeviceEmergencySyncStatus] = None
    """
    Resulting status of emergency address synchronization. Returned if `syncEmergencyAddress`
    parameter is set to 'True'
    """
    
    address_editable_status: Optional[CreateSipRegistrationResponseDeviceEmergencyAddressEditableStatus] = None
    """
    Ability to register new emergency address for a phone line using devices sharing this line or
    only main device (line owner)
    """
    
    address_required: Optional[bool] = None
    """ 'True' if emergency address is required for the country of a phone line """
    
    address_location_only: Optional[bool] = None
    """ 'True' if out of country emergency address is not allowed for the country of a phone line """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseDeviceShippingMethod(DataClassJsonMixin):
    id: Optional[str] = None
    name: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseDeviceShipping(DataClassJsonMixin):
    """
    Shipping information, according to which devices (in case of HardPhone ) or e911 stickers (in
    case of SoftPhone and OtherPhone ) will be delivered to the customer
    
    Generated by Python OpenAPI Parser
    """
    
    address: Optional[dict] = None
    method: Optional[CreateSipRegistrationResponseDeviceShippingMethod] = None
    status: Optional[str] = None
    carrier: Optional[str] = None
    tracking_number: Optional[str] = None

class CreateSipRegistrationResponseDevicePhoneLinesItemLineType(Enum):
    """ Type of phone line """
    
    Standalone = 'Standalone'
    StandaloneFree = 'StandaloneFree'
    BlaPrimary = 'BlaPrimary'
    BlaSecondary = 'BlaSecondary'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseDevicePhoneLinesItemEmergencyAddress(DataClassJsonMixin):
    required: Optional[bool] = None
    """ 'True' if specifying of emergency address is required """
    
    local_only: Optional[bool] = None
    """ 'True' if only local emergency address can be specified """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseDevicePhoneLinesItemPhoneInfoCountry(DataClassJsonMixin):
    """ Brief information on a phone number country """
    
    id: Optional[str] = None
    """ Internal identifier of a home country """
    
    uri: Optional[str] = None
    """ Canonical URI of a home country """
    
    name: Optional[str] = None
    """ Official name of a home country """
    

class CreateSipRegistrationResponseDevicePhoneLinesItemPhoneInfoPaymentType(Enum):
    """
    Payment type. 'External' is returned for forwarded numbers which are not terminated in the
    RingCentral phone system = ['External', 'TollFree', 'Local'],
    
    Generated by Python OpenAPI Parser
    """
    
    External = 'External'
    TollFree = 'TollFree'
    Local = 'Local'

class CreateSipRegistrationResponseDevicePhoneLinesItemPhoneInfoUsageType(Enum):
    CompanyNumber = 'CompanyNumber'
    MainCompanyNumber = 'MainCompanyNumber'
    AdditionalCompanyNumber = 'AdditionalCompanyNumber'
    DirectNumber = 'DirectNumber'
    CompanyFaxNumber = 'CompanyFaxNumber'
    ForwardedNumber = 'ForwardedNumber'
    ForwardedCompanyNumber = 'ForwardedCompanyNumber'
    ContactCenterNumber = 'ContactCenterNumber'

class CreateSipRegistrationResponseDevicePhoneLinesItemPhoneInfoType(Enum):
    """ Type of a phone number """
    
    VoiceFax = 'VoiceFax'
    FaxOnly = 'FaxOnly'
    VoiceOnly = 'VoiceOnly'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseDevicePhoneLinesItemPhoneInfo(DataClassJsonMixin):
    """ Phone number information """
    
    id: Optional[int] = None
    """ Internal identifier of a phone number """
    
    country: Optional[CreateSipRegistrationResponseDevicePhoneLinesItemPhoneInfoCountry] = None
    """ Brief information on a phone number country """
    
    payment_type: Optional[CreateSipRegistrationResponseDevicePhoneLinesItemPhoneInfoPaymentType] = None
    """
    Payment type. 'External' is returned for forwarded numbers which are not terminated in the
    RingCentral phone system = ['External', 'TollFree', 'Local'],
    """
    
    phone_number: Optional[str] = None
    """ Phone number """
    
    usage_type: Optional[CreateSipRegistrationResponseDevicePhoneLinesItemPhoneInfoUsageType] = None
    type: Optional[CreateSipRegistrationResponseDevicePhoneLinesItemPhoneInfoType] = None
    """ Type of a phone number """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseDevicePhoneLinesItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a phone line """
    
    line_type: Optional[CreateSipRegistrationResponseDevicePhoneLinesItemLineType] = None
    """ Type of phone line """
    
    emergency_address: Optional[CreateSipRegistrationResponseDevicePhoneLinesItemEmergencyAddress] = None
    phone_info: Optional[CreateSipRegistrationResponseDevicePhoneLinesItemPhoneInfo] = None
    """ Phone number information """
    

class CreateSipRegistrationResponseDeviceLinePooling(Enum):
    """
    Pooling type of a deviceHost - device with standalone paid phone line which can be linked to
    Glip/Softphone instanceGuest - device with a linked phone lineNone - device without a phone
    line or with specific line (free, BLA, etc.) = ['Host', 'Guest', 'None']
    
    Generated by Python OpenAPI Parser
    """
    
    Host = 'Host'
    Guest = 'Guest'
    None_ = 'None'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseDeviceSite(DataClassJsonMixin):
    """ Site data """
    
    id: Optional[str] = None
    """ Internal identifier of a site """
    
    name: Optional[str] = None
    """ Name of a site """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseDevice(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to a device resource """
    
    id: Optional[str] = None
    """ Internal identifier of a Device """
    
    type: Optional[CreateSipRegistrationResponseDeviceType] = None
    """ Device type """
    
    sku: Optional[str] = None
    """
    Device identification number (stock keeping unit) in the format TP-ID [-AT-AC], where TP is
    device type (HP for RC HardPhone, DV for all other devices including softphone); ID - device
    model ID; AT -addon type ID; AC - addon count (if any). For example 'HP-56-2-2'
    """
    
    status: Optional[CreateSipRegistrationResponseDeviceStatus] = None
    name: Optional[str] = None
    """
    Device name. Mandatory if ordering SoftPhone or OtherPhone. Optional for HardPhone. If not
    specified for HardPhone, then device model name is used as device name
    """
    
    serial: Optional[str] = None
    """
    Serial number for HardPhone (is returned only when the phone is shipped and provisioned);
    endpoint_id for softphone and mobile applications
    """
    
    computer_name: Optional[str] = None
    """ PC name for softphone """
    
    model: Optional[CreateSipRegistrationResponseDeviceModel] = None
    """ HardPhone model information """
    
    extension: Optional[CreateSipRegistrationResponseDeviceExtension] = None
    """ Internal identifier of an extension the device should be assigned to """
    
    emergency_service_address: Optional[CreateSipRegistrationResponseDeviceEmergencyServiceAddress] = None
    """
    Address for emergency cases. The same emergency address is assigned to all the numbers of one
    device
    """
    
    emergency: Optional[CreateSipRegistrationResponseDeviceEmergency] = None
    """ Emergency response location settings of a device """
    
    shipping: Optional[CreateSipRegistrationResponseDeviceShipping] = None
    """
    Shipping information, according to which devices (in case of HardPhone ) or e911 stickers (in
    case of SoftPhone and OtherPhone ) will be delivered to the customer
    """
    
    phone_lines: Optional[List[CreateSipRegistrationResponseDevicePhoneLinesItem]] = None
    """ Phone lines information """
    
    box_billing_id: Optional[int] = None
    """
    Box billing identifier of a device. Applicable only for HardPhones. It is an alternative way to
    identify the device to be ordered. EitherT? model structure, or boxBillingId must be specified
    forT?HardPhone
    """
    
    use_as_common_phone: Optional[bool] = None
    """
    Supported only for devices assigned to Limited extensions. If true, enables users to log in to
    this phone as a common phone.
    """
    
    line_pooling: Optional[CreateSipRegistrationResponseDeviceLinePooling] = None
    """
    Pooling type of a deviceHost - device with standalone paid phone line which can be linked to
    Glip/Softphone instanceGuest - device with a linked phone lineNone - device without a phone
    line or with specific line (free, BLA, etc.) = ['Host', 'Guest', 'None']
    """
    
    in_company_net: Optional[bool] = None
    """
    Network location status. 'True' if the device is located in the configured corporate network
    (On-Net); 'False' for Off-Net location. Parameter is not returned if
    `EmergencyAddressAutoUpdate` feature is not enabled for the account/user, or if device network
    location is not determined
    """
    
    site: Optional[CreateSipRegistrationResponseDeviceSite] = None
    """ Site data """
    
    last_location_report_time: Optional[str] = None
    """
    Datetime of receiving last location report in [ISO
    8601](https://en.wikipedia.org/wiki/ISO_8601) format including timezone, for example
    *2016-03-10T18:07:52.534Z
    """
    

class CreateSipRegistrationResponseSipInfoItemTransport(Enum):
    """ Preferred transport. SIP info will be returned for this transport if supported """
    
    UDP = 'UDP'
    TCP = 'TCP'
    TLS = 'TLS'
    WS = 'WS'
    WSS = 'WSS'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseSipInfoItem(DataClassJsonMixin):
    username: Optional[str] = None
    """ User credentials """
    
    password: Optional[str] = None
    """ User password """
    
    authorization_id: Optional[str] = None
    """ Identifier for SIP authorization """
    
    omain: Optional[str] = None
    """ SIP domain """
    
    outbound_proxy: Optional[str] = None
    """ SIP outbound proxy """
    
    outbound_proxy_i_pv6: Optional[str] = None
    """ SIP outbound IPv6 proxy """
    
    outbound_proxy_backup: Optional[str] = None
    """ SIP outbound proxy backup """
    
    outbound_proxy_i_pv6_backup: Optional[str] = None
    """ SIP outbound IPv6 proxy backup """
    
    transport: Optional[CreateSipRegistrationResponseSipInfoItemTransport] = None
    """ Preferred transport. SIP info will be returned for this transport if supported """
    
    certificate: Optional[str] = None
    """ For TLS transport only Base64 encoded certificate """
    
    switch_back_interval: Optional[int] = None
    """
    The interval in seconds after which the app must try to switch back to primary proxy if it was
    previously switched to backup. If this parameter is not returned, the app must stay on backup
    proxy and try to switch to primary proxy after the next SIP-provision call.
    """
    

class CreateSipRegistrationResponseSipFlagsVoipFeatureEnabled(Enum):
    """ If 'True' VoIP calling feature is enabled """
    
    True_ = 'True'
    False_ = 'False'

class CreateSipRegistrationResponseSipFlagsVoipCountryBlocked(Enum):
    """ If 'True' the request is sent from IP address of a country blocked for VoIP calling """
    
    True_ = 'True'
    False_ = 'False'

class CreateSipRegistrationResponseSipFlagsOutboundCallsEnabled(Enum):
    """ If 'True' outbound calls are enabled """
    
    True_ = 'True'
    False_ = 'False'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponseSipFlags(DataClassJsonMixin):
    """ SIP flags data """
    
    voip_feature_enabled: Optional[CreateSipRegistrationResponseSipFlagsVoipFeatureEnabled] = None
    """ If 'True' VoIP calling feature is enabled """
    
    voip_country_blocked: Optional[CreateSipRegistrationResponseSipFlagsVoipCountryBlocked] = None
    """ If 'True' the request is sent from IP address of a country blocked for VoIP calling """
    
    outbound_calls_enabled: Optional[CreateSipRegistrationResponseSipFlagsOutboundCallsEnabled] = None
    """ If 'True' outbound calls are enabled """
    
    dscp_enabled: Optional[bool] = None
    dscp_signaling: Optional[int] = None
    dscp_voice: Optional[int] = None
    dscp_video: Optional[int] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSipRegistrationResponse(DataClassJsonMixin):
    """
    Required Properties:
     - sip_flags
     - sip_info
    
    Generated by Python OpenAPI Parser
    """
    
    sip_info: List[CreateSipRegistrationResponseSipInfoItem]
    """ SIP settings for device """
    
    sip_flags: CreateSipRegistrationResponseSipFlags
    """ SIP flags data """
    
    device: Optional[CreateSipRegistrationResponseDevice] = None
    sip_info_pstn: Optional[list] = None
    """ SIP PSTN settings for device """
    
    sip_error_codes: Optional[List[str]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetTimezoneListResponseRecordsItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a timezone """
    
    uri: Optional[str] = None
    """ Canonical URI of a timezone """
    
    name: Optional[str] = None
    """ Short name of a timezone """
    
    description: Optional[str] = None
    """ Description of a timezone """
    
    bias: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetTimezoneListResponseNavigationFirstPage(DataClassJsonMixin):
    """ Canonical URI for the first page of the list """
    
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetTimezoneListResponseNavigation(DataClassJsonMixin):
    """ Information on navigation """
    
    first_page: Optional[GetTimezoneListResponseNavigationFirstPage] = None
    """ Canonical URI for the first page of the list """
    
    next_page: Optional[dict] = None
    """ Canonical URI for the next page of the list """
    
    previous_page: Optional[dict] = None
    """ Canonical URI for the previous page of the list """
    
    last_page: Optional[dict] = None
    """ Canonical URI for the last page of the list """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetTimezoneListResponsePaging(DataClassJsonMixin):
    """ Information on paging """
    
    page: Optional[int] = None
    """
    The current page number. 1-indexed, so the first page is 1 by default. May be omitted if result
    is empty (because non-existent page was specified or perPage=0 was requested)
    """
    
    per_page: Optional[int] = None
    """
    Current page size, describes how many items are in each page. Default value is 100. Maximum
    value is 1000. If perPage value in the request is greater than 1000, the maximum value (1000)
    is applied
    """
    
    page_start: Optional[int] = None
    """
    The zero-based number of the first element on the current page. Omitted if the page is omitted
    or result is empty
    """
    
    page_end: Optional[int] = None
    """
    The zero-based index of the last element on the current page. Omitted if the page is omitted or
    result is empty
    """
    
    total_pages: Optional[int] = None
    """
    The total number of pages in a dataset. May be omitted for some resources due to performance
    reasons
    """
    
    total_elements: Optional[int] = None
    """
    The total number of elements in a dataset. May be omitted for some resource due to performance
    reasons
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetTimezoneListResponse(DataClassJsonMixin):
    """
    Required Properties:
     - navigation
     - paging
     - records
    
    Generated by Python OpenAPI Parser
    """
    
    records: List[GetTimezoneListResponseRecordsItem]
    """ List of timezones """
    
    navigation: GetTimezoneListResponseNavigation
    """ Information on navigation """
    
    paging: GetTimezoneListResponsePaging
    """ Information on paging """
    
    uri: Optional[str] = None
    """ Link to the timezone list resource """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UserCallQueuesRecordsItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Call queue extension identifier """
    
    name: Optional[str] = None
    """ Call queue name (read-only) """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UserCallQueues(DataClassJsonMixin):
    records: Optional[List[UserCallQueuesRecordsItem]] = None
    """ List of the queues where the extension is an agent """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class DepartmentBulkAssignResourceItemsItem(DataClassJsonMixin):
    department_id: Optional[str] = None
    added_extension_ids: Optional[List[str]] = None
    removed_extension_ids: Optional[List[str]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class DepartmentBulkAssignResource(DataClassJsonMixin):
    items: Optional[List[DepartmentBulkAssignResourceItemsItem]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class PagingOnlyGroupUsersRecordsItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a paging group user extension """
    
    uri: Optional[str] = None
    """ Link to a paging group user extension """
    
    extension_number: Optional[str] = None
    """ Extension number of a paging group user """
    
    name: Optional[str] = None
    """ Name of a paging group user """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class PagingOnlyGroupUsers(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to the list of users allowed to page the Paging Only group """
    
    records: Optional[List[PagingOnlyGroupUsersRecordsItem]] = None
    """ List of users allowed to page the Paging Only group """
    
    navigation: Optional[dict] = None
    """ Information on navigation """
    
    paging: Optional[dict] = None
    """ Information on paging """
    

class ListDevicesAutomaticLocationUpdatesRecordsItemType(Enum):
    """ Device type """
    
    HardPhone = 'HardPhone'
    SoftPhone = 'SoftPhone'
    OtherPhone = 'OtherPhone'

class ListDevicesAutomaticLocationUpdatesRecordsItemModelFeaturesItem(Enum):
    BLA = 'BLA'
    Intercom = 'Intercom'
    Paging = 'Paging'
    HELD = 'HELD'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListDevicesAutomaticLocationUpdatesRecordsItemModel(DataClassJsonMixin):
    """ HardPhone model information """
    
    id: Optional[str] = None
    """ Device model identifier """
    
    name: Optional[str] = None
    """ Device name """
    
    features: Optional[List[ListDevicesAutomaticLocationUpdatesRecordsItemModelFeaturesItem]] = None
    """ Device feature or multiple features supported """
    

class ListDevicesAutomaticLocationUpdatesRecordsItemPhoneLinesItemLineType(Enum):
    Unknown = 'Unknown'
    Standalone = 'Standalone'
    StandaloneFree = 'StandaloneFree'
    BlaPrimary = 'BlaPrimary'
    BlaSecondary = 'BlaSecondary'
    BLF = 'BLF'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListDevicesAutomaticLocationUpdatesRecordsItemPhoneLinesItemPhoneInfo(DataClassJsonMixin):
    id: Optional[int] = None
    """ Internal identifier of a phone number """
    
    phone_number: Optional[str] = None
    """ Phone number """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListDevicesAutomaticLocationUpdatesRecordsItemPhoneLinesItem(DataClassJsonMixin):
    line_type: Optional[ListDevicesAutomaticLocationUpdatesRecordsItemPhoneLinesItemLineType] = None
    phone_info: Optional[ListDevicesAutomaticLocationUpdatesRecordsItemPhoneLinesItemPhoneInfo] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListDevicesAutomaticLocationUpdatesRecordsItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a device """
    
    type: Optional[ListDevicesAutomaticLocationUpdatesRecordsItemType] = 'HardPhone'
    """ Device type """
    
    serial: Optional[str] = None
    """ Serial number for HardPhone (is returned only when the phone is shipped and provisioned) """
    
    feature_enabled: Optional[bool] = None
    """ Specifies if Automatic Location Updates feature is enabled """
    
    name: Optional[str] = None
    """ Device name """
    
    model: Optional[ListDevicesAutomaticLocationUpdatesRecordsItemModel] = None
    """ HardPhone model information """
    
    site: Optional[str] = None
    """ Site data """
    
    phone_lines: Optional[List[ListDevicesAutomaticLocationUpdatesRecordsItemPhoneLinesItem]] = None
    """ Phone lines information """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListDevicesAutomaticLocationUpdates(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to devices resource """
    
    records: Optional[List[ListDevicesAutomaticLocationUpdatesRecordsItem]] = None
    """ List of users' devices with the current status of Emergency Address Auto Update Feature """
    
    navigation: Optional[dict] = None
    paging: Optional[dict] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetConferencingInfoResponsePhoneNumbersItemCountry(DataClassJsonMixin):
    """ Information on a home country of a conference phone number """
    
    id: Optional[str] = None
    """ Internal identifier of a country """
    
    uri: Optional[str] = None
    """ Canonical URI of a country """
    
    calling_code: Optional[str] = None
    """
    Country calling code defined by ITU-T recommendations
    [E.123](https://www.itu.int/rec/T-REC-E.123-200102-I/en) and
    [E.164](https://www.itu.int/rec/T-REC-E.164-201011-I)
    """
    
    emergency_calling: Optional[bool] = None
    """ Emergency calling feature availability/emergency address requirement indicator """
    
    iso_code: Optional[str] = None
    """
    Country code according to the ISO standard, see [ISO
    3166](https://www.iso.org/iso-3166-country-codes.html)
    """
    
    name: Optional[str] = None
    """ Official name of a country """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetConferencingInfoResponsePhoneNumbersItem(DataClassJsonMixin):
    country: Optional[GetConferencingInfoResponsePhoneNumbersItemCountry] = None
    """ Information on a home country of a conference phone number """
    
    default: Optional[bool] = None
    """
    'True' if the number is default for the conference. Default conference number is a domestic
    number that can be set by user (otherwise it is set by the system). Only one default number per
    country is allowed
    """
    
    has_greeting: Optional[bool] = None
    """ 'True' if the greeting message is played on this number """
    
    location: Optional[str] = None
    """ Location (city, region, state) of a conference phone number """
    
    phone_number: Optional[str] = None
    """ Dial-in phone number to connect to a conference """
    
    premium: Optional[bool] = None
    """
    Indicates if the number is 'premium' (account phone number with the `ConferencingNumber`
    usageType)
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetConferencingInfoResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Canonical URI of a conferencing """
    
    allow_join_before_host: Optional[bool] = None
    """ Determines if host user allows conference participants to join before the host """
    
    host_code: Optional[str] = None
    """ Access code for a host user """
    
    mode: Optional[str] = None
    """ Internal parameter specifying conferencing engine """
    
    participant_code: Optional[str] = None
    """ Access code for any participant """
    
    phone_number: Optional[str] = None
    """
    Primary conference phone number for user's home country returned in
    [E.164](https://www.itu.int/rec/T-REC-E.164-201011-I) format
    """
    
    tap_to_join_uri: Optional[str] = None
    """ Short URL leading to the service web page Tap to Join for audio conference bridge """
    
    phone_numbers: Optional[List[GetConferencingInfoResponsePhoneNumbersItem]] = None
    """
    List of multiple dial-in phone numbers to connect to audio conference service, relevant for
    user's brand. Each number is given with the country and location information, in order to let
    the user choose the less expensive way to connect to a conference. The first number in the list
    is the primary conference number, that is default and domestic
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetExtensionPhoneNumbersResponseRecordsItemCountry(DataClassJsonMixin):
    """ Brief information on a phone number country """
    
    id: Optional[str] = None
    """ Internal identifier of a home country """
    
    uri: Optional[str] = None
    """ Canonical URI of a home country """
    
    name: Optional[str] = None
    """ Official name of a home country """
    
    iso_code: Optional[str] = None
    """ ISO code of a country """
    
    calling_code: Optional[str] = None
    """ Calling code of a country """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetExtensionPhoneNumbersResponseRecordsItemContactCenterProvider(DataClassJsonMixin):
    """
    CCRN (Contact Center Routing Number) provider. If not specified then the default value
    'InContact/North America' is used, its ID is '1'
    
    Generated by Python OpenAPI Parser
    """
    
    id: Optional[str] = None
    """ Internal identifier of the provider """
    
    name: Optional[str] = None
    """ Provider's name """
    

class GetExtensionPhoneNumbersResponseRecordsItemExtensionType(Enum):
    """ Extension type """
    
    User = 'User'
    FaxUser = 'FaxUser'
    VirtualUser = 'VirtualUser'
    DigitalUser = 'DigitalUser'
    Department = 'Department'
    Announcement = 'Announcement'
    Voicemail = 'Voicemail'
    SharedLinesGroup = 'SharedLinesGroup'
    PagingOnly = 'PagingOnly'
    IvrMenu = 'IvrMenu'
    ApplicationExtension = 'ApplicationExtension'
    ParkLocation = 'ParkLocation'
    Site = 'Site'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetExtensionPhoneNumbersResponseRecordsItemExtension(DataClassJsonMixin):
    """
    Information on the extension, to which the phone number is assigned. Returned only for the
    request of Account phone number list
    
    Generated by Python OpenAPI Parser
    """
    
    id: Optional[int] = None
    """ Internal identifier of an extension """
    
    uri: Optional[str] = None
    """ Canonical URI of an extension """
    
    extension_number: Optional[str] = None
    """ Number of department extension """
    
    partner_id: Optional[str] = None
    """
    For Partner Applications Internal identifier of an extension created by partner. The
    RingCentral supports the mapping of accounts and stores the corresponding account ID/extension
    ID for each partner ID of a client application. In request URIs partner IDs are accepted
    instead of regular RingCentral native IDs as path parameters using pid = XXX clause. Though in
    response URIs contain the corresponding account IDs and extension IDs. In all request and
    response bodies these values are reflected via partnerId attributes of account and extension
    """
    
    type: Optional[GetExtensionPhoneNumbersResponseRecordsItemExtensionType] = None
    """ Extension type """
    
    contact_center_provider: Optional[dict] = None
    """
    CCRN (Contact Center Routing Number) provider. If not specified then the default value
    'InContact/North America' is used, its ID is '1'
    """
    
    name: Optional[str] = None
    """
    Extension name. For user extension types the value is a combination of the specified first name
    and last name
    """
    

class GetExtensionPhoneNumbersResponseRecordsItemPaymentType(Enum):
    """
    Payment type. 'External' is returned for forwarded numbers which are not terminated in the
    RingCentral phone system
    
    Generated by Python OpenAPI Parser
    """
    
    External = 'External'
    TollFree = 'TollFree'
    Local = 'Local'
    BusinessMobileNumberProvider = 'BusinessMobileNumberProvider'

class GetExtensionPhoneNumbersResponseRecordsItemType(Enum):
    """ Phone number type """
    
    VoiceFax = 'VoiceFax'
    FaxOnly = 'FaxOnly'
    VoiceOnly = 'VoiceOnly'

class GetExtensionPhoneNumbersResponseRecordsItemUsageType(Enum):
    """
    Usage type of a phone number. Numbers of 'NumberPool' type wont't be returned for phone number
    list requests
    
    Generated by Python OpenAPI Parser
    """
    
    MainCompanyNumber = 'MainCompanyNumber'
    AdditionalCompanyNumber = 'AdditionalCompanyNumber'
    CompanyNumber = 'CompanyNumber'
    DirectNumber = 'DirectNumber'
    CompanyFaxNumber = 'CompanyFaxNumber'
    ForwardedNumber = 'ForwardedNumber'
    ForwardedCompanyNumber = 'ForwardedCompanyNumber'
    ContactCenterNumber = 'ContactCenterNumber'
    ConferencingNumber = 'ConferencingNumber'
    NumberPool = 'NumberPool'
    BusinessMobileNumber = 'BusinessMobileNumber'

class GetExtensionPhoneNumbersResponseRecordsItemFeaturesItem(Enum):
    CallerId = 'CallerId'
    SmsSender = 'SmsSender'
    A2PSmsSender = 'A2PSmsSender'
    MmsSender = 'MmsSender'
    InternationalSmsSender = 'InternationalSmsSender'
    Delegated = 'Delegated'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetExtensionPhoneNumbersResponseRecordsItem(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to the user's phone number resource """
    
    id: Optional[int] = None
    """ Internal identifier of a phone number """
    
    country: Optional[GetExtensionPhoneNumbersResponseRecordsItemCountry] = None
    """ Brief information on a phone number country """
    
    contact_center_provider: Optional[GetExtensionPhoneNumbersResponseRecordsItemContactCenterProvider] = None
    """
    CCRN (Contact Center Routing Number) provider. If not specified then the default value
    'InContact/North America' is used, its ID is '1'
    """
    
    extension: Optional[GetExtensionPhoneNumbersResponseRecordsItemExtension] = None
    """
    Information on the extension, to which the phone number is assigned. Returned only for the
    request of Account phone number list
    """
    
    label: Optional[str] = None
    """ Custom user name of a phone number, if any """
    
    location: Optional[str] = None
    """ Location (City, State). Filled for local US numbers """
    
    payment_type: Optional[GetExtensionPhoneNumbersResponseRecordsItemPaymentType] = None
    """
    Payment type. 'External' is returned for forwarded numbers which are not terminated in the
    RingCentral phone system
    """
    
    phone_number: Optional[str] = None
    """ Phone number """
    
    status: Optional[str] = None
    """
    Status of a phone number. If the value is 'Normal', the phone number is ready to be used.
    Otherwise it is an external number not yet ported to RingCentral
    """
    
    type: Optional[GetExtensionPhoneNumbersResponseRecordsItemType] = None
    """ Phone number type """
    
    usage_type: Optional[GetExtensionPhoneNumbersResponseRecordsItemUsageType] = None
    """
    Usage type of a phone number. Numbers of 'NumberPool' type wont't be returned for phone number
    list requests
    """
    
    features: Optional[List[GetExtensionPhoneNumbersResponseRecordsItemFeaturesItem]] = None
    """ List of features of a phone number """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetExtensionPhoneNumbersResponse(DataClassJsonMixin):
    """
    Required Properties:
     - navigation
     - paging
     - records
    
    Generated by Python OpenAPI Parser
    """
    
    records: List[GetExtensionPhoneNumbersResponseRecordsItem]
    """ List of phone numbers """
    
    navigation: dict
    """ Information on navigation """
    
    paging: dict
    """ Information on paging """
    
    uri: Optional[str] = None
    """ Link to the user's phone number list resource """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ExtensionCreationRequestContactBusinessAddress(DataClassJsonMixin):
    country: Optional[str] = None
    """ Country name of an extension user company """
    
    state: Optional[str] = None
    """ State/province name of an extension user company. Mandatory for the USA, UK and Canada """
    
    city: Optional[str] = None
    """ City name of an extension user company """
    
    street: Optional[str] = None
    """ Street address of an extension user company """
    
    zip: Optional[str] = None
    """ Zip code of an extension user company """
    

class ExtensionCreationRequestContactPronouncedNameType(Enum):
    """
    Voice name type. 'Default' - default extension name; first name and last name specified in user
    profile; 'TextToSpeech' - custom text; user name spelled the way it sounds and specified by
    user; 'Recorded' - custom audio, user name recorded in user's own voice (supported only for
    extension retrieval)
    
    Generated by Python OpenAPI Parser
    """
    
    Default = 'Default'
    TextToSpeech = 'TextToSpeech'
    Recorded = 'Recorded'

class ExtensionCreationRequestContactPronouncedNamePromptContentType(Enum):
    """ Content media type """
    
    AudioMpeg = 'audio/mpeg'
    AudioWav = 'audio/wav'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ExtensionCreationRequestContactPronouncedNamePrompt(DataClassJsonMixin):
    id: Optional[str] = None
    content_uri: Optional[str] = None
    """ Link to a prompt resource """
    
    content_type: Optional[ExtensionCreationRequestContactPronouncedNamePromptContentType] = None
    """ Content media type """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ExtensionCreationRequestContactPronouncedName(DataClassJsonMixin):
    type: Optional[ExtensionCreationRequestContactPronouncedNameType] = None
    """
    Voice name type. 'Default' - default extension name; first name and last name specified in user
    profile; 'TextToSpeech' - custom text; user name spelled the way it sounds and specified by
    user; 'Recorded' - custom audio, user name recorded in user's own voice (supported only for
    extension retrieval)
    """
    
    text: Optional[str] = None
    """ Custom text """
    
    prompt: Optional[ExtensionCreationRequestContactPronouncedNamePrompt] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ExtensionCreationRequestContact(DataClassJsonMixin):
    """ Contact Information """
    
    first_name: Optional[str] = None
    """ For User extension type only. Extension user first name """
    
    last_name: Optional[str] = None
    """ For User extension type only. Extension user last name """
    
    company: Optional[str] = None
    """ Extension user company name """
    
    job_title: Optional[str] = None
    email: Optional[str] = None
    """ Email of extension user """
    
    business_phone: Optional[str] = None
    """
    Extension user contact phone number in [E.164](https://www.itu.int/rec/T-REC-E.164-201011-I)
    format
    """
    
    mobile_phone: Optional[str] = None
    """
    Extension user mobile (**non** Toll Free) phone number in
    [E.164](https://www.itu.int/rec/T-REC-E.164-201011-I) (with '+' sign) format
    """
    
    business_address: Optional[ExtensionCreationRequestContactBusinessAddress] = None
    email_as_login_name: Optional[bool] = None
    """
    If 'True' then contact email is enabled as login name for this user. Please note that email
    should be unique in this case. The default value is 'False'
    """
    
    pronounced_name: Optional[ExtensionCreationRequestContactPronouncedName] = None
    department: Optional[str] = None
    """ Extension user department, if any """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ExtensionCreationRequestCustomFieldsItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a custom field """
    
    value: Optional[str] = None
    """ Custom field value """
    
    display_name: Optional[str] = None

class ExtensionCreationRequestReferencesItemType(Enum):
    """ Type of external identifier """
    
    PartnerId = 'PartnerId'
    CustomerDirectoryId = 'CustomerDirectoryId'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ExtensionCreationRequestReferencesItem(DataClassJsonMixin):
    ref: Optional[str] = None
    """ Non-RC identifier of an extension """
    
    type: Optional[ExtensionCreationRequestReferencesItemType] = None
    """ Type of external identifier """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ExtensionCreationRequestRegionalSettingsTimezone(DataClassJsonMixin):
    """ Extension timezone information """
    
    id: Optional[str] = None
    """ Internal identifier of a timezone """
    
    uri: Optional[str] = None
    """ Canonical URI of a timezone """
    
    name: Optional[str] = None
    """ Short name of a timezone """
    
    description: Optional[str] = None
    """ Meaningful description of the timezone """
    
    bias: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ExtensionCreationRequestRegionalSettingsLanguage(DataClassJsonMixin):
    """ User interface language data """
    
    id: Optional[str] = None
    """ Internal identifier of a language """
    
    uri: Optional[str] = None
    """ Canonical URI of a language """
    
    greeting: Optional[bool] = None
    """ Indicates whether a language is available as greeting language """
    
    formatting_locale: Optional[bool] = None
    """ Indicates whether a language is available as formatting locale """
    
    locale_code: Optional[str] = None
    """ Localization code of a language """
    
    iso_code: Optional[str] = None
    """
    Country code according to the ISO standard, see [ISO
    3166](https://www.iso.org/iso-3166-country-codes.html)
    """
    
    name: Optional[str] = None
    """ Official name of a language """
    
    ui: Optional[bool] = None
    """ Indicates whether a language is available as UI language """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ExtensionCreationRequestRegionalSettingsGreetingLanguage(DataClassJsonMixin):
    """ Information on language used for telephony greetings """
    
    id: Optional[str] = None
    """ Internal identifier of a greeting language """
    
    locale_code: Optional[str] = None
    """ Localization code of a greeting language """
    
    name: Optional[str] = None
    """ Official name of a greeting language """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ExtensionCreationRequestRegionalSettingsFormattingLocale(DataClassJsonMixin):
    """ Formatting language preferences for numbers, dates and currencies """
    
    id: Optional[str] = None
    """ Internal identifier of a formatting language """
    
    locale_code: Optional[str] = None
    """ Localization code of a formatting language """
    
    name: Optional[str] = None

class ExtensionCreationRequestRegionalSettingsTimeFormat(Enum):
    """ Time format setting. The default value is '12h' = ['12h', '24h'] """
    
    OBJECT_12h = '12h'
    OBJECT_24h = '24h'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ExtensionCreationRequestRegionalSettings(DataClassJsonMixin):
    """ Extension region data (timezone, home country, language) """
    
    home_country: Optional[dict] = None
    """ Extension country information """
    
    timezone: Optional[ExtensionCreationRequestRegionalSettingsTimezone] = None
    """ Extension timezone information """
    
    language: Optional[ExtensionCreationRequestRegionalSettingsLanguage] = None
    """ User interface language data """
    
    greeting_language: Optional[ExtensionCreationRequestRegionalSettingsGreetingLanguage] = None
    """ Information on language used for telephony greetings """
    
    formatting_locale: Optional[ExtensionCreationRequestRegionalSettingsFormattingLocale] = None
    """ Formatting language preferences for numbers, dates and currencies """
    
    time_format: Optional[ExtensionCreationRequestRegionalSettingsTimeFormat] = None
    """ Time format setting. The default value is '12h' = ['12h', '24h'] """
    
