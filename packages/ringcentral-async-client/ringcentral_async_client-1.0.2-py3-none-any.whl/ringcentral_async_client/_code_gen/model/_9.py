from ._8 import *

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListGlipPostsResponseNavigation(DataClassJsonMixin):
    prev_page_token: Optional[str] = None
    """
    Previous page token. To get previous page, user should pass one of returned token in next
    request and, in turn, required page will be returned with new tokens
    """
    
    next_page_token: Optional[str] = None
    """
    Next page token. To get next page, user should pass one of returned token in next request and,
    in turn, required page will be returned with new tokens
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListGlipPostsResponse(DataClassJsonMixin):
    """
    Required Properties:
     - records
    
    Generated by Python OpenAPI Parser
    """
    
    records: List[ListGlipPostsResponseRecordsItem]
    """ List of posts """
    
    navigation: Optional[ListGlipPostsResponseNavigation] = None

class CreatePostRequestAttachmentsItemType(Enum):
    """ Type of attachment """
    
    Card = 'Card'
    Event = 'Event'
    Note = 'Note'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreatePostRequestAttachmentsItemAuthor(DataClassJsonMixin):
    """ Information about the author """
    
    name: Optional[str] = None
    """ Name of a message author """
    
    uri: Optional[str] = None
    """ Link to an author's name """
    
    icon_uri: Optional[str] = None
    """ Link to an image displayed to the left of an author's name; sized 82x82px """
    

class CreatePostRequestAttachmentsItemFieldsItemStyle(Enum):
    """ Style of width span applied to a field """
    
    Short = 'Short'
    Long = 'Long'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreatePostRequestAttachmentsItemFieldsItem(DataClassJsonMixin):
    title: Optional[str] = None
    """ Title of an individual field """
    
    value: Optional[str] = None
    """ Value of an individual field (supports Markdown) """
    
    style: Optional[CreatePostRequestAttachmentsItemFieldsItemStyle] = 'Short'
    """ Style of width span applied to a field """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreatePostRequestAttachmentsItemFootnote(DataClassJsonMixin):
    """ Message footer information """
    
    text: Optional[str] = None
    """ Text of a footer """
    
    icon_uri: Optional[str] = None
    """ Link to an icon displayed to the left of a footer; sized 32x32px """
    
    time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Message creation datetime in ISO 8601 format including timezone, for example
    *2016-03-10T18:07:52.534Z*
    """
    

class CreatePostRequestAttachmentsItemRecurrence(Enum):
    """
    Event recurrence settings. For non-periodic events the value is 'None'. Must be greater or
    equal to event duration: 1- Day/Weekday; 7 - Week; 28 - Month; 365 - Year
    
    Generated by Python OpenAPI Parser
    """
    
    None_ = 'None'
    Day = 'Day'
    Weekday = 'Weekday'
    Week = 'Week'
    Month = 'Month'
    Year = 'Year'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreatePostRequestAttachmentsItem(DataClassJsonMixin):
    type: Optional[CreatePostRequestAttachmentsItemType] = 'Card'
    """ Type of attachment """
    
    title: Optional[str] = None
    """ Attachment title """
    
    fallback: Optional[str] = None
    """ Default message returned in case the client does not support interactive messages """
    
    color: Optional[str] = None
    """
    Color of Event title, including its presentation in Calendar; or the color of the side border
    of an interactive message of a Card. The default color is 'Black'
    """
    
    intro: Optional[str] = None
    """ Introductory text displayed directly above a message """
    
    author: Optional[CreatePostRequestAttachmentsItemAuthor] = None
    """ Information about the author """
    
    text: Optional[str] = None
    """ Text of attachment (up to 1000 chars), supports GlipDown """
    
    image_uri: Optional[str] = None
    """ Link to an image displayed at the bottom of a message """
    
    thumbnail_uri: Optional[str] = None
    """ Link to an image preview displayed to the right of a message (82x82) """
    
    fields: Optional[List[CreatePostRequestAttachmentsItemFieldsItem]] = None
    """ Individual subsections within a message """
    
    footnote: Optional[CreatePostRequestAttachmentsItemFootnote] = None
    """ Message footer information """
    
    start_time: Optional[str] = None
    """ Datetime of starting an event """
    
    end_time: Optional[str] = None
    """ Datetime of ending an event """
    
    all_day: Optional[bool] = False
    """ Indicates whether an event has some specific time slot or lasts for the whole day(s) """
    
    recurrence: Optional[CreatePostRequestAttachmentsItemRecurrence] = None
    """
    Event recurrence settings. For non-periodic events the value is 'None'. Must be greater or
    equal to event duration: 1- Day/Weekday; 7 - Week; 28 - Month; 365 - Year
    """
    
    ending_condition: Optional[str] = None
    """ Condition of ending an event """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreatePostRequest(DataClassJsonMixin):
    activity: Optional[str] = None
    title: Optional[str] = None
    """ Title of a message. (Can be set for bot's messages only). """
    
    text: Optional[str] = None
    """ Text of a post """
    
    group_id: Optional[str] = None
    """ Internal identifier of a group """
    
    attachments: Optional[List[CreatePostRequestAttachmentsItem]] = None
    """ List of attachments to be posted """
    
    person_ids: Optional[List[str]] = None
    system: Optional[bool] = None

class CreatePostResponseType(Enum):
    """ Type of a post """
    
    TextMessage = 'TextMessage'
    PersonJoined = 'PersonJoined'
    PersonsAdded = 'PersonsAdded'

class CreatePostResponseAttachmentsItemType(Enum):
    """ Type of an attachment """
    
    Card = 'Card'
    Event = 'Event'
    Note = 'Note'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreatePostResponseAttachmentsItemAuthor(DataClassJsonMixin):
    """ Information about the author """
    
    name: Optional[str] = None
    """ Name of a message author """
    
    uri: Optional[str] = None
    """ Link to an author's name """
    
    icon_uri: Optional[str] = None
    """ Link to an image displayed to the left of an author's name; sized 82x82px """
    

class CreatePostResponseAttachmentsItemFieldsItemStyle(Enum):
    """ Style of width span applied to a field """
    
    Short = 'Short'
    Long = 'Long'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreatePostResponseAttachmentsItemFieldsItem(DataClassJsonMixin):
    title: Optional[str] = None
    """ Title of an individual field """
    
    value: Optional[str] = None
    """ Value of an individual field (supports Markdown) """
    
    style: Optional[CreatePostResponseAttachmentsItemFieldsItemStyle] = 'Short'
    """ Style of width span applied to a field """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreatePostResponseAttachmentsItemFootnote(DataClassJsonMixin):
    """ Message Footer """
    
    text: Optional[str] = None
    """ Text of a footer """
    
    icon_uri: Optional[str] = None
    """ Link to an icon displayed to the left of a footer; sized 32x32px """
    
    time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Message creation datetime in ISO 8601 format including timezone, for example
    *2016-03-10T18:07:52.534Z*
    """
    

class CreatePostResponseAttachmentsItemRecurrence(Enum):
    """ Event recurrence settings. """
    
    None_ = 'None'
    Day = 'Day'
    Weekday = 'Weekday'
    Week = 'Week'
    Month = 'Month'
    Year = 'Year'

class CreatePostResponseAttachmentsItemEndingOn(Enum):
    """ Iterations end datetime for periodic events """
    
    None_ = 'None'
    Count = 'Count'
    Date = 'Date'

class CreatePostResponseAttachmentsItemColor(Enum):
    """
    Color of Event title, including its presentation in Calendar; or the color of the side border
    of an interactive message of a Card
    
    Generated by Python OpenAPI Parser
    """
    
    Black = 'Black'
    Red = 'Red'
    Orange = 'Orange'
    Yellow = 'Yellow'
    Green = 'Green'
    Blue = 'Blue'
    Purple = 'Purple'
    Magenta = 'Magenta'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreatePostResponseAttachmentsItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of an attachment """
    
    type: Optional[CreatePostResponseAttachmentsItemType] = 'Card'
    """ Type of an attachment """
    
    fallback: Optional[str] = None
    """
    A string of default text that will be rendered in the case that the client does not support
    Interactive Messages
    """
    
    intro: Optional[str] = None
    """ A pretext to the message """
    
    author: Optional[CreatePostResponseAttachmentsItemAuthor] = None
    """ Information about the author """
    
    title: Optional[str] = None
    """ Message title """
    
    text: Optional[str] = None
    """
    A large string field (up to 1000 chars) to be displayed as the body of a message (Supports
    GlipDown)
    """
    
    image_uri: Optional[str] = None
    """ Link to an image displayed at the bottom of a message """
    
    thumbnail_uri: Optional[str] = None
    """ Link to an image preview displayed to the right of a message (82x82) """
    
    fields: Optional[List[CreatePostResponseAttachmentsItemFieldsItem]] = None
    """ Information on navigation """
    
    footnote: Optional[CreatePostResponseAttachmentsItemFootnote] = None
    """ Message Footer """
    
    creator_id: Optional[str] = None
    """ Internal identifier of a person created an event """
    
    start_time: Optional[str] = None
    """ Datetime of starting an event """
    
    end_time: Optional[str] = None
    """ Datetime of ending an event """
    
    all_day: Optional[bool] = False
    """ Indicates whether an event has some specific time slot or lasts for the whole day(s) """
    
    recurrence: Optional[CreatePostResponseAttachmentsItemRecurrence] = None
    """ Event recurrence settings. """
    
    ending_condition: Optional[str] = None
    """ Condition of ending """
    
    ending_after: Optional[int] = None
    """ Count of iterations. For periodic events only """
    
    ending_on: Optional[CreatePostResponseAttachmentsItemEndingOn] = 'None'
    """ Iterations end datetime for periodic events """
    
    color: Optional[CreatePostResponseAttachmentsItemColor] = 'Black'
    """
    Color of Event title, including its presentation in Calendar; or the color of the side border
    of an interactive message of a Card
    """
    
    location: Optional[str] = None
    """ Event location """
    
    description: Optional[str] = None
    """ Event details """
    

class CreatePostResponseMentionsItemType(Enum):
    """ Type of mentions """
    
    Person = 'Person'
    Team = 'Team'
    File = 'File'
    Link = 'Link'
    Event = 'Event'
    Task = 'Task'
    Note = 'Note'
    Card = 'Card'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreatePostResponseMentionsItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a user """
    
    type: Optional[CreatePostResponseMentionsItemType] = None
    """ Type of mentions """
    
    name: Optional[str] = None
    """ Name of a user """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreatePostResponse(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a post """
    
    group_id: Optional[str] = None
    """ Internal identifier of a group a post belongs to """
    
    type: Optional[CreatePostResponseType] = None
    """ Type of a post """
    
    text: Optional[str] = None
    """ For 'TextMessage' post type only. Text of a message """
    
    creator_id: Optional[str] = None
    """ Internal identifier of a user - author of a post """
    
    added_person_ids: Optional[List[str]] = None
    """ For 'PersonsAdded' post type only. Identifiers of persons added to a group """
    
    creation_time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """ Post creation datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format """
    
    last_modified_time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """ Post last modification datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format """
    
    attachments: Optional[List[CreatePostResponseAttachmentsItem]] = None
    """ List of posted attachments """
    
    mentions: Optional[List[CreatePostResponseMentionsItem]] = None
    activity: Optional[str] = None
    """ Label of activity type """
    
    title: Optional[str] = None
    """ Title of a message. (Can be set for bot's messages only) """
    
    icon_uri: Optional[str] = None
    """ Link to an image used as an icon for this message """
    
    icon_emoji: Optional[str] = None
    """ Emoji used as an icon for this message """
    

class ReadUnifiedPresenceResponseStatus(Enum):
    """ Aggregated presence status of the user """
    
    Available = 'Available'
    Offline = 'Offline'
    DND = 'DND'
    Busy = 'Busy'

class ReadUnifiedPresenceResponseGlipStatus(Enum):
    """
    Glip connection status calculated from all user's apps. Returned always for the requester's
    extension; returned for another users if their glip visibility is set to 'Visible'
    
    Generated by Python OpenAPI Parser
    """
    
    Offline = 'Offline'
    Online = 'Online'

class ReadUnifiedPresenceResponseGlipVisibility(Enum):
    """
    Visibility setting allowing other users to see the user's Glip presence status; returned only
    for requester's extension
    
    Generated by Python OpenAPI Parser
    """
    
    Visible = 'Visible'
    Invisible = 'Invisible'

class ReadUnifiedPresenceResponseGlipAvailability(Enum):
    """ Shows whether user wants to receive Glip notifications or not. """
    
    Available = 'Available'
    DND = 'DND'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUnifiedPresenceResponseGlip(DataClassJsonMixin):
    """ Returned if *Glip* feature is switched on """
    
    status: Optional[ReadUnifiedPresenceResponseGlipStatus] = None
    """
    Glip connection status calculated from all user's apps. Returned always for the requester's
    extension; returned for another users if their glip visibility is set to 'Visible'
    """
    
    visibility: Optional[ReadUnifiedPresenceResponseGlipVisibility] = None
    """
    Visibility setting allowing other users to see the user's Glip presence status; returned only
    for requester's extension
    """
    
    availability: Optional[ReadUnifiedPresenceResponseGlipAvailability] = None
    """ Shows whether user wants to receive Glip notifications or not. """
    

class ReadUnifiedPresenceResponseTelephonyStatus(Enum):
    """
    Telephony status calculated from all user's phone numbers. Returned always for the requester's
    extension; returned for another users if their telephony visibility is set to 'Visible'
    
    Generated by Python OpenAPI Parser
    """
    
    NoCall = 'NoCall'
    Ringing = 'Ringing'
    CallConnected = 'CallConnected'
    OnHold = 'OnHold'
    ParkedCall = 'ParkedCall'

class ReadUnifiedPresenceResponseTelephonyVisibility(Enum):
    """
    Specifies if the user hardphone presence status is visible to other users; returned only for
    requester's extension
    
    Generated by Python OpenAPI Parser
    """
    
    Visible = 'Visible'
    Invisible = 'Invisible'

class ReadUnifiedPresenceResponseTelephonyAvailability(Enum):
    """ Telephony DND status. Returned if *DND* feature is switched on """
    
    TakeAllCalls = 'TakeAllCalls'
    DoNotAcceptAnyCalls = 'DoNotAcceptAnyCalls'
    DoNotAcceptQueueCalls = 'DoNotAcceptQueueCalls'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUnifiedPresenceResponseTelephony(DataClassJsonMixin):
    """ Returned if *BLF* feature is switched on """
    
    status: Optional[ReadUnifiedPresenceResponseTelephonyStatus] = None
    """
    Telephony status calculated from all user's phone numbers. Returned always for the requester's
    extension; returned for another users if their telephony visibility is set to 'Visible'
    """
    
    visibility: Optional[ReadUnifiedPresenceResponseTelephonyVisibility] = None
    """
    Specifies if the user hardphone presence status is visible to other users; returned only for
    requester's extension
    """
    
    availability: Optional[ReadUnifiedPresenceResponseTelephonyAvailability] = None
    """ Telephony DND status. Returned if *DND* feature is switched on """
    

class ReadUnifiedPresenceResponseMeetingStatus(Enum):
    """ Meeting status calculated from all user`s meetings """
    
    NoMeeting = 'NoMeeting'
    InMeeting = 'InMeeting'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUnifiedPresenceResponseMeeting(DataClassJsonMixin):
    """ Returned if *Meetings* feature is switched on """
    
    status: Optional[ReadUnifiedPresenceResponseMeetingStatus] = None
    """ Meeting status calculated from all user`s meetings """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUnifiedPresenceResponse(DataClassJsonMixin):
    status: Optional[ReadUnifiedPresenceResponseStatus] = None
    """ Aggregated presence status of the user """
    
    glip: Optional[ReadUnifiedPresenceResponseGlip] = None
    """ Returned if *Glip* feature is switched on """
    
    telephony: Optional[ReadUnifiedPresenceResponseTelephony] = None
    """ Returned if *BLF* feature is switched on """
    
    meeting: Optional[ReadUnifiedPresenceResponseMeeting] = None
    """ Returned if *Meetings* feature is switched on """
    

class ReadUnifiedPresenceResponseBodyStatus(Enum):
    """ Aggregated presence status of the user """
    
    Available = 'Available'
    Offline = 'Offline'
    DND = 'DND'
    Busy = 'Busy'

class ReadUnifiedPresenceResponseBodyGlipStatus(Enum):
    """
    Glip connection status calculated from all user's apps. Returned always for the requester's
    extension; returned for another users if their glip visibility is set to 'Visible'
    
    Generated by Python OpenAPI Parser
    """
    
    Offline = 'Offline'
    Online = 'Online'

class ReadUnifiedPresenceResponseBodyGlipVisibility(Enum):
    """
    Visibility setting allowing other users to see the user's Glip presence status; returned only
    for requester's extension
    
    Generated by Python OpenAPI Parser
    """
    
    Visible = 'Visible'
    Invisible = 'Invisible'

class ReadUnifiedPresenceResponseBodyGlipAvailability(Enum):
    """ Shows whether user wants to receive Glip notifications or not. """
    
    Available = 'Available'
    DND = 'DND'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUnifiedPresenceResponseBodyGlip(DataClassJsonMixin):
    """ Returned if *Glip* feature is switched on """
    
    status: Optional[ReadUnifiedPresenceResponseBodyGlipStatus] = None
    """
    Glip connection status calculated from all user's apps. Returned always for the requester's
    extension; returned for another users if their glip visibility is set to 'Visible'
    """
    
    visibility: Optional[ReadUnifiedPresenceResponseBodyGlipVisibility] = None
    """
    Visibility setting allowing other users to see the user's Glip presence status; returned only
    for requester's extension
    """
    
    availability: Optional[ReadUnifiedPresenceResponseBodyGlipAvailability] = None
    """ Shows whether user wants to receive Glip notifications or not. """
    

class ReadUnifiedPresenceResponseBodyTelephonyStatus(Enum):
    """
    Telephony status calculated from all user's phone numbers. Returned always for the requester's
    extension; returned for another users if their telephony visibility is set to 'Visible'
    
    Generated by Python OpenAPI Parser
    """
    
    NoCall = 'NoCall'
    Ringing = 'Ringing'
    CallConnected = 'CallConnected'
    OnHold = 'OnHold'
    ParkedCall = 'ParkedCall'

class ReadUnifiedPresenceResponseBodyTelephonyVisibility(Enum):
    """
    Specifies if the user hardphone presence status is visible to other users; returned only for
    requester's extension
    
    Generated by Python OpenAPI Parser
    """
    
    Visible = 'Visible'
    Invisible = 'Invisible'

class ReadUnifiedPresenceResponseBodyTelephonyAvailability(Enum):
    """ Telephony DND status. Returned if *DND* feature is switched on """
    
    TakeAllCalls = 'TakeAllCalls'
    DoNotAcceptAnyCalls = 'DoNotAcceptAnyCalls'
    DoNotAcceptQueueCalls = 'DoNotAcceptQueueCalls'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUnifiedPresenceResponseBodyTelephony(DataClassJsonMixin):
    """ Returned if *BLF* feature is switched on """
    
    status: Optional[ReadUnifiedPresenceResponseBodyTelephonyStatus] = None
    """
    Telephony status calculated from all user's phone numbers. Returned always for the requester's
    extension; returned for another users if their telephony visibility is set to 'Visible'
    """
    
    visibility: Optional[ReadUnifiedPresenceResponseBodyTelephonyVisibility] = None
    """
    Specifies if the user hardphone presence status is visible to other users; returned only for
    requester's extension
    """
    
    availability: Optional[ReadUnifiedPresenceResponseBodyTelephonyAvailability] = None
    """ Telephony DND status. Returned if *DND* feature is switched on """
    

class ReadUnifiedPresenceResponseBodyMeetingStatus(Enum):
    """ Meeting status calculated from all user`s meetings """
    
    NoMeeting = 'NoMeeting'
    InMeeting = 'InMeeting'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUnifiedPresenceResponseBodyMeeting(DataClassJsonMixin):
    """ Returned if *Meetings* feature is switched on """
    
    status: Optional[ReadUnifiedPresenceResponseBodyMeetingStatus] = None
    """ Meeting status calculated from all user`s meetings """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUnifiedPresenceResponseBody(DataClassJsonMixin):
    status: Optional[ReadUnifiedPresenceResponseBodyStatus] = None
    """ Aggregated presence status of the user """
    
    glip: Optional[ReadUnifiedPresenceResponseBodyGlip] = None
    """ Returned if *Glip* feature is switched on """
    
    telephony: Optional[ReadUnifiedPresenceResponseBodyTelephony] = None
    """ Returned if *BLF* feature is switched on """
    
    meeting: Optional[ReadUnifiedPresenceResponseBodyMeeting] = None
    """ Returned if *Meetings* feature is switched on """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUnifiedPresenceResponse(DataClassJsonMixin):
    resource_id: Optional[str] = None
    """ Internal identifier of the resource """
    
    status: Optional[int] = None
    """ Status code of resource retrieval """
    
    body: Optional[ReadUnifiedPresenceResponseBody] = None

class UpdateUnifiedPresenceRequestGlipVisibility(Enum):
    """ Visibility setting allowing other users to see Glip presence status """
    
    Visible = 'Visible'
    Invisible = 'Invisible'

class UpdateUnifiedPresenceRequestGlipAvailability(Enum):
    """ Availability setting specifing whether to receive Glip notifications or not """
    
    Available = 'Available'
    DND = 'DND'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUnifiedPresenceRequestGlip(DataClassJsonMixin):
    visibility: Optional[UpdateUnifiedPresenceRequestGlipVisibility] = None
    """ Visibility setting allowing other users to see Glip presence status """
    
    availability: Optional[UpdateUnifiedPresenceRequestGlipAvailability] = None
    """ Availability setting specifing whether to receive Glip notifications or not """
    

class UpdateUnifiedPresenceRequestTelephonyAvailability(Enum):
    """ Telephony DND status """
    
    TakeAllCalls = 'TakeAllCalls'
    DoNotAcceptAnyCalls = 'DoNotAcceptAnyCalls'
    DoNotAcceptQueueCalls = 'DoNotAcceptQueueCalls'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUnifiedPresenceRequestTelephony(DataClassJsonMixin):
    availability: Optional[UpdateUnifiedPresenceRequestTelephonyAvailability] = None
    """ Telephony DND status """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUnifiedPresenceRequest(DataClassJsonMixin):
    glip: Optional[UpdateUnifiedPresenceRequestGlip] = None
    telephony: Optional[UpdateUnifiedPresenceRequestTelephony] = None

class UpdateUnifiedPresenceResponseStatus(Enum):
    """ Aggregated presence status of the user """
    
    Available = 'Available'
    Offline = 'Offline'
    DND = 'DND'
    Busy = 'Busy'

class UpdateUnifiedPresenceResponseGlipStatus(Enum):
    """
    Glip connection status calculated from all user's apps. Returned always for the requester's
    extension; returned for another users if their glip visibility is set to 'Visible'
    
    Generated by Python OpenAPI Parser
    """
    
    Offline = 'Offline'
    Online = 'Online'

class UpdateUnifiedPresenceResponseGlipVisibility(Enum):
    """
    Visibility setting allowing other users to see the user's Glip presence status; returned only
    for requester's extension
    
    Generated by Python OpenAPI Parser
    """
    
    Visible = 'Visible'
    Invisible = 'Invisible'

class UpdateUnifiedPresenceResponseGlipAvailability(Enum):
    """ Shows whether user wants to receive Glip notifications or not. """
    
    Available = 'Available'
    DND = 'DND'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUnifiedPresenceResponseGlip(DataClassJsonMixin):
    """ Returned if *Glip* feature is switched on """
    
    status: Optional[UpdateUnifiedPresenceResponseGlipStatus] = None
    """
    Glip connection status calculated from all user's apps. Returned always for the requester's
    extension; returned for another users if their glip visibility is set to 'Visible'
    """
    
    visibility: Optional[UpdateUnifiedPresenceResponseGlipVisibility] = None
    """
    Visibility setting allowing other users to see the user's Glip presence status; returned only
    for requester's extension
    """
    
    availability: Optional[UpdateUnifiedPresenceResponseGlipAvailability] = None
    """ Shows whether user wants to receive Glip notifications or not. """
    

class UpdateUnifiedPresenceResponseTelephonyStatus(Enum):
    """
    Telephony status calculated from all user's phone numbers. Returned always for the requester's
    extension; returned for another users if their telephony visibility is set to 'Visible'
    
    Generated by Python OpenAPI Parser
    """
    
    NoCall = 'NoCall'
    Ringing = 'Ringing'
    CallConnected = 'CallConnected'
    OnHold = 'OnHold'
    ParkedCall = 'ParkedCall'

class UpdateUnifiedPresenceResponseTelephonyVisibility(Enum):
    """
    Specifies if the user hardphone presence status is visible to other users; returned only for
    requester's extension
    
    Generated by Python OpenAPI Parser
    """
    
    Visible = 'Visible'
    Invisible = 'Invisible'

class UpdateUnifiedPresenceResponseTelephonyAvailability(Enum):
    """ Telephony DND status. Returned if *DND* feature is switched on """
    
    TakeAllCalls = 'TakeAllCalls'
    DoNotAcceptAnyCalls = 'DoNotAcceptAnyCalls'
    DoNotAcceptQueueCalls = 'DoNotAcceptQueueCalls'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUnifiedPresenceResponseTelephony(DataClassJsonMixin):
    """ Returned if *BLF* feature is switched on """
    
    status: Optional[UpdateUnifiedPresenceResponseTelephonyStatus] = None
    """
    Telephony status calculated from all user's phone numbers. Returned always for the requester's
    extension; returned for another users if their telephony visibility is set to 'Visible'
    """
    
    visibility: Optional[UpdateUnifiedPresenceResponseTelephonyVisibility] = None
    """
    Specifies if the user hardphone presence status is visible to other users; returned only for
    requester's extension
    """
    
    availability: Optional[UpdateUnifiedPresenceResponseTelephonyAvailability] = None
    """ Telephony DND status. Returned if *DND* feature is switched on """
    

class UpdateUnifiedPresenceResponseMeetingStatus(Enum):
    """ Meeting status calculated from all user`s meetings """
    
    NoMeeting = 'NoMeeting'
    InMeeting = 'InMeeting'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUnifiedPresenceResponseMeeting(DataClassJsonMixin):
    """ Returned if *Meetings* feature is switched on """
    
    status: Optional[UpdateUnifiedPresenceResponseMeetingStatus] = None
    """ Meeting status calculated from all user`s meetings """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUnifiedPresenceResponse(DataClassJsonMixin):
    status: Optional[UpdateUnifiedPresenceResponseStatus] = None
    """ Aggregated presence status of the user """
    
    glip: Optional[UpdateUnifiedPresenceResponseGlip] = None
    """ Returned if *Glip* feature is switched on """
    
    telephony: Optional[UpdateUnifiedPresenceResponseTelephony] = None
    """ Returned if *BLF* feature is switched on """
    
    meeting: Optional[UpdateUnifiedPresenceResponseMeeting] = None
    """ Returned if *Meetings* feature is switched on """
    

class ListMeetingsResponseRecordsItemMeetingType(Enum):
    Instant = 'Instant'
    Scheduled = 'Scheduled'
    ScheduledRecurring = 'ScheduledRecurring'
    Recurring = 'Recurring'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListMeetingsResponseRecordsItemLinks(DataClassJsonMixin):
    start_uri: Optional[str] = None
    join_uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListMeetingsResponseRecordsItemScheduleTimeZone(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListMeetingsResponseRecordsItemSchedule(DataClassJsonMixin):
    start_time: Optional[str] = None
    duration_in_minutes: Optional[int] = None
    time_zone: Optional[ListMeetingsResponseRecordsItemScheduleTimeZone] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListMeetingsResponseRecordsItemHost(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to the meeting host resource """
    
    id: Optional[str] = None
    """
    Internal identifier of an extension which is assigned to be a meeting host. The default value
    is currently logged-in extension identifier
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListMeetingsResponseRecordsItemOccurrencesItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Identifier of a meeting occurrence """
    
    start_time: Optional[str] = None
    """ Starting time of a meeting occurrence """
    
    duration_in_minutes: Optional[int] = None
    """ Duration of a meeting occurrence """
    
    status: Optional[str] = None
    """ Status of a meeting occurrence """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListMeetingsResponseRecordsItem(DataClassJsonMixin):
    uri: Optional[str] = None
    uuid: Optional[str] = None
    id: Optional[str] = None
    topic: Optional[str] = None
    meeting_type: Optional[ListMeetingsResponseRecordsItemMeetingType] = None
    password: Optional[str] = None
    h323_password: Optional[str] = None
    status: Optional[str] = None
    links: Optional[ListMeetingsResponseRecordsItemLinks] = None
    schedule: Optional[ListMeetingsResponseRecordsItemSchedule] = None
    host: Optional[ListMeetingsResponseRecordsItemHost] = None
    allow_join_before_host: Optional[bool] = False
    start_host_video: Optional[bool] = False
    start_participants_video: Optional[bool] = False
    audio_options: Optional[List[str]] = None
    occurrences: Optional[List[ListMeetingsResponseRecordsItemOccurrencesItem]] = None
    """ List of meeting occurrences """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListMeetingsResponsePaging(DataClassJsonMixin):
    page: Optional[int] = None
    total_pages: Optional[int] = None
    per_page: Optional[int] = None
    total_elements: Optional[int] = None
    page_start: Optional[int] = None
    page_end: Optional[int] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListMeetingsResponseNavigationNextPage(DataClassJsonMixin):
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListMeetingsResponseNavigationPreviousPage(DataClassJsonMixin):
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListMeetingsResponseNavigationFirstPage(DataClassJsonMixin):
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListMeetingsResponseNavigationLastPage(DataClassJsonMixin):
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListMeetingsResponseNavigation(DataClassJsonMixin):
    next_page: Optional[ListMeetingsResponseNavigationNextPage] = None
    previous_page: Optional[ListMeetingsResponseNavigationPreviousPage] = None
    first_page: Optional[ListMeetingsResponseNavigationFirstPage] = None
    last_page: Optional[ListMeetingsResponseNavigationLastPage] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListMeetingsResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    records: Optional[List[ListMeetingsResponseRecordsItem]] = None
    paging: Optional[ListMeetingsResponsePaging] = None
    navigation: Optional[ListMeetingsResponseNavigation] = None

class CreateMeetingRequestMeetingType(Enum):
    Instant = 'Instant'
    Scheduled = 'Scheduled'
    ScheduledRecurring = 'ScheduledRecurring'
    Recurring = 'Recurring'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateMeetingRequestScheduleTimeZone(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateMeetingRequestSchedule(DataClassJsonMixin):
    start_time: Optional[str] = None
    duration_in_minutes: Optional[int] = None
    time_zone: Optional[CreateMeetingRequestScheduleTimeZone] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateMeetingRequestHost(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to the meeting host resource """
    
    id: Optional[str] = None
    """
    Internal identifier of an extension which is assigned to be a meeting host. The default value
    is currently logged-in extension identifier
    """
    

class CreateMeetingRequestRecurrenceFrequency(Enum):
    """ Recurrence time frame """
    
    Daily = 'Daily'
    Weekly = 'Weekly'
    Monthly = 'Monthly'

class CreateMeetingRequestRecurrenceMonthlyByWeek(Enum):
    """ Supported together with `weeklyByDay` """
    
    Last = 'Last'
    First = 'First'
    Second = 'Second'
    Third = 'Third'
    Fourth = 'Fourth'

class CreateMeetingRequestRecurrenceWeeklyByDay(Enum):
    Sunday = 'Sunday'
    Monday = 'Monday'
    Tuesday = 'Tuesday'
    Wednesday = 'Wednesday'
    Thursday = 'Thursday'
    Friday = 'Friday'
    Saturday = 'Saturday'

class CreateMeetingRequestRecurrenceWeeklyByDays(Enum):
    """ Multiple values are supported, should be specified separated by comma """
    
    Sunday = 'Sunday'
    Monday = 'Monday'
    Tuesday = 'Tuesday'
    Wednesday = 'Wednesday'
    Thursday = 'Thursday'
    Friday = 'Friday'
    Saturday = 'Saturday'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateMeetingRequestRecurrence(DataClassJsonMixin):
    """ Recurrence settings """
    
    frequency: Optional[CreateMeetingRequestRecurrenceFrequency] = None
    """ Recurrence time frame """
    
    interval: Optional[int] = None
    """
    Reccurence interval. The supported ranges are: 1-90 for `Daily`; 1-12 for `Weekly`; 1-3 for
    `Monthly`
    """
    
    monthly_by_week: Optional[CreateMeetingRequestRecurrenceMonthlyByWeek] = None
    """ Supported together with `weeklyByDay` """
    
    weekly_by_day: Optional[CreateMeetingRequestRecurrenceWeeklyByDay] = None
    weekly_by_days: Optional[CreateMeetingRequestRecurrenceWeeklyByDays] = None
    """ Multiple values are supported, should be specified separated by comma """
    
    monthly_by_day: Optional[int] = None
    """ The supported range is 1-31 """
    
    count: Optional[int] = None
    """ Number of occurences """
    
    until: Optional[str] = None
    """ Meeting expiration datetime """
    

class CreateMeetingRequestAutoRecordType(Enum):
    """ Automatic record type """
    
    Local = 'local'
    Cloud = 'cloud'
    None_ = 'none'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateMeetingRequest(DataClassJsonMixin):
    topic: Optional[str] = None
    meeting_type: Optional[CreateMeetingRequestMeetingType] = None
    schedule: Optional[CreateMeetingRequestSchedule] = None
    password: Optional[str] = None
    host: Optional[CreateMeetingRequestHost] = None
    allow_join_before_host: Optional[bool] = False
    start_host_video: Optional[bool] = False
    start_participants_video: Optional[bool] = False
    use_personal_meeting_id: Optional[bool] = None
    audio_options: Optional[List[str]] = None
    recurrence: Optional[CreateMeetingRequestRecurrence] = None
    """ Recurrence settings """
    
    auto_record_type: Optional[CreateMeetingRequestAutoRecordType] = 'local'
    """ Automatic record type """
    

class CreateMeetingResponseMeetingType(Enum):
    Instant = 'Instant'
    Scheduled = 'Scheduled'
    ScheduledRecurring = 'ScheduledRecurring'
    Recurring = 'Recurring'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateMeetingResponseLinks(DataClassJsonMixin):
    start_uri: Optional[str] = None
    join_uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateMeetingResponseScheduleTimeZone(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateMeetingResponseSchedule(DataClassJsonMixin):
    start_time: Optional[str] = None
    duration_in_minutes: Optional[int] = None
    time_zone: Optional[CreateMeetingResponseScheduleTimeZone] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateMeetingResponseHost(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to the meeting host resource """
    
    id: Optional[str] = None
    """
    Internal identifier of an extension which is assigned to be a meeting host. The default value
    is currently logged-in extension identifier
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateMeetingResponseOccurrencesItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Identifier of a meeting occurrence """
    
    start_time: Optional[str] = None
    """ Starting time of a meeting occurrence """
    
    duration_in_minutes: Optional[int] = None
    """ Duration of a meeting occurrence """
    
    status: Optional[str] = None
    """ Status of a meeting occurrence """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateMeetingResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    uuid: Optional[str] = None
    id: Optional[str] = None
    topic: Optional[str] = None
    meeting_type: Optional[CreateMeetingResponseMeetingType] = None
    password: Optional[str] = None
    h323_password: Optional[str] = None
    status: Optional[str] = None
    links: Optional[CreateMeetingResponseLinks] = None
    schedule: Optional[CreateMeetingResponseSchedule] = None
    host: Optional[CreateMeetingResponseHost] = None
    allow_join_before_host: Optional[bool] = False
    start_host_video: Optional[bool] = False
    start_participants_video: Optional[bool] = False
    audio_options: Optional[List[str]] = None
    occurrences: Optional[List[CreateMeetingResponseOccurrencesItem]] = None
    """ List of meeting occurrences """
    

class GetUserSettingResponseRecordingAutoRecording(Enum):
    """ Automatical recording (local/cloud/none) of meetings as they start """
    
    Local = 'local'
    Cloud = 'cloud'
    None_ = 'none'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetUserSettingResponseRecording(DataClassJsonMixin):
    local_recording: Optional[bool] = None
    """ Allows hosts and participants to record a meeting to a local file """
    
    cloud_recording: Optional[bool] = None
    """ Allows hosts to record and save a meeting/webinar in the cloud """
    
    record_speaker_view: Optional[bool] = False
    """ Allows to record active speaker with the shared screen """
    
    record_gallery_view: Optional[bool] = False
    """ Allows to record gallery view with the shared screen """
    
    record_audio_file: Optional[bool] = False
    """ Allows to record an audio-only file """
    
    save_chat_text: Optional[bool] = False
    """ Allows to save chat text from a meeting """
    
    show_timestamp: Optional[bool] = False
    """ Allows to show timestamp on video """
    
    auto_recording: Optional[GetUserSettingResponseRecordingAutoRecording] = 'local'
    """ Automatical recording (local/cloud/none) of meetings as they start """
    
    auto_delete_cmr: Optional[str] = False
    """ Automatical deletion of cloud recordings """
    
    auto_delete_cmr_days: Optional[int] = None
    """
    A specified number of days for automatical deletion of cloud recordings, the value range is
    1-60
    """
    

class GetUserSettingResponseScheduleMeetingAudioOptionsItem(Enum):
    Phone = 'Phone'
    ComputerAudio = 'ComputerAudio'

class GetUserSettingResponseScheduleMeetingRequirePasswordForPmiMeetings(Enum):
    """
    Specifies whether to require a password for meetings using Personal Meeting ID (PMI). The
    supported values are: 'none', 'all' and 'jbhOnly' (joined before host only)
    
    Generated by Python OpenAPI Parser
    """
    
    All = 'all'
    None_ = 'none'
    JbhOnly = 'jbhOnly'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetUserSettingResponseScheduleMeeting(DataClassJsonMixin):
    """ Settings defining how to schedule user meetings """
    
    start_host_video: Optional[bool] = None
    """ Starting meetings with host video on/off (true/false) """
    
    start_participants_video: Optional[bool] = None
    """ Starting meetings with participant video on/off (true/false) """
    
    audio_options: Optional[List[GetUserSettingResponseScheduleMeetingAudioOptionsItem]] = None
    """ Determines how participants can join the audio channel of a meeting """
    
    allow_join_before_host: Optional[bool] = None
    """ Allows participants to join the meeting before the host arrives """
    
    use_pmi_for_scheduled_meetings: Optional[bool] = None
    """ Determines whether to use Personal Meeting ID (PMI) when scheduling a meeting """
    
    use_pmi_for_instant_meetings: Optional[bool] = None
    """ Determines whether to use Personal Meeting ID (PMI) when starting an instant meeting """
    
    require_password_for_scheduling_new_meetings: Optional[bool] = None
    """
    A password will be generated when scheduling a meeting and participants will require password
    to join a meeting. The Personal Meeting ID (PMI) meetings are not included
    """
    
    require_password_for_scheduled_meetings: Optional[bool] = None
    """ Specifies whether to require a password for meetings which have already been scheduled """
    
    default_password_for_scheduled_meetings: Optional[str] = None
    """ Password for already scheduled meetings. Users can set it individually """
    
    require_password_for_instant_meetings: Optional[bool] = None
    """
    A random password will be generated for an instant meeting, if set to 'True'. If you use PMI
    for your instant meetings, this option will be disabled
    """
    
    require_password_for_pmi_meetings: Optional[GetUserSettingResponseScheduleMeetingRequirePasswordForPmiMeetings] = None
    """
    Specifies whether to require a password for meetings using Personal Meeting ID (PMI). The
    supported values are: 'none', 'all' and 'jbhOnly' (joined before host only)
    """
    
    pmi_password: Optional[str] = None
    """ The default password for Personal Meeting ID (PMI) meetings """
    
    pstn_password_protected: Optional[bool] = None
    """ Specifies whether to generate and require a password for participants joining by phone """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetUserSettingResponse(DataClassJsonMixin):
    recording: Optional[GetUserSettingResponseRecording] = None
    schedule_meeting: Optional[GetUserSettingResponseScheduleMeeting] = None
    """ Settings defining how to schedule user meetings """
    

class GetAccountLockedSettingResponseScheduleMeetingAudioOptionsItem(Enum):
    Phone = 'Phone'
    ComputerAudio = 'ComputerAudio'

class GetAccountLockedSettingResponseScheduleMeetingRequirePasswordForPmiMeetings(Enum):
    """
    Specifies whether to require a password for meetings using Personal Meeting ID (PMI). The
    supported values are: 'none', 'all' and 'jbhOnly' (joined before host only)
    
    Generated by Python OpenAPI Parser
    """
    
    All = 'all'
    None_ = 'none'
    JbhOnly = 'jbhOnly'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetAccountLockedSettingResponseScheduleMeeting(DataClassJsonMixin):
    """ Scheduling meeting settings locked on account level """
    
    start_host_video: Optional[bool] = None
    """ Starting meetings with host video on/off (true/false) """
    
    start_participants_video: Optional[bool] = None
    """ Starting meetings with participant video on/off (true/false) """
    
    audio_options: Optional[List[GetAccountLockedSettingResponseScheduleMeetingAudioOptionsItem]] = None
    """ Determines how participants can join the audio channel of a meeting """
    
    allow_join_before_host: Optional[bool] = None
    """ Allows participants to join the meeting before the host arrives """
    
    use_pmi_for_scheduled_meetings: Optional[bool] = None
    """ Determines whether to use Personal Meeting ID (PMI) when scheduling a meeting """
    
    use_pmi_for_instant_meetings: Optional[bool] = None
    """ Determines whether to use Personal Meeting ID (PMI) when starting an instant meeting """
    
    require_password_for_scheduling_new_meetings: Optional[bool] = None
    """
    A password will be generated when scheduling a meeting and participants will require password
    to join a meeting. The Personal Meeting ID (PMI) meetings are not included
    """
    
    require_password_for_scheduled_meetings: Optional[bool] = None
    """ Specifies whether to require a password for meetings which have already been scheduled """
    
    default_password_for_scheduled_meetings: Optional[str] = None
    """ Password for already scheduled meetings. Users can set it individually """
    
    require_password_for_instant_meetings: Optional[bool] = None
    """
    A random password will be generated for an instant meeting, if set to 'True'. If you use PMI
    for your instant meetings, this option will be disabled
    """
    
    require_password_for_pmi_meetings: Optional[GetAccountLockedSettingResponseScheduleMeetingRequirePasswordForPmiMeetings] = None
    """
    Specifies whether to require a password for meetings using Personal Meeting ID (PMI). The
    supported values are: 'none', 'all' and 'jbhOnly' (joined before host only)
    """
    
    pmi_password: Optional[str] = None
    """ The default password for Personal Meeting ID (PMI) meetings """
    
    pstn_password_protected: Optional[bool] = None
    """ Specifies whether to generate and require a password for participants joining by phone """
    

class GetAccountLockedSettingResponseRecordingAutoRecording(Enum):
    """ Automatical recording (local/cloud/none) of meetings as they start """
    
    Local = 'local'
    Cloud = 'cloud'
    None_ = 'none'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetAccountLockedSettingResponseRecording(DataClassJsonMixin):
    """ Meeting recording settings locked on account level """
    
    local_recording: Optional[bool] = None
    """ Allows hosts and participants to record a meeting to a local file """
    
    cloud_recording: Optional[bool] = None
    """ Allows hosts to record and save a meeting/webinar in the cloud """
    
    record_speaker_view: Optional[bool] = False
    """ Allows to record active speaker with the shared screen """
    
    record_gallery_view: Optional[bool] = False
    """ Allows to record gallery view with the shared screen """
    
    record_audio_file: Optional[bool] = False
    """ Allows to record an audio-only file """
    
    save_chat_text: Optional[bool] = False
    """ Allows to save chat text from a meeting """
    
    show_timestamp: Optional[bool] = False
    """ Allows to show timestamp on video """
    
    auto_recording: Optional[GetAccountLockedSettingResponseRecordingAutoRecording] = 'local'
    """ Automatical recording (local/cloud/none) of meetings as they start """
    
    auto_delete_cmr: Optional[str] = False
    """ Automatical deletion of cloud recordings """
    
    auto_delete_cmr_days: Optional[int] = None
    """
    A specified number of days for automatical deletion of cloud recordings, the value range is
    1-60
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class GetAccountLockedSettingResponse(DataClassJsonMixin):
    schedule_meeting: Optional[GetAccountLockedSettingResponseScheduleMeeting] = None
    """ Scheduling meeting settings locked on account level """
    
    recording: Optional[GetAccountLockedSettingResponseRecording] = None
    """ Meeting recording settings locked on account level """
    

class ReadMeetingResponseMeetingType(Enum):
    Instant = 'Instant'
    Scheduled = 'Scheduled'
    ScheduledRecurring = 'ScheduledRecurring'
    Recurring = 'Recurring'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadMeetingResponseLinks(DataClassJsonMixin):
    start_uri: Optional[str] = None
    join_uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadMeetingResponseScheduleTimeZone(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadMeetingResponseSchedule(DataClassJsonMixin):
    start_time: Optional[str] = None
    duration_in_minutes: Optional[int] = None
    time_zone: Optional[ReadMeetingResponseScheduleTimeZone] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadMeetingResponseHost(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to the meeting host resource """
    
    id: Optional[str] = None
    """
    Internal identifier of an extension which is assigned to be a meeting host. The default value
    is currently logged-in extension identifier
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadMeetingResponseOccurrencesItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Identifier of a meeting occurrence """
    
    start_time: Optional[str] = None
    """ Starting time of a meeting occurrence """
    
    duration_in_minutes: Optional[int] = None
    """ Duration of a meeting occurrence """
    
    status: Optional[str] = None
    """ Status of a meeting occurrence """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadMeetingResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    uuid: Optional[str] = None
    id: Optional[str] = None
    topic: Optional[str] = None
    meeting_type: Optional[ReadMeetingResponseMeetingType] = None
    password: Optional[str] = None
    h323_password: Optional[str] = None
    status: Optional[str] = None
    links: Optional[ReadMeetingResponseLinks] = None
    schedule: Optional[ReadMeetingResponseSchedule] = None
    host: Optional[ReadMeetingResponseHost] = None
    allow_join_before_host: Optional[bool] = False
    start_host_video: Optional[bool] = False
    start_participants_video: Optional[bool] = False
    audio_options: Optional[List[str]] = None
    occurrences: Optional[List[ReadMeetingResponseOccurrencesItem]] = None
    """ List of meeting occurrences """
    

class UpdateMeetingResponseMeetingType(Enum):
    Instant = 'Instant'
    Scheduled = 'Scheduled'
    ScheduledRecurring = 'ScheduledRecurring'
    Recurring = 'Recurring'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateMeetingResponseLinks(DataClassJsonMixin):
    start_uri: Optional[str] = None
    join_uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateMeetingResponseScheduleTimeZone(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateMeetingResponseSchedule(DataClassJsonMixin):
    start_time: Optional[str] = None
    duration_in_minutes: Optional[int] = None
    time_zone: Optional[UpdateMeetingResponseScheduleTimeZone] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateMeetingResponseHost(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to the meeting host resource """
    
    id: Optional[str] = None
    """
    Internal identifier of an extension which is assigned to be a meeting host. The default value
    is currently logged-in extension identifier
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateMeetingResponseOccurrencesItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Identifier of a meeting occurrence """
    
    start_time: Optional[str] = None
    """ Starting time of a meeting occurrence """
    
    duration_in_minutes: Optional[int] = None
    """ Duration of a meeting occurrence """
    
    status: Optional[str] = None
    """ Status of a meeting occurrence """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateMeetingResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    uuid: Optional[str] = None
    id: Optional[str] = None
    topic: Optional[str] = None
    meeting_type: Optional[UpdateMeetingResponseMeetingType] = None
    password: Optional[str] = None
    h323_password: Optional[str] = None
    status: Optional[str] = None
    links: Optional[UpdateMeetingResponseLinks] = None
    schedule: Optional[UpdateMeetingResponseSchedule] = None
    host: Optional[UpdateMeetingResponseHost] = None
    allow_join_before_host: Optional[bool] = False
    start_host_video: Optional[bool] = False
    start_participants_video: Optional[bool] = False
    audio_options: Optional[List[str]] = None
    occurrences: Optional[List[UpdateMeetingResponseOccurrencesItem]] = None
    """ List of meeting occurrences """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadMeetingServiceInfoResponseExternalUserInfo(DataClassJsonMixin):
    uri: Optional[str] = None
    user_id: Optional[str] = None
    account_id: Optional[str] = None
    user_type: Optional[int] = None
    user_token: Optional[str] = None
    host_key: Optional[str] = None
    personal_meeting_id: Optional[str] = None
    personal_link: Optional[str] = None
    """
    Link to the user's personal meeting room, used as an alias for personal meeting URL (with
    personal meeting ID)
    
    Example: `https://meetings.ringcentral.com/my/jsmith`
    """
    
    use_pmi_for_instant_meetings: Optional[bool] = False
    """ Enables using personal meeting ID for instant meetings """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadMeetingServiceInfoResponseDialInNumbersItemCountry(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    iso_code: Optional[str] = None
    calling_code: Optional[str] = None
    emergency_calling: Optional[bool] = False
    number_selling: Optional[bool] = False
    login_allowed: Optional[bool] = False

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadMeetingServiceInfoResponseDialInNumbersItem(DataClassJsonMixin):
    phone_number: Optional[str] = None
    formatted_number: Optional[str] = None
    location: Optional[str] = None
    country: Optional[ReadMeetingServiceInfoResponseDialInNumbersItemCountry] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadMeetingServiceInfoResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    support_uri: Optional[str] = None
    intl_dial_in_numbers_uri: Optional[str] = None
    external_user_info: Optional[ReadMeetingServiceInfoResponseExternalUserInfo] = None
    dial_in_numbers: Optional[List[ReadMeetingServiceInfoResponseDialInNumbersItem]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateMeetingServiceInfoRequestExternalUserInfo(DataClassJsonMixin):
    uri: Optional[str] = None
    user_id: Optional[str] = None
    account_id: Optional[str] = None
    user_type: Optional[int] = None
    user_token: Optional[str] = None
    host_key: Optional[str] = None
    personal_meeting_id: Optional[str] = None
    personal_link: Optional[str] = None
    """
    Link to the user's personal meeting room, used as an alias for personal meeting URL (with
    personal meeting ID)
    
    Example: `https://meetings.ringcentral.com/my/jsmith`
    """
    
    use_pmi_for_instant_meetings: Optional[bool] = False
    """ Enables using personal meeting ID for instant meetings """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateMeetingServiceInfoRequest(DataClassJsonMixin):
    external_user_info: Optional[UpdateMeetingServiceInfoRequestExternalUserInfo] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateMeetingServiceInfoResponseExternalUserInfo(DataClassJsonMixin):
    uri: Optional[str] = None
    user_id: Optional[str] = None
    account_id: Optional[str] = None
    user_type: Optional[int] = None
    user_token: Optional[str] = None
    host_key: Optional[str] = None
    personal_meeting_id: Optional[str] = None
    personal_link: Optional[str] = None
    """
    Link to the user's personal meeting room, used as an alias for personal meeting URL (with
    personal meeting ID)
    
    Example: `https://meetings.ringcentral.com/my/jsmith`
    """
    
    use_pmi_for_instant_meetings: Optional[bool] = False
    """ Enables using personal meeting ID for instant meetings """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateMeetingServiceInfoResponseDialInNumbersItemCountry(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    iso_code: Optional[str] = None
    calling_code: Optional[str] = None
    emergency_calling: Optional[bool] = False
    number_selling: Optional[bool] = False
    login_allowed: Optional[bool] = False

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateMeetingServiceInfoResponseDialInNumbersItem(DataClassJsonMixin):
    phone_number: Optional[str] = None
    formatted_number: Optional[str] = None
    location: Optional[str] = None
    country: Optional[UpdateMeetingServiceInfoResponseDialInNumbersItemCountry] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateMeetingServiceInfoResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    support_uri: Optional[str] = None
    intl_dial_in_numbers_uri: Optional[str] = None
    external_user_info: Optional[UpdateMeetingServiceInfoResponseExternalUserInfo] = None
    dial_in_numbers: Optional[List[UpdateMeetingServiceInfoResponseDialInNumbersItem]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadAssistantsResponseRecordsItem(DataClassJsonMixin):
    id: Optional[str] = None
    name: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadAssistantsResponse(DataClassJsonMixin):
    records: Optional[List[ReadAssistantsResponseRecordsItem]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadAssistedUsersResponseRecordsItem(DataClassJsonMixin):
    id: Optional[str] = None
    name: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadAssistedUsersResponse(DataClassJsonMixin):
    records: Optional[List[ReadAssistedUsersResponseRecordsItem]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadMeetingInvitationResponse(DataClassJsonMixin):
    invitation: Optional[str] = None
    """ Meeting invitation """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListSubscriptionsResponseRecordsItemDisabledFiltersItem(DataClassJsonMixin):
    filter: Optional[str] = None
    """ Event filter that is disabled for the user """
    
    reason: Optional[str] = None
    """ Reason why the filter is disabled for the user """
    
    message: Optional[str] = None
    """ Error message """
    

class ListSubscriptionsResponseRecordsItemStatus(Enum):
    """ Subscription status """
    
    Active = 'Active'
    Suspended = 'Suspended'
    Blacklisted = 'Blacklisted'

class ListSubscriptionsResponseRecordsItemDeliveryModeTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListSubscriptionsResponseRecordsItemDeliveryMode(DataClassJsonMixin):
    """ Delivery mode data """
    
    encryption: Optional[bool] = None
    """ Optional parameter. Specifies if the message will be encrypted or not """
    
    address: Optional[str] = None
    """ PubNub channel name """
    
    subscriber_key: Optional[str] = None
    """ PubNub subscriber credentials required to subscribe to the channel """
    
    secret_key: Optional[str] = None
    """
    PubNub subscriber credentials required to subscribe to the channel. Optional (for PubNub
    transport type only)
    """
    
    encryption_algorithm: Optional[str] = None
    """ Encryption algorithm 'AES' (for PubNub transport type only) """
    
    encryption_key: Optional[str] = None
    """ Key for notification message decryption (for PubNub transport type only) """
    
    transport_type: Optional[ListSubscriptionsResponseRecordsItemDeliveryModeTransportType] = None
    """ Notifications transportation provider name """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListSubscriptionsResponseRecordsItemBlacklistedData(DataClassJsonMixin):
    """ Returned if WebHook subscription is blacklisted """
    
    blacklisted_at: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Time of adding subscrition to a black list in [ISO
    8601](https://en.wikipedia.org/wiki/ISO_8601) format including timezone, for example
    *2016-03-10T18:07:52.534Z*
    """
    
    reason: Optional[str] = None
    """ Reason for adding subscrition to a black list """
    

class ListSubscriptionsResponseRecordsItemTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListSubscriptionsResponseRecordsItem(DataClassJsonMixin):
    """
    Required Properties:
     - delivery_mode
    
    Generated by Python OpenAPI Parser
    """
    
    delivery_mode: ListSubscriptionsResponseRecordsItemDeliveryMode
    """ Delivery mode data """
    
    id: Optional[str] = None
    """ Internal identifier of a subscription """
    
    uri: Optional[str] = None
    """ Canonical URI of a subscription """
    
    event_filters: Optional[List[str]] = None
    """
    Collection of API resources (message-store/presence/detailed presence) corresponding to events
    the user is subscribed to
    """
    
    disabled_filters: Optional[List[ListSubscriptionsResponseRecordsItemDisabledFiltersItem]] = None
    """
    Collection of API resources (message-store/presence/detailed presence) corresponding to events
    the user is not subscribed to due to certain limitations
    """
    
    expiration_time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Subscription expiration datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format
    including timezone, for example 2016-03-10T18:07:52.534Z
    """
    
    expires_in: Optional[int] = 900
    """ Subscription lifetime in seconds """
    
    status: Optional[ListSubscriptionsResponseRecordsItemStatus] = None
    """ Subscription status """
    
    creation_time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Subscription creation datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format
    including timezone, for example 2016-03-10T18:07:52.534Z
    """
    
    blacklisted_data: Optional[ListSubscriptionsResponseRecordsItemBlacklistedData] = None
    """ Returned if WebHook subscription is blacklisted """
    
    transport_type: Optional[ListSubscriptionsResponseRecordsItemTransportType] = None
    """ Notifications transportation provider name """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListSubscriptionsResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    records: Optional[List[ListSubscriptionsResponseRecordsItem]] = None

class CreateSubscriptionRequestDeliveryModeTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSubscriptionRequestDeliveryMode(DataClassJsonMixin):
    """ Notification delivery settings """
    
    transport_type: Optional[CreateSubscriptionRequestDeliveryModeTransportType] = None
    """ Notifications transportation provider name """
    
    address: Optional[str] = None
    """
    Mandatory for 'WebHook' transport type, URL of a consumer service (cannot be changed during
    subscription update)
    """
    
    encryption: Optional[bool] = None
    """
    Optional parameter. Specifies if the message will be encrypted or not. If request contains any
    presence event filter the value by default is 'True' (even if specified as 'false'). If request
    contains only message event filters the value by default is 'False'
    """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    verification_token: Optional[str] = None
    """
    Verification key of a subscription ensuring data security. Supported for 'Webhook' transport
    type
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSubscriptionRequest(DataClassJsonMixin):
    """
    Required Properties:
     - delivery_mode
     - event_filters
    
    Generated by Python OpenAPI Parser
    """
    
    event_filters: List[str]
    """ Collection of URIs to API resources """
    
    delivery_mode: CreateSubscriptionRequestDeliveryMode
    """ Notification delivery settings """
    
    expires_in: Optional[int] = 604800
    """
    Subscription lifetime in seconds. Max value is 7 days (604800 sec). For *WebHook* transport
    type max value might be set up to 630720000 seconds (20 years)
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSubscriptionResponseDisabledFiltersItem(DataClassJsonMixin):
    filter: Optional[str] = None
    """ Event filter that is disabled for the user """
    
    reason: Optional[str] = None
    """ Reason why the filter is disabled for the user """
    
    message: Optional[str] = None
    """ Error message """
    

class CreateSubscriptionResponseStatus(Enum):
    """ Subscription status """
    
    Active = 'Active'
    Suspended = 'Suspended'
    Blacklisted = 'Blacklisted'

class CreateSubscriptionResponseDeliveryModeTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSubscriptionResponseDeliveryMode(DataClassJsonMixin):
    """ Delivery mode data """
    
    encryption: Optional[bool] = None
    """ Optional parameter. Specifies if the message will be encrypted or not """
    
    address: Optional[str] = None
    """ PubNub channel name """
    
    subscriber_key: Optional[str] = None
    """ PubNub subscriber credentials required to subscribe to the channel """
    
    secret_key: Optional[str] = None
    """
    PubNub subscriber credentials required to subscribe to the channel. Optional (for PubNub
    transport type only)
    """
    
    encryption_algorithm: Optional[str] = None
    """ Encryption algorithm 'AES' (for PubNub transport type only) """
    
    encryption_key: Optional[str] = None
    """ Key for notification message decryption (for PubNub transport type only) """
    
    transport_type: Optional[CreateSubscriptionResponseDeliveryModeTransportType] = None
    """ Notifications transportation provider name """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSubscriptionResponseBlacklistedData(DataClassJsonMixin):
    """ Returned if WebHook subscription is blacklisted """
    
    blacklisted_at: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Time of adding subscrition to a black list in [ISO
    8601](https://en.wikipedia.org/wiki/ISO_8601) format including timezone, for example
    *2016-03-10T18:07:52.534Z*
    """
    
    reason: Optional[str] = None
    """ Reason for adding subscrition to a black list """
    

class CreateSubscriptionResponseTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateSubscriptionResponse(DataClassJsonMixin):
    """
    Required Properties:
     - delivery_mode
    
    Generated by Python OpenAPI Parser
    """
    
    delivery_mode: CreateSubscriptionResponseDeliveryMode
    """ Delivery mode data """
    
    id: Optional[str] = None
    """ Internal identifier of a subscription """
    
    uri: Optional[str] = None
    """ Canonical URI of a subscription """
    
    event_filters: Optional[List[str]] = None
    """
    Collection of API resources (message-store/presence/detailed presence) corresponding to events
    the user is subscribed to
    """
    
    disabled_filters: Optional[List[CreateSubscriptionResponseDisabledFiltersItem]] = None
    """
    Collection of API resources (message-store/presence/detailed presence) corresponding to events
    the user is not subscribed to due to certain limitations
    """
    
    expiration_time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Subscription expiration datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format
    including timezone, for example 2016-03-10T18:07:52.534Z
    """
    
    expires_in: Optional[int] = 900
    """ Subscription lifetime in seconds """
    
    status: Optional[CreateSubscriptionResponseStatus] = None
    """ Subscription status """
    
    creation_time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Subscription creation datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format
    including timezone, for example 2016-03-10T18:07:52.534Z
    """
    
    blacklisted_data: Optional[CreateSubscriptionResponseBlacklistedData] = None
    """ Returned if WebHook subscription is blacklisted """
    
    transport_type: Optional[CreateSubscriptionResponseTransportType] = None
    """ Notifications transportation provider name """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadSubscriptionResponseDisabledFiltersItem(DataClassJsonMixin):
    filter: Optional[str] = None
    """ Event filter that is disabled for the user """
    
    reason: Optional[str] = None
    """ Reason why the filter is disabled for the user """
    
    message: Optional[str] = None
    """ Error message """
    

class ReadSubscriptionResponseStatus(Enum):
    """ Subscription status """
    
    Active = 'Active'
    Suspended = 'Suspended'
    Blacklisted = 'Blacklisted'

class ReadSubscriptionResponseDeliveryModeTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadSubscriptionResponseDeliveryMode(DataClassJsonMixin):
    """ Delivery mode data """
    
    encryption: Optional[bool] = None
    """ Optional parameter. Specifies if the message will be encrypted or not """
    
    address: Optional[str] = None
    """ PubNub channel name """
    
    subscriber_key: Optional[str] = None
    """ PubNub subscriber credentials required to subscribe to the channel """
    
    secret_key: Optional[str] = None
    """
    PubNub subscriber credentials required to subscribe to the channel. Optional (for PubNub
    transport type only)
    """
    
    encryption_algorithm: Optional[str] = None
    """ Encryption algorithm 'AES' (for PubNub transport type only) """
    
    encryption_key: Optional[str] = None
    """ Key for notification message decryption (for PubNub transport type only) """
    
    transport_type: Optional[ReadSubscriptionResponseDeliveryModeTransportType] = None
    """ Notifications transportation provider name """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadSubscriptionResponseBlacklistedData(DataClassJsonMixin):
    """ Returned if WebHook subscription is blacklisted """
    
    blacklisted_at: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Time of adding subscrition to a black list in [ISO
    8601](https://en.wikipedia.org/wiki/ISO_8601) format including timezone, for example
    *2016-03-10T18:07:52.534Z*
    """
    
    reason: Optional[str] = None
    """ Reason for adding subscrition to a black list """
    

class ReadSubscriptionResponseTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadSubscriptionResponse(DataClassJsonMixin):
    """
    Required Properties:
     - delivery_mode
    
    Generated by Python OpenAPI Parser
    """
    
    delivery_mode: ReadSubscriptionResponseDeliveryMode
    """ Delivery mode data """
    
    id: Optional[str] = None
    """ Internal identifier of a subscription """
    
    uri: Optional[str] = None
    """ Canonical URI of a subscription """
    
    event_filters: Optional[List[str]] = None
    """
    Collection of API resources (message-store/presence/detailed presence) corresponding to events
    the user is subscribed to
    """
    
    disabled_filters: Optional[List[ReadSubscriptionResponseDisabledFiltersItem]] = None
    """
    Collection of API resources (message-store/presence/detailed presence) corresponding to events
    the user is not subscribed to due to certain limitations
    """
    
    expiration_time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Subscription expiration datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format
    including timezone, for example 2016-03-10T18:07:52.534Z
    """
    
    expires_in: Optional[int] = 900
    """ Subscription lifetime in seconds """
    
    status: Optional[ReadSubscriptionResponseStatus] = None
    """ Subscription status """
    
    creation_time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Subscription creation datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format
    including timezone, for example 2016-03-10T18:07:52.534Z
    """
    
    blacklisted_data: Optional[ReadSubscriptionResponseBlacklistedData] = None
    """ Returned if WebHook subscription is blacklisted """
    
    transport_type: Optional[ReadSubscriptionResponseTransportType] = None
    """ Notifications transportation provider name """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    

class UpdateSubscriptionRequestDeliveryModeTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateSubscriptionRequestDeliveryMode(DataClassJsonMixin):
    """ Notification delivery settings """
    
    transport_type: Optional[UpdateSubscriptionRequestDeliveryModeTransportType] = None
    """ Notifications transportation provider name """
    
    address: Optional[str] = None
    """
    Mandatory for 'WebHook' transport type, URL of a consumer service (cannot be changed during
    subscription update)
    """
    
    encryption: Optional[bool] = None
    """
    Optional parameter. Specifies if the message will be encrypted or not. If request contains any
    presence event filter the value by default is 'True' (even if specified as 'false'). If request
    contains only message event filters the value by default is 'False'
    """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    verification_token: Optional[str] = None
    """
    Verification key of a subscription ensuring data security. Supported for 'Webhook' transport
    type
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateSubscriptionRequest(DataClassJsonMixin):
    """
    Required Properties:
     - event_filters
    
    Generated by Python OpenAPI Parser
    """
    
    event_filters: List[str]
    """ Collection of URIs to API resources """
    
    delivery_mode: Optional[UpdateSubscriptionRequestDeliveryMode] = None
    """ Notification delivery settings """
    
    expires_in: Optional[int] = 604800
    """
    Subscription lifetime in seconds. Max value is 7 days (604800 sec). For *WebHook* transport
    type max value might be set up to 630720000 seconds (20 years)
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateSubscriptionResponseDisabledFiltersItem(DataClassJsonMixin):
    filter: Optional[str] = None
    """ Event filter that is disabled for the user """
    
    reason: Optional[str] = None
    """ Reason why the filter is disabled for the user """
    
    message: Optional[str] = None
    """ Error message """
    

class UpdateSubscriptionResponseStatus(Enum):
    """ Subscription status """
    
    Active = 'Active'
    Suspended = 'Suspended'
    Blacklisted = 'Blacklisted'

class UpdateSubscriptionResponseDeliveryModeTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateSubscriptionResponseDeliveryMode(DataClassJsonMixin):
    """ Delivery mode data """
    
    encryption: Optional[bool] = None
    """ Optional parameter. Specifies if the message will be encrypted or not """
    
    address: Optional[str] = None
    """ PubNub channel name """
    
    subscriber_key: Optional[str] = None
    """ PubNub subscriber credentials required to subscribe to the channel """
    
    secret_key: Optional[str] = None
    """
    PubNub subscriber credentials required to subscribe to the channel. Optional (for PubNub
    transport type only)
    """
    
    encryption_algorithm: Optional[str] = None
    """ Encryption algorithm 'AES' (for PubNub transport type only) """
    
    encryption_key: Optional[str] = None
    """ Key for notification message decryption (for PubNub transport type only) """
    
    transport_type: Optional[UpdateSubscriptionResponseDeliveryModeTransportType] = None
    """ Notifications transportation provider name """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateSubscriptionResponseBlacklistedData(DataClassJsonMixin):
    """ Returned if WebHook subscription is blacklisted """
    
    blacklisted_at: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Time of adding subscrition to a black list in [ISO
    8601](https://en.wikipedia.org/wiki/ISO_8601) format including timezone, for example
    *2016-03-10T18:07:52.534Z*
    """
    
    reason: Optional[str] = None
    """ Reason for adding subscrition to a black list """
    

class UpdateSubscriptionResponseTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateSubscriptionResponse(DataClassJsonMixin):
    """
    Required Properties:
     - delivery_mode
    
    Generated by Python OpenAPI Parser
    """
    
    delivery_mode: UpdateSubscriptionResponseDeliveryMode
    """ Delivery mode data """
    
    id: Optional[str] = None
    """ Internal identifier of a subscription """
    
    uri: Optional[str] = None
    """ Canonical URI of a subscription """
    
    event_filters: Optional[List[str]] = None
    """
    Collection of API resources (message-store/presence/detailed presence) corresponding to events
    the user is subscribed to
    """
    
    disabled_filters: Optional[List[UpdateSubscriptionResponseDisabledFiltersItem]] = None
    """
    Collection of API resources (message-store/presence/detailed presence) corresponding to events
    the user is not subscribed to due to certain limitations
    """
    
    expiration_time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Subscription expiration datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format
    including timezone, for example 2016-03-10T18:07:52.534Z
    """
    
    expires_in: Optional[int] = 900
    """ Subscription lifetime in seconds """
    
    status: Optional[UpdateSubscriptionResponseStatus] = None
    """ Subscription status """
    
    creation_time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Subscription creation datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format
    including timezone, for example 2016-03-10T18:07:52.534Z
    """
    
    blacklisted_data: Optional[UpdateSubscriptionResponseBlacklistedData] = None
    """ Returned if WebHook subscription is blacklisted """
    
    transport_type: Optional[UpdateSubscriptionResponseTransportType] = None
    """ Notifications transportation provider name """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class RenewSubscriptionResponseDisabledFiltersItem(DataClassJsonMixin):
    filter: Optional[str] = None
    """ Event filter that is disabled for the user """
    
    reason: Optional[str] = None
    """ Reason why the filter is disabled for the user """
    
    message: Optional[str] = None
    """ Error message """
    

class RenewSubscriptionResponseStatus(Enum):
    """ Subscription status """
    
    Active = 'Active'
    Suspended = 'Suspended'
    Blacklisted = 'Blacklisted'

class RenewSubscriptionResponseDeliveryModeTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class RenewSubscriptionResponseDeliveryMode(DataClassJsonMixin):
    """ Delivery mode data """
    
    encryption: Optional[bool] = None
    """ Optional parameter. Specifies if the message will be encrypted or not """
    
    address: Optional[str] = None
    """ PubNub channel name """
    
    subscriber_key: Optional[str] = None
    """ PubNub subscriber credentials required to subscribe to the channel """
    
    secret_key: Optional[str] = None
    """
    PubNub subscriber credentials required to subscribe to the channel. Optional (for PubNub
    transport type only)
    """
    
    encryption_algorithm: Optional[str] = None
    """ Encryption algorithm 'AES' (for PubNub transport type only) """
    
    encryption_key: Optional[str] = None
    """ Key for notification message decryption (for PubNub transport type only) """
    
    transport_type: Optional[RenewSubscriptionResponseDeliveryModeTransportType] = None
    """ Notifications transportation provider name """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class RenewSubscriptionResponseBlacklistedData(DataClassJsonMixin):
    """ Returned if WebHook subscription is blacklisted """
    
    blacklisted_at: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Time of adding subscrition to a black list in [ISO
    8601](https://en.wikipedia.org/wiki/ISO_8601) format including timezone, for example
    *2016-03-10T18:07:52.534Z*
    """
    
    reason: Optional[str] = None
    """ Reason for adding subscrition to a black list """
    

class RenewSubscriptionResponseTransportType(Enum):
    """ Notifications transportation provider name """
    
    PubNub = 'PubNub'
    WebHook = 'WebHook'
    RC_APNS = 'RC/APNS'
    RC_GCM = 'RC/GCM'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class RenewSubscriptionResponse(DataClassJsonMixin):
    """
    Required Properties:
     - delivery_mode
    
    Generated by Python OpenAPI Parser
    """
    
    delivery_mode: RenewSubscriptionResponseDeliveryMode
    """ Delivery mode data """
    
    id: Optional[str] = None
    """ Internal identifier of a subscription """
    
    uri: Optional[str] = None
    """ Canonical URI of a subscription """
    
    event_filters: Optional[List[str]] = None
    """
    Collection of API resources (message-store/presence/detailed presence) corresponding to events
    the user is subscribed to
    """
    
    disabled_filters: Optional[List[RenewSubscriptionResponseDisabledFiltersItem]] = None
    """
    Collection of API resources (message-store/presence/detailed presence) corresponding to events
    the user is not subscribed to due to certain limitations
    """
    
    expiration_time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Subscription expiration datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format
    including timezone, for example 2016-03-10T18:07:52.534Z
    """
    
    expires_in: Optional[int] = 900
    """ Subscription lifetime in seconds """
    
    status: Optional[RenewSubscriptionResponseStatus] = None
    """ Subscription status """
    
    creation_time: Optional[datetime] = field(metadata=config(encoder=datetime.isoformat, decoder=datetime_decoder(datetime)), default=None)
    """
    Subscription creation datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format
    including timezone, for example 2016-03-10T18:07:52.534Z
    """
    
    blacklisted_data: Optional[RenewSubscriptionResponseBlacklistedData] = None
    """ Returned if WebHook subscription is blacklisted """
    
    transport_type: Optional[RenewSubscriptionResponseTransportType] = None
    """ Notifications transportation provider name """
    
    certificate_name: Optional[str] = None
    """ Name of a certificate. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    
    registration_id: Optional[str] = None
    """ Identifier of a registration. Supported for 'RC/APNS' and 'RC/GCM' transport types """
    

class ReadAuthorizationProfileResponsePermissionsItemPermissionSiteCompatible(Enum):
    """ Site compatibility flag set for permission """
    
    Compatible = 'Compatible'
    Incompatible = 'Incompatible'
    Independent = 'Independent'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadAuthorizationProfileResponsePermissionsItemPermission(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None
    site_compatible: Optional[ReadAuthorizationProfileResponsePermissionsItemPermissionSiteCompatible] = None
    """ Site compatibility flag set for permission """
    
    read_only: Optional[bool] = None
    """ Specifies if the permission is editable on UI (if set to 'True') or not (if set to 'False') """
    
    assignable: Optional[bool] = None
    """ Specifies if the permission can be assigned by the account administrator """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadAuthorizationProfileResponsePermissionsItemEffectiveRole(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None

class ReadAuthorizationProfileResponsePermissionsItemScopesItem(Enum):
    Account = 'Account'
    AllExtensions = 'AllExtensions'
    Federation = 'Federation'
    NonUserExtensions = 'NonUserExtensions'
    RoleBased = 'RoleBased'
    Self = 'Self'
    UserExtensions = 'UserExtensions'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadAuthorizationProfileResponsePermissionsItem(DataClassJsonMixin):
    permission: Optional[ReadAuthorizationProfileResponsePermissionsItemPermission] = None
    effective_role: Optional[ReadAuthorizationProfileResponsePermissionsItemEffectiveRole] = None
    scopes: Optional[List[ReadAuthorizationProfileResponsePermissionsItemScopesItem]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadAuthorizationProfileResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    permissions: Optional[List[ReadAuthorizationProfileResponsePermissionsItem]] = None

class CheckUserPermissionResponseDetailsPermissionSiteCompatible(Enum):
    """ Site compatibility flag set for permission """
    
    Compatible = 'Compatible'
    Incompatible = 'Incompatible'
    Independent = 'Independent'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CheckUserPermissionResponseDetailsPermission(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None
    site_compatible: Optional[CheckUserPermissionResponseDetailsPermissionSiteCompatible] = None
    """ Site compatibility flag set for permission """
    
    read_only: Optional[bool] = None
    """ Specifies if the permission is editable on UI (if set to 'True') or not (if set to 'False') """
    
    assignable: Optional[bool] = None
    """ Specifies if the permission can be assigned by the account administrator """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CheckUserPermissionResponseDetailsEffectiveRole(DataClassJsonMixin):
    uri: Optional[str] = None
    id: Optional[str] = None

class CheckUserPermissionResponseDetailsScopesItem(Enum):
    Account = 'Account'
    AllExtensions = 'AllExtensions'
    Federation = 'Federation'
    NonUserExtensions = 'NonUserExtensions'
    RoleBased = 'RoleBased'
    Self = 'Self'
    UserExtensions = 'UserExtensions'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CheckUserPermissionResponseDetails(DataClassJsonMixin):
    permission: Optional[CheckUserPermissionResponseDetailsPermission] = None
    effective_role: Optional[CheckUserPermissionResponseDetailsEffectiveRole] = None
    scopes: Optional[List[CheckUserPermissionResponseDetailsScopesItem]] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CheckUserPermissionResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    successful: Optional[bool] = False
    details: Optional[CheckUserPermissionResponseDetails] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUserBusinessHoursResponseScheduleWeeklyRangesMondayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUserBusinessHoursResponseScheduleWeeklyRangesTuesdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUserBusinessHoursResponseScheduleWeeklyRangesWednesdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUserBusinessHoursResponseScheduleWeeklyRangesThursdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUserBusinessHoursResponseScheduleWeeklyRangesFridayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUserBusinessHoursResponseScheduleWeeklyRangesSaturdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUserBusinessHoursResponseScheduleWeeklyRangesSundayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUserBusinessHoursResponseScheduleWeeklyRanges(DataClassJsonMixin):
    """ Weekly schedule """
    
    monday: Optional[List[ReadUserBusinessHoursResponseScheduleWeeklyRangesMondayItem]] = None
    """ Time intervals for a particular day """
    
    tuesday: Optional[List[ReadUserBusinessHoursResponseScheduleWeeklyRangesTuesdayItem]] = None
    """ Time intervals for a particular day """
    
    wednesday: Optional[List[ReadUserBusinessHoursResponseScheduleWeeklyRangesWednesdayItem]] = None
    """ Time intervals for a particular day """
    
    thursday: Optional[List[ReadUserBusinessHoursResponseScheduleWeeklyRangesThursdayItem]] = None
    """ Time intervals for a particular day """
    
    friday: Optional[List[ReadUserBusinessHoursResponseScheduleWeeklyRangesFridayItem]] = None
    """ Time intervals for a particular day """
    
    saturday: Optional[List[ReadUserBusinessHoursResponseScheduleWeeklyRangesSaturdayItem]] = None
    """ Time intervals for a particular day """
    
    sunday: Optional[List[ReadUserBusinessHoursResponseScheduleWeeklyRangesSundayItem]] = None
    """ Time intervals for a particular day """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUserBusinessHoursResponseSchedule(DataClassJsonMixin):
    """ Schedule when an answering rule is applied """
    
    weekly_ranges: Optional[ReadUserBusinessHoursResponseScheduleWeeklyRanges] = None
    """ Weekly schedule """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadUserBusinessHoursResponse(DataClassJsonMixin):
    """
    Example:
        ```json
        {
            "uri": "https.../restapi/v1.0/account/401800045008/extension/401800045008/business-hours",
            "schedule": {
                "weeklyRanges": {
                    "wednesday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "friday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "tuesday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "monday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "thursday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ]
                }
            }
        }
        ```
    
    Generated by Python OpenAPI Parser
    """
    
    uri: Optional[str] = None
    """ Canonical URI of a business-hours resource """
    
    schedule: Optional[ReadUserBusinessHoursResponseSchedule] = None
    """ Schedule when an answering rule is applied """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursRequestScheduleWeeklyRangesMondayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursRequestScheduleWeeklyRangesTuesdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursRequestScheduleWeeklyRangesWednesdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursRequestScheduleWeeklyRangesThursdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursRequestScheduleWeeklyRangesFridayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursRequestScheduleWeeklyRangesSaturdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursRequestScheduleWeeklyRangesSundayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursRequestScheduleWeeklyRanges(DataClassJsonMixin):
    """ Weekly schedule """
    
    monday: Optional[List[UpdateUserBusinessHoursRequestScheduleWeeklyRangesMondayItem]] = None
    """ Time intervals for a particular day """
    
    tuesday: Optional[List[UpdateUserBusinessHoursRequestScheduleWeeklyRangesTuesdayItem]] = None
    """ Time intervals for a particular day """
    
    wednesday: Optional[List[UpdateUserBusinessHoursRequestScheduleWeeklyRangesWednesdayItem]] = None
    """ Time intervals for a particular day """
    
    thursday: Optional[List[UpdateUserBusinessHoursRequestScheduleWeeklyRangesThursdayItem]] = None
    """ Time intervals for a particular day """
    
    friday: Optional[List[UpdateUserBusinessHoursRequestScheduleWeeklyRangesFridayItem]] = None
    """ Time intervals for a particular day """
    
    saturday: Optional[List[UpdateUserBusinessHoursRequestScheduleWeeklyRangesSaturdayItem]] = None
    """ Time intervals for a particular day """
    
    sunday: Optional[List[UpdateUserBusinessHoursRequestScheduleWeeklyRangesSundayItem]] = None
    """ Time intervals for a particular day """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursRequestSchedule(DataClassJsonMixin):
    """ Schedule when an answering rule is applied """
    
    weekly_ranges: Optional[UpdateUserBusinessHoursRequestScheduleWeeklyRanges] = None
    """ Weekly schedule """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursRequest(DataClassJsonMixin):
    schedule: Optional[UpdateUserBusinessHoursRequestSchedule] = None
    """ Schedule when an answering rule is applied """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursResponseScheduleWeeklyRangesMondayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursResponseScheduleWeeklyRangesTuesdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursResponseScheduleWeeklyRangesWednesdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursResponseScheduleWeeklyRangesThursdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursResponseScheduleWeeklyRangesFridayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursResponseScheduleWeeklyRangesSaturdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursResponseScheduleWeeklyRangesSundayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursResponseScheduleWeeklyRanges(DataClassJsonMixin):
    """ Weekly schedule """
    
    monday: Optional[List[UpdateUserBusinessHoursResponseScheduleWeeklyRangesMondayItem]] = None
    """ Time intervals for a particular day """
    
    tuesday: Optional[List[UpdateUserBusinessHoursResponseScheduleWeeklyRangesTuesdayItem]] = None
    """ Time intervals for a particular day """
    
    wednesday: Optional[List[UpdateUserBusinessHoursResponseScheduleWeeklyRangesWednesdayItem]] = None
    """ Time intervals for a particular day """
    
    thursday: Optional[List[UpdateUserBusinessHoursResponseScheduleWeeklyRangesThursdayItem]] = None
    """ Time intervals for a particular day """
    
    friday: Optional[List[UpdateUserBusinessHoursResponseScheduleWeeklyRangesFridayItem]] = None
    """ Time intervals for a particular day """
    
    saturday: Optional[List[UpdateUserBusinessHoursResponseScheduleWeeklyRangesSaturdayItem]] = None
    """ Time intervals for a particular day """
    
    sunday: Optional[List[UpdateUserBusinessHoursResponseScheduleWeeklyRangesSundayItem]] = None
    """ Time intervals for a particular day """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursResponseSchedule(DataClassJsonMixin):
    """ Schedule when an answering rule is applied """
    
    weekly_ranges: Optional[UpdateUserBusinessHoursResponseScheduleWeeklyRanges] = None
    """ Weekly schedule """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateUserBusinessHoursResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Canonical URI of a business-hours resource """
    
    schedule: Optional[UpdateUserBusinessHoursResponseSchedule] = None
    """ Schedule when an answering rule is applied """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadCompanyBusinessHoursResponseScheduleWeeklyRangesMondayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadCompanyBusinessHoursResponseScheduleWeeklyRangesTuesdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadCompanyBusinessHoursResponseScheduleWeeklyRangesWednesdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadCompanyBusinessHoursResponseScheduleWeeklyRangesThursdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadCompanyBusinessHoursResponseScheduleWeeklyRangesFridayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadCompanyBusinessHoursResponseScheduleWeeklyRangesSaturdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadCompanyBusinessHoursResponseScheduleWeeklyRangesSundayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadCompanyBusinessHoursResponseScheduleWeeklyRanges(DataClassJsonMixin):
    monday: Optional[List[ReadCompanyBusinessHoursResponseScheduleWeeklyRangesMondayItem]] = None
    """ Time intervals for a particular day """
    
    tuesday: Optional[List[ReadCompanyBusinessHoursResponseScheduleWeeklyRangesTuesdayItem]] = None
    """ Time intervals for a particular day """
    
    wednesday: Optional[List[ReadCompanyBusinessHoursResponseScheduleWeeklyRangesWednesdayItem]] = None
    """ Time intervals for a particular day """
    
    thursday: Optional[List[ReadCompanyBusinessHoursResponseScheduleWeeklyRangesThursdayItem]] = None
    """ Time intervals for a particular day """
    
    friday: Optional[List[ReadCompanyBusinessHoursResponseScheduleWeeklyRangesFridayItem]] = None
    """ Time intervals for a particular day """
    
    saturday: Optional[List[ReadCompanyBusinessHoursResponseScheduleWeeklyRangesSaturdayItem]] = None
    """ Time intervals for a particular day """
    
    sunday: Optional[List[ReadCompanyBusinessHoursResponseScheduleWeeklyRangesSundayItem]] = None
    """ Time intervals for a particular day """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadCompanyBusinessHoursResponseSchedule(DataClassJsonMixin):
    """ Schedule when an answering rule is applied """
    
    weekly_ranges: Optional[ReadCompanyBusinessHoursResponseScheduleWeeklyRanges] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadCompanyBusinessHoursResponse(DataClassJsonMixin):
    """
    Example:
        ```json
        {
            "uri": "https.../restapi/v1.0/account/401800045008/business-hours",
            "schedule": {
                "weeklyRanges": {
                    "wednesday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "friday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "tuesday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "monday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "thursday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ]
                }
            }
        }
        ```
    
    Generated by Python OpenAPI Parser
    """
    
    uri: Optional[str] = None
    """ Canonical URI of a business-hours resource """
    
    schedule: Optional[ReadCompanyBusinessHoursResponseSchedule] = None
    """ Schedule when an answering rule is applied """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursRequestScheduleWeeklyRangesMondayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursRequestScheduleWeeklyRangesTuesdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursRequestScheduleWeeklyRangesWednesdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursRequestScheduleWeeklyRangesThursdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursRequestScheduleWeeklyRangesFridayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursRequestScheduleWeeklyRangesSaturdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursRequestScheduleWeeklyRangesSundayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursRequestScheduleWeeklyRanges(DataClassJsonMixin):
    monday: Optional[List[UpdateCompanyBusinessHoursRequestScheduleWeeklyRangesMondayItem]] = None
    """ Time intervals for a particular day """
    
    tuesday: Optional[List[UpdateCompanyBusinessHoursRequestScheduleWeeklyRangesTuesdayItem]] = None
    """ Time intervals for a particular day """
    
    wednesday: Optional[List[UpdateCompanyBusinessHoursRequestScheduleWeeklyRangesWednesdayItem]] = None
    """ Time intervals for a particular day """
    
    thursday: Optional[List[UpdateCompanyBusinessHoursRequestScheduleWeeklyRangesThursdayItem]] = None
    """ Time intervals for a particular day """
    
    friday: Optional[List[UpdateCompanyBusinessHoursRequestScheduleWeeklyRangesFridayItem]] = None
    """ Time intervals for a particular day """
    
    saturday: Optional[List[UpdateCompanyBusinessHoursRequestScheduleWeeklyRangesSaturdayItem]] = None
    """ Time intervals for a particular day """
    
    sunday: Optional[List[UpdateCompanyBusinessHoursRequestScheduleWeeklyRangesSundayItem]] = None
    """ Time intervals for a particular day """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursRequestSchedule(DataClassJsonMixin):
    """ Schedule when an answering rule is applied """
    
    weekly_ranges: Optional[UpdateCompanyBusinessHoursRequestScheduleWeeklyRanges] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursRequest(DataClassJsonMixin):
    """
    Example:
        ```json
        {
            "schedule": {
                "weeklyRanges": {
                    "tuesday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "friday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "thursday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "wednesday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "monday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ]
                }
            }
        }
        ```
    
    Generated by Python OpenAPI Parser
    """
    
    schedule: Optional[UpdateCompanyBusinessHoursRequestSchedule] = None
    """ Schedule when an answering rule is applied """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursResponseScheduleWeeklyRangesMondayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursResponseScheduleWeeklyRangesTuesdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursResponseScheduleWeeklyRangesWednesdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursResponseScheduleWeeklyRangesThursdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursResponseScheduleWeeklyRangesFridayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursResponseScheduleWeeklyRangesSaturdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursResponseScheduleWeeklyRangesSundayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursResponseScheduleWeeklyRanges(DataClassJsonMixin):
    monday: Optional[List[UpdateCompanyBusinessHoursResponseScheduleWeeklyRangesMondayItem]] = None
    """ Time intervals for a particular day """
    
    tuesday: Optional[List[UpdateCompanyBusinessHoursResponseScheduleWeeklyRangesTuesdayItem]] = None
    """ Time intervals for a particular day """
    
    wednesday: Optional[List[UpdateCompanyBusinessHoursResponseScheduleWeeklyRangesWednesdayItem]] = None
    """ Time intervals for a particular day """
    
    thursday: Optional[List[UpdateCompanyBusinessHoursResponseScheduleWeeklyRangesThursdayItem]] = None
    """ Time intervals for a particular day """
    
    friday: Optional[List[UpdateCompanyBusinessHoursResponseScheduleWeeklyRangesFridayItem]] = None
    """ Time intervals for a particular day """
    
    saturday: Optional[List[UpdateCompanyBusinessHoursResponseScheduleWeeklyRangesSaturdayItem]] = None
    """ Time intervals for a particular day """
    
    sunday: Optional[List[UpdateCompanyBusinessHoursResponseScheduleWeeklyRangesSundayItem]] = None
    """ Time intervals for a particular day """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursResponseSchedule(DataClassJsonMixin):
    """ Schedule when an answering rule is applied """
    
    weekly_ranges: Optional[UpdateCompanyBusinessHoursResponseScheduleWeeklyRanges] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCompanyBusinessHoursResponse(DataClassJsonMixin):
    """
    Example:
        ```json
        {
            "uri": "https.../restapi/v1.0/account/401800045008/business-hours",
            "schedule": {
                "weeklyRanges": {
                    "wednesday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "friday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "tuesday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "monday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ],
                    "thursday": [
                        {
                            "from": "09:00",
                            "to": "18:00"
                        }
                    ]
                }
            }
        }
        ```
    
    Generated by Python OpenAPI Parser
    """
    
    uri: Optional[str] = None
    """ Canonical URI of a business-hours resource """
    
    schedule: Optional[UpdateCompanyBusinessHoursResponseSchedule] = None
    """ Schedule when an answering rule is applied """
    

class ReadCallerBlockingSettingsResponseMode(Enum):
    """ Call blocking options: either specific or all calls and faxes """
    
    Specific = 'Specific'
    All = 'All'

class ReadCallerBlockingSettingsResponseNoCallerId(Enum):
    """ Determines how to handle calls with no caller ID in 'Specific' mode """
    
    BlockCallsAndFaxes = 'BlockCallsAndFaxes'
    BlockFaxes = 'BlockFaxes'
    Allow = 'Allow'

class ReadCallerBlockingSettingsResponsePayPhones(Enum):
    """ Blocking settings for pay phones """
    
    Block = 'Block'
    Allow = 'Allow'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadCallerBlockingSettingsResponseGreetingsItemPreset(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to a greeting resource """
    
    id: Optional[str] = None
    """ Internal identifier of a greeting """
    
    name: Optional[str] = None
    """ Name of a greeting """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadCallerBlockingSettingsResponseGreetingsItem(DataClassJsonMixin):
    type: Optional[str] = None
    """ Type of a greeting """
    
    preset: Optional[ReadCallerBlockingSettingsResponseGreetingsItemPreset] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadCallerBlockingSettingsResponse(DataClassJsonMixin):
    """ Returns the lists of blocked and allowed phone numbers """
    
    mode: Optional[ReadCallerBlockingSettingsResponseMode] = None
    """ Call blocking options: either specific or all calls and faxes """
    
    no_caller_id: Optional[ReadCallerBlockingSettingsResponseNoCallerId] = None
    """ Determines how to handle calls with no caller ID in 'Specific' mode """
    
    pay_phones: Optional[ReadCallerBlockingSettingsResponsePayPhones] = None
    """ Blocking settings for pay phones """
    
    greetings: Optional[List[ReadCallerBlockingSettingsResponseGreetingsItem]] = None
    """ List of greetings played for blocked callers """
    

class UpdateCallerBlockingSettingsRequestMode(Enum):
    """ Call blocking options: either specific or all calls and faxes """
    
    Specific = 'Specific'
    All = 'All'

class UpdateCallerBlockingSettingsRequestNoCallerId(Enum):
    """ Determines how to handle calls with no caller ID in 'Specific' mode """
    
    BlockCallsAndFaxes = 'BlockCallsAndFaxes'
    BlockFaxes = 'BlockFaxes'
    Allow = 'Allow'

class UpdateCallerBlockingSettingsRequestPayPhones(Enum):
    """ Blocking settings for pay phones """
    
    Block = 'Block'
    Allow = 'Allow'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCallerBlockingSettingsRequestGreetingsItemPreset(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to a greeting resource """
    
    id: Optional[str] = None
    """ Internal identifier of a greeting """
    
    name: Optional[str] = None
    """ Name of a greeting """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCallerBlockingSettingsRequestGreetingsItem(DataClassJsonMixin):
    type: Optional[str] = None
    """ Type of a greeting """
    
    preset: Optional[UpdateCallerBlockingSettingsRequestGreetingsItemPreset] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCallerBlockingSettingsRequest(DataClassJsonMixin):
    """ Returns the lists of blocked and allowed phone numbers """
    
    mode: Optional[UpdateCallerBlockingSettingsRequestMode] = None
    """ Call blocking options: either specific or all calls and faxes """
    
    no_caller_id: Optional[UpdateCallerBlockingSettingsRequestNoCallerId] = None
    """ Determines how to handle calls with no caller ID in 'Specific' mode """
    
    pay_phones: Optional[UpdateCallerBlockingSettingsRequestPayPhones] = None
    """ Blocking settings for pay phones """
    
    greetings: Optional[List[UpdateCallerBlockingSettingsRequestGreetingsItem]] = None
    """ List of greetings played for blocked callers """
    

class UpdateCallerBlockingSettingsResponseMode(Enum):
    """ Call blocking options: either specific or all calls and faxes """
    
    Specific = 'Specific'
    All = 'All'

class UpdateCallerBlockingSettingsResponseNoCallerId(Enum):
    """ Determines how to handle calls with no caller ID in 'Specific' mode """
    
    BlockCallsAndFaxes = 'BlockCallsAndFaxes'
    BlockFaxes = 'BlockFaxes'
    Allow = 'Allow'

class UpdateCallerBlockingSettingsResponsePayPhones(Enum):
    """ Blocking settings for pay phones """
    
    Block = 'Block'
    Allow = 'Allow'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCallerBlockingSettingsResponseGreetingsItemPreset(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to a greeting resource """
    
    id: Optional[str] = None
    """ Internal identifier of a greeting """
    
    name: Optional[str] = None
    """ Name of a greeting """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCallerBlockingSettingsResponseGreetingsItem(DataClassJsonMixin):
    type: Optional[str] = None
    """ Type of a greeting """
    
    preset: Optional[UpdateCallerBlockingSettingsResponseGreetingsItemPreset] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateCallerBlockingSettingsResponse(DataClassJsonMixin):
    """ Returns the lists of blocked and allowed phone numbers """
    
    mode: Optional[UpdateCallerBlockingSettingsResponseMode] = None
    """ Call blocking options: either specific or all calls and faxes """
    
    no_caller_id: Optional[UpdateCallerBlockingSettingsResponseNoCallerId] = None
    """ Determines how to handle calls with no caller ID in 'Specific' mode """
    
    pay_phones: Optional[UpdateCallerBlockingSettingsResponsePayPhones] = None
    """ Blocking settings for pay phones """
    
    greetings: Optional[List[UpdateCallerBlockingSettingsResponseGreetingsItem]] = None
    """ List of greetings played for blocked callers """
    

class ListBlockedAllowedNumbersStatus(Enum):
    Blocked = 'Blocked'
    Allowed = 'Allowed'

class ListBlockedAllowedNumbersResponseRecordsItemStatus(Enum):
    """ Status of a phone number """
    
    Blocked = 'Blocked'
    Allowed = 'Allowed'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListBlockedAllowedNumbersResponseRecordsItem(DataClassJsonMixin):
    """ Information on a blocked/allowed phone number """
    
    uri: Optional[str] = None
    """ Link to a blocked/allowed phone number """
    
    id: Optional[str] = None
    """ Internal identifier of a blocked/allowed phone number """
    
    phone_number: Optional[str] = None
    """ A blocked/allowed phone number in [E.164](https://www.itu.int/rec/T-REC-E.164-201011-I) format """
    
    label: Optional[str] = None
    """ Custom name of a blocked/allowed phone number """
    
    status: Optional[ListBlockedAllowedNumbersResponseRecordsItemStatus] = None
    """ Status of a phone number """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListBlockedAllowedNumbersResponseNavigationFirstPage(DataClassJsonMixin):
    """ Canonical URI for the first page of the list """
    
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListBlockedAllowedNumbersResponseNavigationNextPage(DataClassJsonMixin):
    """ Canonical URI for the next page of the list """
    
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListBlockedAllowedNumbersResponseNavigationPreviousPage(DataClassJsonMixin):
    """ Canonical URI for the previous page of the list """
    
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListBlockedAllowedNumbersResponseNavigationLastPage(DataClassJsonMixin):
    """ Canonical URI for the last page of the list """
    
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListBlockedAllowedNumbersResponseNavigation(DataClassJsonMixin):
    """ Information on navigation """
    
    first_page: Optional[ListBlockedAllowedNumbersResponseNavigationFirstPage] = None
    """ Canonical URI for the first page of the list """
    
    next_page: Optional[ListBlockedAllowedNumbersResponseNavigationNextPage] = None
    """ Canonical URI for the next page of the list """
    
    previous_page: Optional[ListBlockedAllowedNumbersResponseNavigationPreviousPage] = None
    """ Canonical URI for the previous page of the list """
    
    last_page: Optional[ListBlockedAllowedNumbersResponseNavigationLastPage] = None
    """ Canonical URI for the last page of the list """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListBlockedAllowedNumbersResponsePaging(DataClassJsonMixin):
    """ Information on paging """
    
    page: Optional[int] = None
    """
    The current page number. 1-indexed, so the first page is 1 by default. May be omitted if result
    is empty (because non-existent page was specified or perPage=0 was requested)
    """
    
    per_page: Optional[int] = None
    """
    Current page size, describes how many items are in each page. Default value is 100. Maximum
    value is 1000. If perPage value in the request is greater than 1000, the maximum value (1000)
    is applied
    """
    
    page_start: Optional[int] = None
    """
    The zero-based number of the first element on the current page. Omitted if the page is omitted
    or result is empty
    """
    
    page_end: Optional[int] = None
    """
    The zero-based index of the last element on the current page. Omitted if the page is omitted or
    result is empty
    """
    
    total_pages: Optional[int] = None
    """
    The total number of pages in a dataset. May be omitted for some resources due to performance
    reasons
    """
    
    total_elements: Optional[int] = None
    """
    The total number of elements in a dataset. May be omitted for some resource due to performance
    reasons
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListBlockedAllowedNumbersResponse(DataClassJsonMixin):
    """ List of blocked or allowed phone numbers """
    
    uri: Optional[str] = None
    """ Link to a list of blocked/allowed phone numbers resource """
    
    records: Optional[List[ListBlockedAllowedNumbersResponseRecordsItem]] = None
    navigation: Optional[ListBlockedAllowedNumbersResponseNavigation] = None
    """ Information on navigation """
    
    paging: Optional[ListBlockedAllowedNumbersResponsePaging] = None
    """ Information on paging """
    

class CreateBlockedAllowedNumberRequestStatus(Enum):
    """ Status of a phone number """
    
    Blocked = 'Blocked'
    Allowed = 'Allowed'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateBlockedAllowedNumberRequest(DataClassJsonMixin):
    """ Updates either blocked or allowed phone number list with a new phone number. """
    
    phone_number: Optional[str] = None
    """ A blocked/allowed phone number in [E.164](https://www.itu.int/rec/T-REC-E.164-201011-I) format """
    
    label: Optional[str] = None
    """ Custom name of a blocked/allowed phone number """
    
    status: Optional[CreateBlockedAllowedNumberRequestStatus] = 'Blocked'
    """ Status of a phone number """
    

class CreateBlockedAllowedNumberResponseStatus(Enum):
    """ Status of a phone number """
    
    Blocked = 'Blocked'
    Allowed = 'Allowed'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateBlockedAllowedNumberResponse(DataClassJsonMixin):
    """ Information on a blocked/allowed phone number """
    
    uri: Optional[str] = None
    """ Link to a blocked/allowed phone number """
    
    id: Optional[str] = None
    """ Internal identifier of a blocked/allowed phone number """
    
    phone_number: Optional[str] = None
    """ A blocked/allowed phone number in [E.164](https://www.itu.int/rec/T-REC-E.164-201011-I) format """
    
    label: Optional[str] = None
    """ Custom name of a blocked/allowed phone number """
    
    status: Optional[CreateBlockedAllowedNumberResponseStatus] = None
    """ Status of a phone number """
    

class ReadBlockedAllowedNumberResponseStatus(Enum):
    """ Status of a phone number """
    
    Blocked = 'Blocked'
    Allowed = 'Allowed'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadBlockedAllowedNumberResponse(DataClassJsonMixin):
    """ Information on a blocked/allowed phone number """
    
    uri: Optional[str] = None
    """ Link to a blocked/allowed phone number """
    
    id: Optional[str] = None
    """ Internal identifier of a blocked/allowed phone number """
    
    phone_number: Optional[str] = None
    """ A blocked/allowed phone number in [E.164](https://www.itu.int/rec/T-REC-E.164-201011-I) format """
    
    label: Optional[str] = None
    """ Custom name of a blocked/allowed phone number """
    
    status: Optional[ReadBlockedAllowedNumberResponseStatus] = None
    """ Status of a phone number """
    

class UpdateBlockedAllowedNumberRequestStatus(Enum):
    """ Status of a phone number """
    
    Blocked = 'Blocked'
    Allowed = 'Allowed'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateBlockedAllowedNumberRequest(DataClassJsonMixin):
    """ Updates either blocked or allowed phone number list with a new phone number. """
    
    phone_number: Optional[str] = None
    """ A blocked/allowed phone number in [E.164](https://www.itu.int/rec/T-REC-E.164-201011-I) format """
    
    label: Optional[str] = None
    """ Custom name of a blocked/allowed phone number """
    
    status: Optional[UpdateBlockedAllowedNumberRequestStatus] = 'Blocked'
    """ Status of a phone number """
    

class UpdateBlockedAllowedNumberResponseStatus(Enum):
    """ Status of a phone number """
    
    Blocked = 'Blocked'
    Allowed = 'Allowed'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateBlockedAllowedNumberResponse(DataClassJsonMixin):
    """ Information on a blocked/allowed phone number """
    
    uri: Optional[str] = None
    """ Link to a blocked/allowed phone number """
    
    id: Optional[str] = None
    """ Internal identifier of a blocked/allowed phone number """
    
    phone_number: Optional[str] = None
    """ A blocked/allowed phone number in [E.164](https://www.itu.int/rec/T-REC-E.164-201011-I) format """
    
    label: Optional[str] = None
    """ Custom name of a blocked/allowed phone number """
    
    status: Optional[UpdateBlockedAllowedNumberResponseStatus] = None
    """ Status of a phone number """
    

class ListForwardingNumbersResponseRecordsItemLabel(Enum):
    """ Forwarding/Call flip number title """
    
    Business_Mobile_Phone = 'Business Mobile Phone'

class ListForwardingNumbersResponseRecordsItemFeaturesItem(Enum):
    CallFlip = 'CallFlip'
    CallForwarding = 'CallForwarding'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListForwardingNumbersResponseRecordsItemDevice(DataClassJsonMixin):
    """ Forwarding device information """
    
    id: Optional[str] = None
    """ Internal identifier of the other extension device """
    

class ListForwardingNumbersResponseRecordsItemType(Enum):
    """ Forwarding phone number type """
    
    Home = 'Home'
    Mobile = 'Mobile'
    Work = 'Work'
    PhoneLine = 'PhoneLine'
    Outage = 'Outage'
    Other = 'Other'
    BusinessMobilePhone = 'BusinessMobilePhone'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListForwardingNumbersResponseRecordsItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a forwarding/call flip phone number """
    
    uri: Optional[str] = None
    """ Canonical URI of a forwarding/call flip phone number """
    
    phone_number: Optional[str] = None
    """ Forwarding/Call flip phone number """
    
    label: Optional[ListForwardingNumbersResponseRecordsItemLabel] = None
    """ Forwarding/Call flip number title """
    
    features: Optional[List[ListForwardingNumbersResponseRecordsItemFeaturesItem]] = None
    """ Type of option this phone number is used for. Multiple values are accepted """
    
    flip_number: Optional[str] = None
    """ Number assigned to the call flip phone number, corresponds to the shortcut dial number """
    
    device: Optional[ListForwardingNumbersResponseRecordsItemDevice] = None
    """ Forwarding device information """
    
    type: Optional[ListForwardingNumbersResponseRecordsItemType] = None
    """ Forwarding phone number type """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListForwardingNumbersResponseNavigationFirstPage(DataClassJsonMixin):
    """ Canonical URI for the first page of the list """
    
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListForwardingNumbersResponseNavigationNextPage(DataClassJsonMixin):
    """ Canonical URI for the next page of the list """
    
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListForwardingNumbersResponseNavigationPreviousPage(DataClassJsonMixin):
    """ Canonical URI for the previous page of the list """
    
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListForwardingNumbersResponseNavigationLastPage(DataClassJsonMixin):
    """ Canonical URI for the last page of the list """
    
    uri: Optional[str] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListForwardingNumbersResponseNavigation(DataClassJsonMixin):
    """ Information on navigation """
    
    first_page: Optional[ListForwardingNumbersResponseNavigationFirstPage] = None
    """ Canonical URI for the first page of the list """
    
    next_page: Optional[ListForwardingNumbersResponseNavigationNextPage] = None
    """ Canonical URI for the next page of the list """
    
    previous_page: Optional[ListForwardingNumbersResponseNavigationPreviousPage] = None
    """ Canonical URI for the previous page of the list """
    
    last_page: Optional[ListForwardingNumbersResponseNavigationLastPage] = None
    """ Canonical URI for the last page of the list """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListForwardingNumbersResponsePaging(DataClassJsonMixin):
    """ Information on paging """
    
    page: Optional[int] = None
    """
    The current page number. 1-indexed, so the first page is 1 by default. May be omitted if result
    is empty (because non-existent page was specified or perPage=0 was requested)
    """
    
    per_page: Optional[int] = None
    """
    Current page size, describes how many items are in each page. Default value is 100. Maximum
    value is 1000. If perPage value in the request is greater than 1000, the maximum value (1000)
    is applied
    """
    
    page_start: Optional[int] = None
    """
    The zero-based number of the first element on the current page. Omitted if the page is omitted
    or result is empty
    """
    
    page_end: Optional[int] = None
    """
    The zero-based index of the last element on the current page. Omitted if the page is omitted or
    result is empty
    """
    
    total_pages: Optional[int] = None
    """
    The total number of pages in a dataset. May be omitted for some resources due to performance
    reasons
    """
    
    total_elements: Optional[int] = None
    """
    The total number of elements in a dataset. May be omitted for some resource due to performance
    reasons
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListForwardingNumbersResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Link to the forwarding number list resource """
    
    records: Optional[List[ListForwardingNumbersResponseRecordsItem]] = None
    """ List of forwarding phone numbers """
    
    navigation: Optional[ListForwardingNumbersResponseNavigation] = None
    """ Information on navigation """
    
    paging: Optional[ListForwardingNumbersResponsePaging] = None
    """ Information on paging """
    

class CreateForwardingNumberRequestType(Enum):
    """
    Forwarding/Call flip phone type. If specified, 'label' attribute value is ignored. The default
    value is 'Other'
    
    Generated by Python OpenAPI Parser
    """
    
    PhoneLine = 'PhoneLine'
    Home = 'Home'
    Mobile = 'Mobile'
    Work = 'Work'
    Other = 'Other'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateForwardingNumberRequestDevice(DataClassJsonMixin):
    """
    Reference to the other extension device. Applicable for 'PhoneLine' type only. Cannot be
    specified together with 'phoneNumber' parameter.
    
    Generated by Python OpenAPI Parser
    """
    
    id: Optional[str] = None
    """ Internal identifier of the other extension device """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateForwardingNumberRequest(DataClassJsonMixin):
    flip_number: Optional[int] = None
    """ Number assigned to the call flip phone number, corresponds to the shortcut dial number """
    
    phone_number: Optional[str] = None
    """ Forwarding/Call flip phone number """
    
    label: Optional[str] = None
    """ Forwarding/Call flip number title """
    
    type: Optional[CreateForwardingNumberRequestType] = None
    """
    Forwarding/Call flip phone type. If specified, 'label' attribute value is ignored. The default
    value is 'Other'
    """
    
    device: Optional[CreateForwardingNumberRequestDevice] = None
    """
    Reference to the other extension device. Applicable for 'PhoneLine' type only. Cannot be
    specified together with 'phoneNumber' parameter.
    """
    

class CreateForwardingNumberResponseLabel(Enum):
    """ Forwarding/Call flip number title """
    
    Business_Mobile_Phone = 'Business Mobile Phone'

class CreateForwardingNumberResponseFeaturesItem(Enum):
    CallFlip = 'CallFlip'
    CallForwarding = 'CallForwarding'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateForwardingNumberResponseDevice(DataClassJsonMixin):
    """ Forwarding device information """
    
    id: Optional[str] = None
    """ Internal identifier of the other extension device """
    

class CreateForwardingNumberResponseType(Enum):
    """ Forwarding phone number type """
    
    Home = 'Home'
    Mobile = 'Mobile'
    Work = 'Work'
    PhoneLine = 'PhoneLine'
    Outage = 'Outage'
    Other = 'Other'
    BusinessMobilePhone = 'BusinessMobilePhone'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateForwardingNumberResponse(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a forwarding/call flip phone number """
    
    uri: Optional[str] = None
    """ Canonical URI of a forwarding/call flip phone number """
    
    phone_number: Optional[str] = None
    """ Forwarding/Call flip phone number """
    
    label: Optional[CreateForwardingNumberResponseLabel] = None
    """ Forwarding/Call flip number title """
    
    features: Optional[List[CreateForwardingNumberResponseFeaturesItem]] = None
    """ Type of option this phone number is used for. Multiple values are accepted """
    
    flip_number: Optional[str] = None
    """ Number assigned to the call flip phone number, corresponds to the shortcut dial number """
    
    device: Optional[CreateForwardingNumberResponseDevice] = None
    """ Forwarding device information """
    
    type: Optional[CreateForwardingNumberResponseType] = None
    """ Forwarding phone number type """
    

class ReadForwardingNumberResponseLabel(Enum):
    """ Forwarding/Call flip number title """
    
    Business_Mobile_Phone = 'Business Mobile Phone'

class ReadForwardingNumberResponseFeaturesItem(Enum):
    CallFlip = 'CallFlip'
    CallForwarding = 'CallForwarding'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadForwardingNumberResponseDevice(DataClassJsonMixin):
    """ Forwarding device information """
    
    id: Optional[str] = None
    """ Internal identifier of the other extension device """
    

class ReadForwardingNumberResponseType(Enum):
    """ Forwarding phone number type """
    
    Home = 'Home'
    Mobile = 'Mobile'
    Work = 'Work'
    PhoneLine = 'PhoneLine'
    Outage = 'Outage'
    Other = 'Other'
    BusinessMobilePhone = 'BusinessMobilePhone'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ReadForwardingNumberResponse(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a forwarding/call flip phone number """
    
    uri: Optional[str] = None
    """ Canonical URI of a forwarding/call flip phone number """
    
    phone_number: Optional[str] = None
    """ Forwarding/Call flip phone number """
    
    label: Optional[ReadForwardingNumberResponseLabel] = None
    """ Forwarding/Call flip number title """
    
    features: Optional[List[ReadForwardingNumberResponseFeaturesItem]] = None
    """ Type of option this phone number is used for. Multiple values are accepted """
    
    flip_number: Optional[str] = None
    """ Number assigned to the call flip phone number, corresponds to the shortcut dial number """
    
    device: Optional[ReadForwardingNumberResponseDevice] = None
    """ Forwarding device information """
    
    type: Optional[ReadForwardingNumberResponseType] = None
    """ Forwarding phone number type """
    

class UpdateForwardingNumberRequestLabel(Enum):
    """ Forwarding/Call flip number title """
    
    Business_Mobile_Phone = 'Business Mobile Phone'

class UpdateForwardingNumberRequestType(Enum):
    """ Forwarding phone number type """
    
    Home = 'Home'
    Mobile = 'Mobile'
    Work = 'Work'
    PhoneLine = 'PhoneLine'
    Outage = 'Outage'
    Other = 'Other'
    BusinessMobilePhone = 'BusinessMobilePhone'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateForwardingNumberRequest(DataClassJsonMixin):
    phone_number: Optional[str] = None
    """ Forwarding/Call flip phone number """
    
    label: Optional[UpdateForwardingNumberRequestLabel] = None
    """ Forwarding/Call flip number title """
    
    flip_number: Optional[str] = None
    """ Number assigned to the call flip phone number, corresponds to the shortcut dial number """
    
    type: Optional[UpdateForwardingNumberRequestType] = None
    """ Forwarding phone number type """
    

class UpdateForwardingNumberResponseLabel(Enum):
    """ Forwarding/Call flip number title """
    
    Business_Mobile_Phone = 'Business Mobile Phone'

class UpdateForwardingNumberResponseFeaturesItem(Enum):
    CallFlip = 'CallFlip'
    CallForwarding = 'CallForwarding'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateForwardingNumberResponseDevice(DataClassJsonMixin):
    """ Forwarding device information """
    
    id: Optional[str] = None
    """ Internal identifier of the other extension device """
    

class UpdateForwardingNumberResponseType(Enum):
    """ Forwarding phone number type """
    
    Home = 'Home'
    Mobile = 'Mobile'
    Work = 'Work'
    PhoneLine = 'PhoneLine'
    Outage = 'Outage'
    Other = 'Other'
    BusinessMobilePhone = 'BusinessMobilePhone'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class UpdateForwardingNumberResponse(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a forwarding/call flip phone number """
    
    uri: Optional[str] = None
    """ Canonical URI of a forwarding/call flip phone number """
    
    phone_number: Optional[str] = None
    """ Forwarding/Call flip phone number """
    
    label: Optional[UpdateForwardingNumberResponseLabel] = None
    """ Forwarding/Call flip number title """
    
    features: Optional[List[UpdateForwardingNumberResponseFeaturesItem]] = None
    """ Type of option this phone number is used for. Multiple values are accepted """
    
    flip_number: Optional[str] = None
    """ Number assigned to the call flip phone number, corresponds to the shortcut dial number """
    
    device: Optional[UpdateForwardingNumberResponseDevice] = None
    """ Forwarding device information """
    
    type: Optional[UpdateForwardingNumberResponseType] = None
    """ Forwarding phone number type """
    

class ListAnsweringRulesView(Enum):
    Detailed = 'Detailed'
    Simple = 'Simple'

class ListAnsweringRulesResponseRecordsItemType(Enum):
    """ Type of an answering rule """
    
    BusinessHours = 'BusinessHours'
    AfterHours = 'AfterHours'
    Custom = 'Custom'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListAnsweringRulesResponseRecordsItemSharedLines(DataClassJsonMixin):
    """ SharedLines call handling action settings """
    
    timeout: Optional[int] = None
    """ Number of seconds to wait before forwarding unanswered calls. The value range is 10 - 80 """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListAnsweringRulesResponseRecordsItem(DataClassJsonMixin):
    uri: Optional[str] = None
    """
    Canonical URI to an answering rule resource
    
    Example: `https://platform.ringcentral.com/restapi/v1.0/account/240913004/extension/240972004/answering-rule/business-hours-rule`
    """
    
    id: Optional[str] = None
    """
    Internal identifier of an asnwering rule
    
    Example: `business-hours-rule`
    """
    
    type: Optional[ListAnsweringRulesResponseRecordsItemType] = None
    """ Type of an answering rule """
    
    name: Optional[str] = None
    """ Name of an answering rule specified by user """
    
    enabled: Optional[bool] = None
    """ Specifies if an answering rule is active or inactive """
    
    shared_lines: Optional[ListAnsweringRulesResponseRecordsItemSharedLines] = None
    """ SharedLines call handling action settings """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListAnsweringRulesResponsePaging(DataClassJsonMixin):
    page: Optional[int] = None
    """
    The current page number. 1-indexed, so the first page is 1 by default. May be omitted if result
    is empty (because non-existent page was specified or perPage=0 was requested)
    
    Example: `1`
    """
    
    total_pages: Optional[int] = None
    """
    The total number of pages in a dataset.
    
    Example: `1`
    """
    
    per_page: Optional[int] = None
    """
    Current page size, describes how many items are in each page. Default value is 100. Maximum
    value is 1000. If perPage value in the request is greater than 1000, the maximum value (1000)
    is applied
    
    Example: `100`
    """
    
    total_elements: Optional[int] = None
    """
    The total number of elements in a dataset.
    
    Example: `1`
    """
    
    page_start: Optional[int] = None
    """
    The zero-based number of the first element on the current page. Omitted if the page is omitted
    or result is empty
    
    Example: `0`
    """
    
    page_end: Optional[int] = None
    """
    The zero-based index of the last element on the current page. Omitted if the page is omitted or
    result is empty
    
    Example: `0`
    """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListAnsweringRulesResponseNavigationFirstPage(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Example: `https://platform.ringcentral.com/restapi/v1.0/account/240913004/extension/240972004/answering-rule?page=1&perPage=100` """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListAnsweringRulesResponseNavigationNextPage(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Example: `https://platform.ringcentral.com/restapi/v1.0/account/240913004/extension/240972004/answering-rule?page=1&perPage=100` """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListAnsweringRulesResponseNavigationPreviousPage(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Example: `https://platform.ringcentral.com/restapi/v1.0/account/240913004/extension/240972004/answering-rule?page=1&perPage=100` """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListAnsweringRulesResponseNavigationLastPage(DataClassJsonMixin):
    uri: Optional[str] = None
    """ Example: `https://platform.ringcentral.com/restapi/v1.0/account/240913004/extension/240972004/answering-rule?page=1&perPage=100` """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListAnsweringRulesResponseNavigation(DataClassJsonMixin):
    first_page: Optional[ListAnsweringRulesResponseNavigationFirstPage] = None
    next_page: Optional[ListAnsweringRulesResponseNavigationNextPage] = None
    previous_page: Optional[ListAnsweringRulesResponseNavigationPreviousPage] = None
    last_page: Optional[ListAnsweringRulesResponseNavigationLastPage] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class ListAnsweringRulesResponse(DataClassJsonMixin):
    uri: Optional[str] = None
    """
    Canonical URI of an answering rule list resource
    
    Example: `https://platform.ringcentral.com/restapi/v1.0/account/240913004/extension/240972004/answering-rule?page=1&perPage=100`
    """
    
    records: Optional[List[ListAnsweringRulesResponseRecordsItem]] = None
    """ List of answering rules """
    
    paging: Optional[ListAnsweringRulesResponsePaging] = None
    navigation: Optional[ListAnsweringRulesResponseNavigation] = None

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestCallersItem(DataClassJsonMixin):
    caller_id: Optional[str] = None
    """ Phone number of a caller """
    
    name: Optional[str] = None
    """ Contact name of a caller """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestCalledNumbersItem(DataClassJsonMixin):
    phone_number: Optional[str] = None
    """ Called phone number """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestScheduleWeeklyRangesMondayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestScheduleWeeklyRangesTuesdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestScheduleWeeklyRangesWednesdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestScheduleWeeklyRangesThursdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestScheduleWeeklyRangesFridayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestScheduleWeeklyRangesSaturdayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestScheduleWeeklyRangesSundayItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """ Time in format hh:mm """
    
    to: Optional[str] = None
    """ Time in format hh:mm """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestScheduleWeeklyRanges(DataClassJsonMixin):
    """ Weekly schedule """
    
    monday: Optional[List[CreateAnsweringRuleRequestScheduleWeeklyRangesMondayItem]] = None
    """ Time intervals for a particular day """
    
    tuesday: Optional[List[CreateAnsweringRuleRequestScheduleWeeklyRangesTuesdayItem]] = None
    """ Time intervals for a particular day """
    
    wednesday: Optional[List[CreateAnsweringRuleRequestScheduleWeeklyRangesWednesdayItem]] = None
    """ Time intervals for a particular day """
    
    thursday: Optional[List[CreateAnsweringRuleRequestScheduleWeeklyRangesThursdayItem]] = None
    """ Time intervals for a particular day """
    
    friday: Optional[List[CreateAnsweringRuleRequestScheduleWeeklyRangesFridayItem]] = None
    """ Time intervals for a particular day """
    
    saturday: Optional[List[CreateAnsweringRuleRequestScheduleWeeklyRangesSaturdayItem]] = None
    """ Time intervals for a particular day """
    
    sunday: Optional[List[CreateAnsweringRuleRequestScheduleWeeklyRangesSundayItem]] = None
    """ Time intervals for a particular day """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestScheduleRangesItem(DataClassJsonMixin):
    from_: Optional[str] = field(metadata=config(field_name='from'), default=None)
    """
    Starting datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601), for example
    *2018-10-29T14:00:00*, *2018-10-29T14:00:00Z*, *2018-10-29T14:00:00+0100*
    """
    
    to: Optional[str] = None
    """
    Ending datetime in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601), for example
    *2018-10-29T14:00:00*, *2018-10-29T14:00:00Z*, *2018-10-29T14:00:00+0100*
    """
    

class CreateAnsweringRuleRequestScheduleRef(Enum):
    """
    The user's schedule specified for business hours or after hours; it can also be set/retrieved
    calling the corresponding method
    
    Generated by Python OpenAPI Parser
    """
    
    BusinessHours = 'BusinessHours'
    AfterHours = 'AfterHours'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestSchedule(DataClassJsonMixin):
    """ Schedule when an answering rule should be applied """
    
    weekly_ranges: Optional[CreateAnsweringRuleRequestScheduleWeeklyRanges] = None
    """ Weekly schedule """
    
    ranges: Optional[List[CreateAnsweringRuleRequestScheduleRangesItem]] = None
    """ Specific data ranges """
    
    ref: Optional[CreateAnsweringRuleRequestScheduleRef] = None
    """
    The user's schedule specified for business hours or after hours; it can also be set/retrieved
    calling the corresponding method
    """
    

class CreateAnsweringRuleRequestCallHandlingAction(Enum):
    """ Specifies how incoming calls are forwarded """
    
    ForwardCalls = 'ForwardCalls'
    UnconditionalForwarding = 'UnconditionalForwarding'
    AgentQueue = 'AgentQueue'
    TransferToExtension = 'TransferToExtension'
    TakeMessagesOnly = 'TakeMessagesOnly'
    PlayAnnouncementOnly = 'PlayAnnouncementOnly'
    SharedLines = 'SharedLines'

class CreateAnsweringRuleRequestForwardingRingingMode(Enum):
    """
    Specifies the order in which forwarding numbers ring. 'Sequentially' means that forwarding
    numbers are ringing one at a time, in order of priority. 'Simultaneously' means that forwarding
    numbers are ring all at the same time
    
    Generated by Python OpenAPI Parser
    """
    
    Sequentially = 'Sequentially'
    Simultaneously = 'Simultaneously'

class CreateAnsweringRuleRequestForwardingRulesItemForwardingNumbersItemLabel(Enum):
    """ Forwarding/Call flip number title """
    
    Business_Mobile_Phone = 'Business Mobile Phone'

class CreateAnsweringRuleRequestForwardingRulesItemForwardingNumbersItemType(Enum):
    """ Type of a forwarding number """
    
    Home = 'Home'
    Mobile = 'Mobile'
    Work = 'Work'
    PhoneLine = 'PhoneLine'
    Outage = 'Outage'
    Other = 'Other'
    BusinessMobilePhone = 'BusinessMobilePhone'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestForwardingRulesItemForwardingNumbersItem(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of a forwarding number """
    
    uri: Optional[str] = None
    """ Canonical URI of a forwarding/call flip phone number """
    
    phone_number: Optional[str] = None
    """ Forwarding/Call flip phone number """
    
    label: Optional[CreateAnsweringRuleRequestForwardingRulesItemForwardingNumbersItemLabel] = None
    """ Forwarding/Call flip number title """
    
    type: Optional[CreateAnsweringRuleRequestForwardingRulesItemForwardingNumbersItemType] = None
    """ Type of a forwarding number """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestForwardingRulesItem(DataClassJsonMixin):
    index: Optional[int] = None
    """ Forwarding number (or group) ordinal """
    
    ring_count: Optional[int] = None
    """ Number of rings for a forwarding number (or group) """
    
    enabled: Optional[bool] = None
    """ Forwarding number status. Returned only if `showInactiveNumbers` is set to `true` """
    
    forwarding_numbers: Optional[List[CreateAnsweringRuleRequestForwardingRulesItemForwardingNumbersItem]] = None
    """ Forwarding number (or group) data """
    

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestForwarding(DataClassJsonMixin):
    """
    Forwarding parameters. Returned if 'ForwardCalls' is specified in 'callHandlingAction'. These
    settings determine the forwarding numbers to which the call will be forwarded
    
    Generated by Python OpenAPI Parser
    """
    
    notify_my_soft_phones: Optional[bool] = None
    """
    Specifies if the user's softphone(s) are notified before forwarding the incoming call to desk
    phones and forwarding numbers
    """
    
    notify_admin_soft_phones: Optional[bool] = None
    """
    Specifies if the administrator's softphone is notified before forwarding the incoming call to
    desk phones and forwarding numbers. The default value is 'False'
    """
    
    soft_phones_ring_count: Optional[int] = None
    """ Number of rings before forwarding starts """
    
    ringing_mode: Optional[CreateAnsweringRuleRequestForwardingRingingMode] = None
    """
    Specifies the order in which forwarding numbers ring. 'Sequentially' means that forwarding
    numbers are ringing one at a time, in order of priority. 'Simultaneously' means that forwarding
    numbers are ring all at the same time
    """
    
    rules: Optional[List[CreateAnsweringRuleRequestForwardingRulesItem]] = None
    """ Information on a call forwarding rule """
    
    mobile_timeout: Optional[bool] = None
    """ Specifies if mobile timeout is activated for the rule """
    

class CreateAnsweringRuleRequestUnconditionalForwardingAction(Enum):
    """ Event that initiates forwarding to the specified phone number """
    
    HoldTimeExpiration = 'HoldTimeExpiration'
    MaxCallers = 'MaxCallers'
    NoAnswer = 'NoAnswer'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestUnconditionalForwarding(DataClassJsonMixin):
    """
    Unconditional forwarding parameters. Returned if 'UnconditionalForwarding' is specified in
    'callHandlingAction'
    
    Generated by Python OpenAPI Parser
    """
    
    phone_number: Optional[str] = None
    """
    Phone number to which the call is forwarded. In addition to common e.164 format, the following
    number patterns are supported: 11xxxxxxxxxxx, 444xxxxxxxxxxx, 616xxxxxxxxxxx; where xxxxxxxxxxx
    is a phone number in e.164 format (without '+' sign)
    """
    
    action: Optional[CreateAnsweringRuleRequestUnconditionalForwardingAction] = None
    """ Event that initiates forwarding to the specified phone number """
    

class CreateAnsweringRuleRequestQueueTransferMode(Enum):
    """ Specifies how calls are transferred to group members """
    
    Rotating = 'Rotating'
    Simultaneous = 'Simultaneous'
    FixedOrder = 'FixedOrder'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestQueueTransferItemExtension(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of an extension the call is transferred to """
    
    name: Optional[str] = None
    """ Extension name """
    
    extension_number: Optional[str] = None
    """ Extension number """
    

class CreateAnsweringRuleRequestQueueTransferItemAction(Enum):
    """ Event that initiates transferring to the specified extension """
    
    HoldTimeExpiration = 'HoldTimeExpiration'
    MaxCallers = 'MaxCallers'
    NoAnswer = 'NoAnswer'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestQueueTransferItem(DataClassJsonMixin):
    extension: Optional[CreateAnsweringRuleRequestQueueTransferItemExtension] = None
    action: Optional[CreateAnsweringRuleRequestQueueTransferItemAction] = None
    """ Event that initiates transferring to the specified extension """
    

class CreateAnsweringRuleRequestQueueNoAnswerAction(Enum):
    """
    Specifies the type of action to be taken if: members are available but no one answers, or all
    members are busy/unavailable. This option is available for Business hours only. For
    simultaneous transfer mode only 'WaitPrimaryMembers' and 'WaitPrimaryAndOverflowMembers' are
    supported
    
    Generated by Python OpenAPI Parser
    """
    
    WaitPrimaryMembers = 'WaitPrimaryMembers'
    WaitPrimaryAndOverflowMembers = 'WaitPrimaryAndOverflowMembers'
    Voicemail = 'Voicemail'
    TransferToExtension = 'TransferToExtension'
    UnconditionalForwarding = 'UnconditionalForwarding'

@dataclass_json(letter_case=LetterCase.CAMEL)
@dataclass
class CreateAnsweringRuleRequestQueueFixedOrderAgentsItemExtension(DataClassJsonMixin):
    id: Optional[str] = None
    """ Internal identifier of an extension """
    
    uri: Optional[str] = None
    """ Canonical URI of an extension """
    
    extension_number: Optional[str] = None
    """ Number of department extension """
    
