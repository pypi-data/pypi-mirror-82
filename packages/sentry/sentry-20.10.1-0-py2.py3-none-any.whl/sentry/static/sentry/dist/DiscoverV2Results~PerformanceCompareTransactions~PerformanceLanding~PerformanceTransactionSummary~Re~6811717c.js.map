{"version":3,"sources":["webpack:///./app/components/charts/styles.tsx","webpack:///./app/actionCreators/events.tsx","webpack:///./app/components/charts/eventsRequest.tsx","webpack:///./app/utils/discover/charts.tsx","webpack:////workspace/node_modules/lodash/omitBy.js","webpack:///./app/components/charts/transitionChart.tsx","webpack:///./app/components/charts/transparentLoadingMask.tsx","webpack:////workspace/node_modules/lodash/negate.js","webpack:///./app/components/charts/optionSelector.tsx"],"names":["ChartControls","space","p","theme","borderLight","SectionHeading","gray600","fontSizeMedium","SectionValue","InlineContainer","doEventsRequest","api","organization","project","environment","period","start","end","interval","includePrevious","query","yAxis","field","keyTransactions","topEvents","orderby","shouldDoublePeriod","canIncludePreviousPeriod","urlQuery","Object","fromEntries","entries","filter","periodObj","getPeriod","requestPromise","org","slug","getBaseUrl","fetchTagFacets","orgSlug","a","urlParams","pick","values","URL_PARAM","queryOption","fetchTotalCount","then","res","count","propNamesToIgnore","omitIgnoredProps","props","omitBy","_value","key","includes","EventsRequest","state","reloading","loading","errored","timeseriesData","unmounting","fetchData","confirmedQuery","setState","clear","responseJSON","detail","addErrorMessage","t","getData","data","hasPreviousPeriod","dataMiddleIndex","Math","floor","length","current","slice","previous","this","prevProps","isEqual","getName","timestamp","map","i","countArray","name","value","reduce","acc","seriesName","previousSeriesName","calculateTotalsPerTimestamp","_timestamp","_countArray","response","totals","includeTransformedData","includeTimeAggregation","timeAggregationSeriesName","transformTimeseriesData","currentSeriesName","allData","originalData","originalPreviousData","previousData","transformPreviousPeriodData","timeAggregatedData","transformAggregatedTimeseries","children","showLoading","data-test-id","undefined","results","keys","seriesData","transformed","order","sort","b","item","processData","allTimeseriesData","originalTimeseriesData","timeseriesTotals","originalPreviousTimeseriesData","previousTimeseriesData","React","PureComponent","defaultProps","limit","tooltipFormatter","aggregateOutputType","toLocaleString","formatPercentage","getDuration","toString","axisLabelFormatter","abbreviation","formatAbbreviatedNumber","axisDuration","WEEK","label","toFixed","DAY","HOUR","MINUTE","SECOND","baseIteratee","negate","pickBy","module","exports","object","predicate","TransitionChart","prevReloading","prevLoading","height","Fragment","String","nextReloading","nextLoading","Component","TransparentLoadingMask","LoadingMask","visible","TypeError","args","arguments","call","apply","OptionSelector","options","onChange","selected","title","menuWidth","selectedOption","find","opt","MenuContainer","alwaysRenderMenu","isOpen","getMenuProps","getActorProps","StyledDropdownButton","size","StyledDropdownBubble","alignMenu","width","blendWithActor","blendCorner","onSelect","eventKey","disabled","isActive","tooltip","containerDisplayMode","DropdownButton","zIndex","dropdownAutocomplete","actor","gray700","DropdownBubble"],"mappings":"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","file":"DiscoverV2Results~PerformanceCompareTransactions~PerformanceLanding~PerformanceTransactionSummary~Re~6811717c.js","sourcesContent":["import styled from '@emotion/styled';\n\nimport space from 'app/styles/space';\n\nexport const ChartControls = styled('div')`\n  display: flex;\n  justify-content: space-between;\n  padding: ${space(1)} ${space(3)};\n  border-top: 1px solid ${p => p.theme.borderLight};\n`;\n\nexport const SubHeading = styled('h3')`\n  font-size: ${p => p.theme.fontSizeLarge};\n  font-weight: normal;\n  color: ${p => p.theme.gray800};\n  margin: 0;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n`;\n\nexport const SectionHeading = styled('h4')`\n  display: inline-grid;\n  grid-auto-flow: column;\n  grid-gap: ${space(1)};\n  align-items: center;\n  color: ${p => p.theme.gray600};\n  font-size: ${p => p.theme.fontSizeMedium};\n  margin: ${space(1)} 0;\n  line-height: 1.3;\n`;\n\nexport const SectionValue = styled('span')`\n  color: ${p => p.theme.gray600};\n  font-size: ${p => p.theme.fontSizeMedium};\n  margin-right: ${space(1)};\n`;\n\nexport const InlineContainer = styled('div')`\n  display: flex;\n  align-items: center;\n  margin-right: ${space(2)};\n\n  > h4 {\n    margin-right: ${space(1)};\n  }\n\n  &:last-child {\n    margin-right: 0;\n  }\n`;\n","import {LocationDescriptor} from 'history';\nimport pick from 'lodash/pick';\n\nimport {Client} from 'app/api';\nimport {URL_PARAM} from 'app/constants/globalSelectionHeader';\nimport {canIncludePreviousPeriod} from 'app/components/charts/utils';\nimport {getPeriod} from 'app/utils/getPeriod';\nimport {\n  EventsStats,\n  DateString,\n  OrganizationSummary,\n  MultiSeriesEventsStats,\n} from 'app/types';\n\nfunction getBaseUrl(org: OrganizationSummary, keyTransactions: boolean | undefined) {\n  if (keyTransactions) {\n    return `/organizations/${org.slug}/key-transactions-stats/`;\n  }\n\n  return `/organizations/${org.slug}/events-stats/`;\n}\n\ntype Options = {\n  organization: OrganizationSummary;\n  project?: number[];\n  environment?: string[];\n  period?: string;\n  start?: DateString;\n  end?: DateString;\n  interval?: string;\n  includePrevious?: boolean;\n  limit?: number;\n  query?: string;\n  yAxis?: string | string[];\n  field?: string[];\n  keyTransactions?: boolean;\n  topEvents?: number;\n  orderby?: string;\n};\n\n/**\n * Make requests to `events-stats` endpoint\n *\n * @param {Object} api API client instance\n * @param {Object} options Request parameters\n * @param {Object} options.organization Organization object\n * @param {Number[]} options.project List of project ids\n * @param {String[]} options.environment List of environments to query for\n * @param {String} options.period Time period to query for, in the format: <integer><units> where units are \"d\" or \"h\"\n * @param {String} options.interval Time interval to group results in, in the format: <integer><units> where units are \"d\", \"h\", \"m\", \"s\"\n * @param {Boolean} options.includePrevious Should request also return reqsults for previous period?\n * @param {Number} options.limit The number of rows to return\n * @param {String} options.query Search query\n */\nexport const doEventsRequest = (\n  api: Client,\n  {\n    organization,\n    project,\n    environment,\n    period,\n    start,\n    end,\n    interval,\n    includePrevious,\n    query,\n    yAxis,\n    field,\n    keyTransactions,\n    topEvents,\n    orderby,\n  }: Options\n): Promise<EventsStats | MultiSeriesEventsStats> => {\n  const shouldDoublePeriod = canIncludePreviousPeriod(includePrevious, period);\n  const urlQuery = Object.fromEntries(\n    Object.entries({\n      interval,\n      project,\n      environment,\n      query,\n      yAxis,\n      field,\n      topEvents,\n      orderby,\n    }).filter(([, value]) => typeof value !== 'undefined')\n  );\n\n  // Doubling period for absolute dates is not accurate unless starting and\n  // ending times are the same (at least for daily intervals). This is\n  // the tradeoff for now.\n  const periodObj = getPeriod({period, start, end}, {shouldDoublePeriod});\n\n  return api.requestPromise(`${getBaseUrl(organization, keyTransactions)}`, {\n    query: {\n      ...urlQuery,\n      ...periodObj,\n    },\n  });\n};\n\nexport type EventQuery = {\n  field: string[];\n  project?: string | string[];\n  sort?: string | string[];\n  query: string;\n  per_page?: number;\n  referrer?: string;\n};\n\nexport type TagSegment = {\n  count: number;\n  name: string;\n  value: string;\n  url: LocationDescriptor;\n  isOther?: boolean;\n  key?: string;\n};\n\nexport type Tag = {\n  key: string;\n  topValues: Array<TagSegment>;\n};\n\n/**\n * Fetches tag facets for a query\n */\nexport async function fetchTagFacets(\n  api: Client,\n  orgSlug: string,\n  query: EventQuery\n): Promise<Tag[]> {\n  const urlParams = pick(query, Object.values(URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  return api.requestPromise(`/organizations/${orgSlug}/events-facets/`, {\n    query: queryOption,\n  });\n}\n\n/**\n * Fetches total count of events for a given query\n */\nexport async function fetchTotalCount(\n  api: Client,\n  orgSlug: String,\n  query: EventQuery\n): Promise<number> {\n  const urlParams = pick(query, Object.values(URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  type Response = {\n    count: number;\n  };\n\n  return api\n    .requestPromise(`/organizations/${orgSlug}/events-meta/`, {\n      query: queryOption,\n    })\n    .then((res: Response) => res.count);\n}\n","import isEqual from 'lodash/isEqual';\nimport omitBy from 'lodash/omitBy';\nimport PropTypes from 'prop-types';\nimport React from 'react';\n\nimport {\n  DateString,\n  EventsStats,\n  EventsStatsData,\n  OrganizationSummary,\n  MultiSeriesEventsStats,\n} from 'app/types';\nimport {Series, SeriesDataUnit} from 'app/types/echarts';\nimport LoadingPanel from 'app/components/charts/loadingPanel';\nimport {Client} from 'app/api';\nimport {doEventsRequest} from 'app/actionCreators/events';\nimport {canIncludePreviousPeriod} from 'app/components/charts/utils';\nimport {addErrorMessage} from 'app/actionCreators/indicator';\nimport {t} from 'app/locale';\nimport SentryTypes from 'app/sentryTypes';\n\nexport type TimeSeriesData = {\n  // timeseries data\n  timeseriesData?: Series[];\n  allTimeseriesData?: EventsStatsData;\n  originalTimeseriesData?: EventsStatsData;\n  timeseriesTotals?: {count: number};\n  originalPreviousTimeseriesData?: EventsStatsData | null;\n  previousTimeseriesData?: Series | null;\n  timeAggregatedData?: Series | {};\n};\n\ntype LoadingStatus = {\n  loading: boolean;\n  reloading: boolean;\n  /**\n   * Whether there was an error retrieving data\n   */\n  errored: boolean;\n};\n\n// Chart format for multiple series.\ntype MultiSeriesResults = Series[];\n\ntype RenderProps = LoadingStatus & TimeSeriesData & {results?: MultiSeriesResults};\n\ntype DefaultProps = {\n  /**\n   * Relative time period for query.\n   *\n   * Use `start` and `end` for absolute dates.\n   *\n   * e.g. 24h, 7d, 30d\n   */\n  period?: string;\n  /**\n   * Absolute start date for query\n   */\n  start?: DateString;\n  /**\n   * Absolute end date for query\n   */\n  end?: DateString;\n  /**\n   * Interval to group results in\n   *\n   * e.g. 1d, 1h, 1m, 1s\n   */\n  interval: string;\n  /**\n   * number of rows to return\n   */\n  limit: number;\n  /**\n   * The query string to search events by\n   */\n  query: string;\n  /**\n   * Include data for previous period\n   */\n  includePrevious: boolean;\n  /**\n   * Transform the response data to be something ingestible by charts\n   */\n  includeTransformedData: boolean;\n};\n\ntype EventsRequestPartialProps = {\n  /**\n   * API client instance\n   */\n  api: Client;\n  organization: OrganizationSummary;\n  /**\n   * List of project ids to query\n   */\n  project?: number[];\n  /**\n   * List of environments to query\n   */\n  environment?: string[];\n  /**\n   * List of fields to group with when doing a topEvents request.\n   */\n  field?: string[];\n  /**\n   * Initial loading state\n   */\n  loading?: boolean;\n  /**\n   * Should loading be shown.\n   */\n  showLoading?: boolean;\n  /**\n   * The yAxis being plotted. If multiple yAxis are requested,\n   * the child render function will be called with `results`\n   */\n  yAxis?: string | string[];\n  /**\n   * Name used for display current series data set tooltip\n   */\n  currentSeriesName?: string;\n  previousSeriesName?: string;\n  children: (renderProps: RenderProps) => React.ReactNode;\n  /**\n   * Determines if the \"key transactions\" version of the event-stats endpoint should be used\n   */\n  keyTransactions?: boolean;\n  /**\n   * The number of top results to get. When set a multi-series result will be returned\n   * in the `results` child render function.\n   */\n  topEvents?: number;\n  /**\n   * How to order results when getting top events.\n   */\n  orderby?: string;\n  /**\n   * Discover needs confirmation to run >30 day >10 project queries,\n   * optional and when not passed confirmation is not required.\n   */\n  confirmedQuery?: boolean;\n};\n\ntype TimeAggregationProps =\n  | {includeTimeAggregation: true; timeAggregationSeriesName: string}\n  | {includeTimeAggregation?: false; timeAggregationSeriesName?: undefined};\n\ntype EventsRequestProps = DefaultProps & TimeAggregationProps & EventsRequestPartialProps;\n\ntype EventsRequestState = {\n  reloading: boolean;\n  errored: boolean;\n  timeseriesData: null | EventsStats | MultiSeriesEventsStats;\n};\n\nconst propNamesToIgnore = ['api', 'children', 'organization', 'loading'];\nconst omitIgnoredProps = (props: EventsRequestProps) =>\n  omitBy(props, (_value, key) => propNamesToIgnore.includes(key));\n\nfunction isMultiSeriesStats(\n  data: MultiSeriesEventsStats | EventsStats | null\n): data is MultiSeriesEventsStats {\n  return data !== null && data.data === undefined && data.totals === undefined;\n}\n\nclass EventsRequest extends React.PureComponent<EventsRequestProps, EventsRequestState> {\n  static propTypes = {\n    api: PropTypes.object.isRequired,\n    organization: SentryTypes.Organization.isRequired,\n    project: PropTypes.arrayOf(PropTypes.number),\n    environment: PropTypes.arrayOf(PropTypes.string),\n    period: PropTypes.string,\n    start: PropTypes.instanceOf(Date),\n    end: PropTypes.instanceOf(Date),\n    interval: PropTypes.string,\n    includePrevious: PropTypes.bool,\n    limit: PropTypes.number,\n    query: PropTypes.string,\n    includeTransformedData: PropTypes.bool,\n\n    /**\n     * Include a dataset transform that will aggregate count values for each\n     * timestamp. Be sure to supply a name to `timeAggregationSeriesName`\n     */\n    includeTimeAggregation: PropTypes.bool,\n\n    /**\n     * Name of series of aggregated timeseries\n     */\n    timeAggregationSeriesName: PropTypes.string,\n    loading: PropTypes.bool,\n    errored: PropTypes.bool,\n    showLoading: PropTypes.bool,\n    currentSeriesName: PropTypes.string,\n    yAxis: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n\n    field: PropTypes.arrayOf(PropTypes.string),\n    keyTransactions: PropTypes.bool,\n    topEvents: PropTypes.number,\n    orderby: PropTypes.string,\n\n    confirmedQuery: PropTypes.bool,\n  };\n\n  static defaultProps: DefaultProps = {\n    period: undefined,\n    start: null,\n    end: null,\n    interval: '1d',\n    limit: 15,\n    query: '',\n    includePrevious: true,\n    includeTransformedData: true,\n  };\n\n  state: EventsRequestState = {\n    reloading: !!this.props.loading,\n    errored: false,\n    timeseriesData: null,\n  };\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentDidUpdate(prevProps: EventsRequestProps) {\n    if (isEqual(omitIgnoredProps(prevProps), omitIgnoredProps(this.props))) {\n      return;\n    }\n    this.fetchData();\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n  }\n\n  private unmounting: boolean = false;\n\n  fetchData = async () => {\n    const {api, confirmedQuery, ...props} = this.props;\n    let timeseriesData: EventsStats | MultiSeriesEventsStats | null = null;\n\n    if (confirmedQuery === false) {\n      return;\n    }\n\n    this.setState(state => ({\n      reloading: state.timeseriesData !== null,\n      errored: false,\n    }));\n\n    try {\n      api.clear();\n      timeseriesData = await doEventsRequest(api, props);\n    } catch (resp) {\n      if (resp && resp.responseJSON && resp.responseJSON.detail) {\n        addErrorMessage(resp.responseJSON.detail);\n      } else {\n        addErrorMessage(t('Error loading chart data'));\n      }\n      this.setState({\n        errored: true,\n      });\n    }\n\n    if (this.unmounting) {\n      return;\n    }\n\n    this.setState({\n      reloading: false,\n      timeseriesData,\n    });\n  };\n\n  /**\n   * Retrieves data set for the current period (since data can potentially\n   * contain previous period's data), as well as the previous period if\n   * possible.\n   *\n   * Returns `null` if data does not exist\n   */\n  getData = (\n    data: EventsStatsData\n  ): {previous: EventsStatsData | null; current: EventsStatsData} => {\n    const {period, includePrevious} = this.props;\n\n    const hasPreviousPeriod = canIncludePreviousPeriod(includePrevious, period);\n    // Take the floor just in case, but data should always be divisible by 2\n    const dataMiddleIndex = Math.floor(data.length / 2);\n    return {\n      current: hasPreviousPeriod ? data.slice(dataMiddleIndex) : data,\n      previous: hasPreviousPeriod ? data.slice(0, dataMiddleIndex) : null,\n    };\n  };\n\n  // This aggregates all values per `timestamp`\n  calculateTotalsPerTimestamp(\n    data: EventsStatsData,\n    getName: (\n      timestamp: number,\n      countArray: {count: number}[],\n      i: number\n    ) => number = timestamp => timestamp * 1000\n  ): SeriesDataUnit[] {\n    return data.map(([timestamp, countArray], i) => ({\n      name: getName(timestamp, countArray, i),\n      value: countArray.reduce((acc, {count}) => acc + count, 0),\n    }));\n  }\n\n  /**\n   * Get previous period data, but transform timestamps so that data fits unto\n   * the current period's data axis\n   */\n  transformPreviousPeriodData(\n    current: EventsStatsData,\n    previous: EventsStatsData | null\n  ): Series | null {\n    // Need the current period data array so we can take the timestamp\n    // so we can be sure the data lines up\n    if (!previous) {\n      return null;\n    }\n\n    return {\n      seriesName: this.props.previousSeriesName ?? 'Previous',\n      data: this.calculateTotalsPerTimestamp(\n        previous,\n        (_timestamp, _countArray, i) => current[i][0] * 1000\n      ),\n    };\n  }\n\n  /**\n   * Aggregate all counts for each time stamp\n   */\n  transformAggregatedTimeseries(data: EventsStatsData, seriesName: string = ''): Series {\n    return {\n      seriesName,\n      data: this.calculateTotalsPerTimestamp(data),\n    };\n  }\n\n  /**\n   * Transforms query response into timeseries data to be used in a chart\n   */\n  transformTimeseriesData(data: EventsStatsData, seriesName?: string): Series[] {\n    return [\n      {\n        seriesName: seriesName || 'Current',\n        data: data.map(([timestamp, countsForTimestamp]) => ({\n          name: timestamp * 1000,\n          value: countsForTimestamp.reduce((acc, {count}) => acc + count, 0),\n        })),\n      },\n    ];\n  }\n\n  processData(response: EventsStats | null) {\n    if (!response) {\n      return {};\n    }\n\n    const {data, totals} = response;\n    const {\n      includeTransformedData,\n      includeTimeAggregation,\n      timeAggregationSeriesName,\n    } = this.props;\n    const {current, previous} = this.getData(data);\n    const transformedData = includeTransformedData\n      ? this.transformTimeseriesData(current, this.props.currentSeriesName)\n      : [];\n    const previousData = includeTransformedData\n      ? this.transformPreviousPeriodData(current, previous)\n      : null;\n    const timeAggregatedData = includeTimeAggregation\n      ? this.transformAggregatedTimeseries(current, timeAggregationSeriesName || '')\n      : {};\n    return {\n      data: transformedData,\n      allData: data,\n      originalData: current,\n      totals,\n      originalPreviousData: previous,\n      previousData,\n      timeAggregatedData,\n    };\n  }\n\n  render() {\n    const {children, showLoading, ...props} = this.props;\n    const {timeseriesData, reloading, errored} = this.state;\n    // Is \"loading\" if data is null\n    const loading = this.props.loading || timeseriesData === null;\n\n    if (showLoading && loading) {\n      return <LoadingPanel data-test-id=\"events-request-loading\" />;\n    }\n\n    if (isMultiSeriesStats(timeseriesData)) {\n      // Convert multi-series results into chartable series. Multi series results\n      // are created when multiple yAxis are used or a topEvents request is made.\n      // Convert the timeseries data into a multi-series result set.\n      // As the server will have replied with a map like:\n      // {[titleString: string]: EventsStats}\n      const results: MultiSeriesResults = Object.keys(timeseriesData)\n        .map((seriesName: string): [number, Series] => {\n          const seriesData: EventsStats = timeseriesData[seriesName];\n          const transformed = this.transformTimeseriesData(\n            seriesData.data,\n            seriesName\n          )[0];\n          return [seriesData.order || 0, transformed];\n        })\n        .sort((a, b) => a[0] - b[0])\n        .map(item => item[1]);\n\n      return children({\n        loading,\n        reloading,\n        errored,\n        results,\n        // sometimes we want to reference props that were given to EventsRequest\n        ...props,\n      });\n    }\n\n    const {\n      data: transformedTimeseriesData,\n      allData: allTimeseriesData,\n      originalData: originalTimeseriesData,\n      totals: timeseriesTotals,\n      originalPreviousData: originalPreviousTimeseriesData,\n      previousData: previousTimeseriesData,\n      timeAggregatedData,\n    } = this.processData(timeseriesData);\n\n    return children({\n      loading,\n      reloading,\n      errored,\n      // timeseries data\n      timeseriesData: transformedTimeseriesData,\n      allTimeseriesData,\n      originalTimeseriesData,\n      timeseriesTotals,\n      originalPreviousTimeseriesData,\n      previousTimeseriesData,\n      timeAggregatedData,\n      // sometimes we want to reference props that were given to EventsRequest\n      ...props,\n    });\n  }\n}\nexport default EventsRequest;\n","import {\n  WEEK,\n  DAY,\n  HOUR,\n  MINUTE,\n  SECOND,\n  getDuration,\n  formatAbbreviatedNumber,\n  formatPercentage,\n} from 'app/utils/formatters';\nimport {t} from 'app/locale';\nimport {aggregateOutputType} from 'app/utils/discover/fields';\n\n/**\n * Formatter for chart tooltips that handle a variety of discover result values\n */\nexport function tooltipFormatter(value: number, seriesName: string): string {\n  switch (aggregateOutputType(seriesName)) {\n    case 'integer':\n    case 'number':\n      return value.toLocaleString();\n    case 'percentage':\n      return formatPercentage(value, 2);\n    case 'duration':\n      return getDuration(value / 1000, 2, true);\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Formatter for chart axis labels that handle a variety of discover result values\n * This function is *very similar* to tooltipFormatter but outputs data with less precision.\n */\nexport function axisLabelFormatter(\n  value: number,\n  seriesName: string,\n  abbreviation: boolean = false\n): string {\n  switch (aggregateOutputType(seriesName)) {\n    case 'integer':\n    case 'number':\n      return abbreviation ? formatAbbreviatedNumber(value) : value.toLocaleString();\n    case 'percentage':\n      return formatPercentage(value, 0);\n    case 'duration':\n      return axisDuration(value);\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Specialized duration formatting for axis labels.\n * In that context we are ok sacrificing accuracy for more\n * consistent sizing.\n *\n * @param value Number of milliseconds to format.\n */\nfunction axisDuration(value: number): string {\n  if (value === 0) {\n    return '0';\n  }\n  if (value >= WEEK) {\n    const label = (value / WEEK).toFixed(0);\n    return t('%swk', label);\n  }\n  if (value >= DAY) {\n    const label = (value / DAY).toFixed(0);\n    return t('%sd', label);\n  }\n  if (value >= HOUR) {\n    const label = (value / HOUR).toFixed(0);\n    return t('%shr', label);\n  }\n  if (value >= MINUTE) {\n    const label = (value / MINUTE).toFixed(0);\n    return t('%smin', label);\n  }\n  if (value >= SECOND) {\n    const label = (value / SECOND).toFixed(0);\n    return t('%ss', label);\n  }\n  const label = (value / SECOND).toFixed(1);\n  return t('%ss', label);\n}\n","var baseIteratee = require('./_baseIteratee'),\n    negate = require('./negate'),\n    pickBy = require('./pickBy');\n\n/**\n * The opposite of `_.pickBy`; this method creates an object composed of\n * the own and inherited enumerable string keyed properties of `object` that\n * `predicate` doesn't return truthy for. The predicate is invoked with two\n * arguments: (value, key).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The source object.\n * @param {Function} [predicate=_.identity] The function invoked per property.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.omitBy(object, _.isNumber);\n * // => { 'b': '2' }\n */\nfunction omitBy(object, predicate) {\n  return pickBy(object, negate(baseIteratee(predicate)));\n}\n\nmodule.exports = omitBy;\n","import React from 'react';\n\nimport LoadingPanel from 'app/components/charts/loadingPanel';\n\nconst defaultProps = {\n  height: '200px',\n};\n\ntype Props = {\n  reloading: boolean;\n  loading: boolean;\n} & typeof defaultProps;\n\ntype State = {\n  prevReloading: boolean;\n  prevLoading: boolean;\n  key: number;\n};\n\nclass TransitionChart extends React.Component<Props, State> {\n  static defaultProps = defaultProps;\n\n  state = {\n    prevReloading: this.props.reloading,\n    prevLoading: this.props.loading,\n    key: 1,\n  };\n\n  static getDerivedStateFromProps(props: Props, state: State) {\n    // Transitions are controlled using variables called:\n    // - loading and,\n    // - reloading (also called pending in other apps)\n    //\n    // This component remounts the chart to ensure the stable transition\n    // from one data set to the next.\n\n    const prevReloading = state.prevReloading;\n    const nextReloading = props.reloading;\n\n    const prevLoading = state.prevLoading;\n    const nextLoading = props.loading;\n\n    // whenever loading changes, we explicitly remount the children by updating\n    // the key prop; regardless of what state reloading is in\n    if (prevLoading !== nextLoading) {\n      return {\n        prevReloading: nextReloading,\n        prevLoading: nextLoading,\n        key: state.key + 1,\n      };\n    }\n\n    // invariant: prevLoading === nextLoading\n\n    // if loading is true, and hasn't changed from the previous re-render,\n    // do not remount the children.\n    if (nextLoading) {\n      return {\n        prevReloading: nextReloading,\n        prevLoading: nextLoading,\n        key: state.key,\n      };\n    }\n\n    // invariant: loading is false\n\n    // whenever the chart is transitioning from the reloading (pending) state to a non-loading state,\n    // remount the children\n    if (prevReloading && !nextReloading) {\n      return {\n        prevReloading: nextReloading,\n        prevLoading: nextLoading,\n        key: state.key + 1,\n      };\n    }\n\n    // do not remount the children in these remaining cases:\n    // !prevReloading && !nextReloading (re-render with no prop change)\n    // prevReloading && nextReloading (re-render with no prop change)\n    // !prevReloading && nextReloading (from loaded to pending state)\n\n    return {\n      prevReloading: nextReloading,\n      prevLoading: nextLoading,\n      key: state.key,\n    };\n  }\n\n  render() {\n    const {height, loading, reloading} = this.props;\n\n    if (loading && !reloading) {\n      return <LoadingPanel height={height} data-test-id=\"events-request-loading\" />;\n    }\n\n    // We make use of the key prop to explicitly remount the children\n    // https://reactjs.org/docs/lists-and-keys.html#keys\n    return (\n      <React.Fragment key={String(this.state.key)}>{this.props.children}</React.Fragment>\n    );\n  }\n}\n\nexport default TransitionChart;\n","import styled from '@emotion/styled';\n\nimport LoadingMask from 'app/components/loadingMask';\n\ntype Props = {\n  visible: boolean;\n};\n\nconst TransparentLoadingMask = styled(LoadingMask)<Props>`\n  ${p => !p.visible && 'display: none;'};\n  opacity: 0.4;\n  z-index: 1;\n`;\n\nexport default TransparentLoadingMask;\n","/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that negates the result of the predicate `func`. The\n * `func` predicate is invoked with the `this` binding and arguments of the\n * created function.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Function\n * @param {Function} predicate The predicate to negate.\n * @returns {Function} Returns the new negated function.\n * @example\n *\n * function isEven(n) {\n *   return n % 2 == 0;\n * }\n *\n * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n * // => [1, 3, 5]\n */\nfunction negate(predicate) {\n  if (typeof predicate != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return function() {\n    var args = arguments;\n    switch (args.length) {\n      case 0: return !predicate.call(this);\n      case 1: return !predicate.call(this, args[0]);\n      case 2: return !predicate.call(this, args[0], args[1]);\n      case 3: return !predicate.call(this, args[0], args[1], args[2]);\n    }\n    return !predicate.apply(this, args);\n  };\n}\n\nmodule.exports = negate;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport styled from '@emotion/styled';\n\nimport DropdownButton from 'app/components/dropdownButton';\nimport DropdownMenu from 'app/components/dropdownMenu';\nimport {InlineContainer, SectionHeading} from 'app/components/charts/styles';\nimport {DropdownItem} from 'app/components/dropdownControl';\nimport DropdownBubble from 'app/components/dropdownBubble';\nimport Tooltip from 'app/components/tooltip';\nimport space from 'app/styles/space';\nimport {SelectValue} from 'app/types';\n\ntype Props = {\n  options: SelectValue<string>[];\n  selected: string;\n  onChange: (value: string) => void;\n  title: string;\n  menuWidth?: string;\n};\n\nfunction OptionSelector({options, onChange, selected, title, menuWidth = 'auto'}: Props) {\n  const selectedOption = options.find(opt => selected === opt.value) || options[0];\n\n  return (\n    <InlineContainer>\n      <SectionHeading>{title}</SectionHeading>\n      <MenuContainer>\n        <DropdownMenu alwaysRenderMenu={false}>\n          {({isOpen, getMenuProps, getActorProps}) => (\n            <React.Fragment>\n              <StyledDropdownButton {...getActorProps()} size=\"zero\" isOpen={isOpen}>\n                {selectedOption.label}\n              </StyledDropdownButton>\n              <StyledDropdownBubble\n                {...getMenuProps()}\n                alignMenu=\"right\"\n                width={menuWidth}\n                isOpen={isOpen}\n                blendWithActor={false}\n                blendCorner\n              >\n                {options.map(opt => (\n                  <DropdownItem\n                    key={opt.value}\n                    onSelect={onChange}\n                    eventKey={opt.value}\n                    disabled={opt.disabled}\n                    isActive={selected === opt.value}\n                    data-test-id={`option-${opt.value}`}\n                  >\n                    <Tooltip title={opt.tooltip} containerDisplayMode=\"inline\">\n                      {opt.label}\n                    </Tooltip>\n                  </DropdownItem>\n                ))}\n              </StyledDropdownBubble>\n            </React.Fragment>\n          )}\n        </DropdownMenu>\n      </MenuContainer>\n    </InlineContainer>\n  );\n}\n\nconst MenuContainer = styled('div')`\n  display: inline-block;\n  position: relative;\n`;\n\nconst StyledDropdownButton = styled(DropdownButton)`\n  padding: ${space(1)} ${space(2)};\n  font-weight: normal;\n  color: ${p => p.theme.gray600};\n  z-index: ${p => (p.isOpen ? p.theme.zIndex.dropdownAutocomplete.actor : 'auto')};\n\n  &:hover,\n  &:focus,\n  &:active {\n    color: ${p => p.theme.gray700};\n  }\n`;\n\nconst StyledDropdownBubble = styled(DropdownBubble)<{isOpen: boolean}>`\n  display: ${p => (p.isOpen ? 'block' : 'none')};\n`;\n\nOptionSelector.propTypes = {\n  options: PropTypes.array.isRequired,\n  onChange: PropTypes.func.isRequired,\n  title: PropTypes.string.isRequired,\n  selected: PropTypes.string,\n};\n\nexport default OptionSelector;\n"],"sourceRoot":""}