Metadata-Version: 2.1
Name: vdf3
Version: 3.1.1.1
Summary: Library for working with Valve's VDF text format
Home-page: https://github.com/Gobot1234/vdf3
Author: Gobot1234
License: MIT
Download-URL: https://github.com/Gobot1234/vdf3/archive/3.1.1.1.tar.gz
Project-URL: Code, https://github.com/Gobot1234/vdf3
Project-URL: Issue tracker, https://github.com/Gobot1234/vdf3/issues
Keywords: valve keyvalue vdf tf2 dota2 csgo
Platform: UNKNOWN
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Natural Language :: English
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3 :: Only
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Topic :: Software Development :: Libraries
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Typing :: Typed
Requires: multidict
Requires-Python: >=3.7.0
Description-Content-Type: text/markdown

VDF 3
======

Pure python module for (de)serialization to and from VDF that works just like ``json``.
[VDF is Valve's KeyValue text file format](https://developer.valvesoftware.com/wiki/KeyValues)

Supports:
- ``kv1``

Installation
------------

**Python 3.7 or higher is required**

```sh
pip install git+https://github.com/ValvePython/vdf
```

Example usage
-------------

For text representation.

```py
import vdf

# parsing vdf from file or string
d = vdf.load(open('file.txt'))
d = vdf.loads(vdf_text)
d = vdf.parse(open('file.txt'))
d = vdf.parse(vdf_text)

# dumping dict as vdf to string
vdf_text = vdf.dumps(d)
indented_vdf = vdf.dumps(d, pretty=True)

# dumping dict as vdf to file
vdf.dump(d, open('file2.txt','w'), pretty=True)
```


For binary representation

```py

d = vdf.binary_loads(vdf_bytes)
b = vdf.binary_dumps(d)

# alternative format - VBKV

d = vdf.binary_loads(vdf_bytes, alt_format=True)
b = vdf.binary_dumps(d, alt_format=True)

# VBKV with header and CRC checking

d = vdf.vbkv_loads(vbkv_bytes)
b = vdf.vbkv_dumps(d)
```

Using an alternative mapper

```py
d = vdf.loads(vdf_string, mapper=collections.OrderedDict)
```


