# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['typ', 'typ.types']

package_data = \
{'': ['*']}

install_requires = \
['stringcase>=1.2.0,<2.0.0', 'typing_inspect>=0.6.0,<0.7.0']

setup_kwargs = {
    'name': 'typjson',
    'version': '0.0.32',
    'description': 'Type-safe JSON (de)serialization',
    'long_description': '# typjson\n\nType-safe JSON (de)serialization for Python. Compatible with mypy type hints.\n\n## Requirements\n\n* Python 3.7 or newer\n\n## Features\n\n* Type safety in runtime and mypy compatibility\n* Support for types out of the box:\n  * Primitive types:\n      * `str`, `int`, `float`, `bool`, `Decimal`, `None`\n      * `date` as `"%Y-%m-%d"`, `datetime` as `"%Y-%m-%dT%H:%M:%S%z"`, `time` as `"%H:%M:%S"`\n      * `UUID` as `str` in format `"8-4-4-4-12"`\n      * `char` type as `str` of length 1\n  * `Union[]` and therefore `Optional[]`\n  * Structure types: `List[]`, `Tuple[]`, `Dict[str, T]`, `Set[]`\n  * [Enum classes](https://docs.python.org/3/library/enum.html)\n  * [Data classes](https://docs.python.org/3/library/dataclasses.html)\n* Support for custom encoders and decoders\n* API similar to standard [json module](https://docs.python.org/3/library/json.html)\n\n## Simple Usage\n\n```python\nfrom typ import json\nfrom typing import *\nfrom datetime import date\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Address:\n    street: str\n    house: int\n    apt: Optional[str]\n\n\n@dataclass\nclass Person:\n    first_name: str\n    last_name: str\n    languages: List[str]\n    address: Address\n    birth_date: date\n\n\nperson = Person(\n    "John",\n    "Smith",\n    ["English", "Russian"],\n    Address("Main", 1, "2A"),\n    date(year=1984, month=8, day=1)\n)\n\njson_str = json.dumps(person, indent=2)\nloaded_person = json.loads(Person, json_str)\n\nassert person == loaded_person\n```\n\nValue of `json_str` that is dumped and loaded in the code example above looks like:\n```json\n{\n  "first_name": "John",\n  "last_name": "Smith",\n  "languages": [\n    "English",\n    "Russian"\n  ],\n  "address": {\n    "street": "Main",\n    "house": 1,\n    "apt": "2A"\n  },\n  "birth_date": "1984-08-01"\n}\n```\n\n## Type Safety\n\n### Runtime\n\nWhat is type safety in Python? Since Python is dynamically typed language it\'s hard to provide any types guarantees before runtime. However types could be checked in run time. This is exactly what typjson library is doing.\nConsider following example for `Address` type defined above:\n```python\nfrom typ import json\nfrom typing import *\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Address:\n    street: str\n    house: int\n    apt: Optional[str]\n\njson_str = """{"street": "Main", "house": 1, "apt": 2}"""\nloaded_address = json.loads(Address, json_str)\n```\n\nThe `apt` field has type defined as `Optional[str]` however value provided in JSON is `2` which is `number` type in JSON and it\'s obviously not compatible with `Optional[str]`.\nRespectively `json.loads` call will raise `JsonError`:\n```\ntyp.encoding.JsonError: Value 2 can not be deserialized as typing.Union[str, NoneType]\n```\nCall `json.loads` will either return instance of requested type with all nested types checked or raise a error. This is runtime type safety of typjson.\n\n### Compile Time (mypy)\n\nFunctions in `typ.json` module `dumps`, `loads`, `dump`, `load` have proper type hints. Therefore types could be validated with [mypy](http://mypy-lang.org/) tool:\n```python\njson_str = """{"street": "Main", "house": 1, "apt": 2}"""\nloaded_address = json.loads(Address, json_str)\nloaded_address = "some other address"\n```\nThis will produce error in mypy as type of `loaded_address` is inferred as `Address`:\n```\nerror: Incompatible types in assignment (expression has type "str", variable has type "Address")\n```\nThis provides type safety in compile time.\n\n## API Overview\n\ntypjson API is similar to [json](https://docs.python.org/3/library/json.html) module API. Main functions are defined in `typ.json` module. Most useful functions are [`typ.json.loads`](#typjsonloads) and [`typ.json.dumps`](#typjsondumps). If something went wrong during JSON encoding/decoding then [`JsonError`](#typjsonjsonerror) is raised.\nIn fact `typ.json` functions are using `json` module under the hood for final conversion between python structures and JSON.\n\nList of supported types if provided [here](#supported-types).\n[Custom Encoding](#custom-encoding) section describes how any type could be supported in addition to types that are supported out of the box.\n\n## Supported Types\n\n### Primitive Types\n\n| Python type                          | JSON type | Notes                                             |\n| :----------------------------------- | :-------- | :------------------------------------------------ |\n| int                                  | number    |                                                   |\n| float                                | number    |                                                   |\n| decimal.Decimal                      | number    |                                                   |\n| boolean                              | boolean   |                                                   |\n| typ.typing.char                      | string    | string with length 1                              |\n| str                                  | string    |                                                   |\n| uuid.UUID                            | string    | lower case hex symbols with hyphens as 8-4-4-4-12 |\n| datetime.date                        | string    | ISO 8601 yyyy-mm-dd                               |\n| datetime.datetime                    | string    | ISO 8601 yyyy-mm-ddThh:mm:ss.ffffff               |\n| datetime.time                        | string    | ISO 8601 hh:mm:ss.ffffff                          |\n| typ.typing.NoneType <br/> type(None) | null      |                                                   |\n\n### Non Primitive Types\n\n| Python type                         | JSON type            | Notes                                             |\n| :-----------------------------------| :------------------- | ------------------------------------------------- |\n| List[T]                             | array                | homogeneous, items encoded                        |\n| Dict[str, T]                        | object               | fields values of T encoded                        |\n| Set[T]                              | array                | homogeneous, items of T encoded                   |\n| Tuple[T, K, ...]                    | array                | heterogeneous, items of T, K, ... encoded         |\n| Union[T, K, ...]                    | look for T, K, ...   | T, K, ... encoded                                 |\n| list                                | array                | heterogeneous, items are encoded                  |\n| dict                                | object               |                                                   |\n| tuple                               | array                | heterogeneous, items are encoded                  |\n| Enum classes                        | look for member type | enum members are encoded according to their types |\n| class decorated with<br/>@dataclass | object               | field types are respected                         |\n| class decorated with<br/>@union     | object               | object with single field                          |\n| Any                                 | any type             | anything                                          |\n\n\n### Null-safety\n\nAll types can not have `None` value besides `NoneType` aka `type(None)`. `Optional[T]` allows `None` value.\nSo if nullable `str` is needed `Optional[str]` would be a good fit.\n`Optional[T]` type is in fact `Union[T, NoneType]` therefore in typjson it\'s supported via `Union[]` support.\nBecause of this `Optional[T]` is not listed above since it\'s just a `Union`.\n\n## Custom Encoding\n\nIn fact all types that are supported out of the box are supported via encoders and decoders. Examples of custom encoder and decoder are provided just for basic understanding. For deeper insight the one might be interested to look at source code of `typ.encoding` module.\n\n### Custom Encoder\n\n[typ.json.dump](#typjsondump) and [typ.json.dumps](#typjsondumps) functions take list of encoders as a parameter.\nThose encoders are custom encoders that are used in addition to standard built-in encoders.\nLet\'s implement custom encoder that will code all integers as strings in JSON:\n```python\nfrom typ.encoding import Unsupported, check_type\n\ndef encode_int_custom(encoder, typ, value):\n    if typ != int:\n        # if this encoder is not applicable to the typ it should return Unsupported\n        return Unsupported\n    # there\'s a helper function checking that value is instance of specified type - int\n    check_type(int, value)\n    # return encoded value\n    return str(value)\n\nfrom typ import json\nassert json.dumps([3, 4, 5], encoders=[encode_int_custom]) == \'["3", "4", "5"]\'\n```\n\nIn the code above `encode_int_custom` is provided into `typ.json.dumps` call and it\'s used prior standard built-in `int` encoding. As it\'s deemostrated in the assert it successfully encoded integers as strings. Please never do this in real life - this code is provided only for demonstration purposes.\n\nEncoder function is defined as: `Callable[[\'Encoder\', Type[K], K], Union[Any, UnsupportedType]]`\nThere\'s an `encoder` parameter of every custom encoder which holds instance of [Encoder](#typencodingencoder). It is useful for encoding nested types, like lists or classes, etc.\n\n### Custom Decoder\n\n[typ.json.load](#typjsonload) and [typ.json.loads](#typjsonloads) functions take list of decoders as a parameter.\nSimilarly to [encoding](#custom-encoder) it\'s useful for custom decoding logic.\nHere\'s a mirror example for decoding `int` type from strings in JSON:\n```python\nfrom typ.encoding import Unsupported, check_type\n\ndef decode_int_custom(decoder, typ, json_value):\n    if typ != int:\n        # if this encoder is not applicable to the typ it should return Unsupported\n        return Unsupported\n    # check that JSON has string in the json_value\n    check_type(str, json_value)\n    # return decoded value\n    return int(json_value)\n\nfrom typ import json\nassert loads(List[int], \'["3", "4", "5"]\', decoders=[decode_int_custom]) == [3, 4, 5]\n```\n\nDecoder function is defined as: `Callable[[\'Decoder\', Type[K], Any], Union[K, UnsupportedType]]`.\n\n## API Reference\n\n### typ.json.dumps\n\n`typ.json.dumps(value: T, typ: Optional[Type[T]] = None, case: CaseConverter = None, encoders: List[EncodeFunc] = [], indent: Optional[int] = None) -> str`\n\nSerialize value to a JSON formatted str using specified type.\n\n`value` Python object to be serialized to JSON.\n\n`typ` type information for `value`.\nIf `None` is provided then actual type of `value` is used otherwise `value` is checked to be valid instance of `typ`.\n\n`case` case converter, see [fields case](#fields-case).\n\n`encoders` list of custom encoders, see [custom encoding](#custom-encoding).\n\n`indent` optional non-negative indent level for JSON. If `None` is provided then JSON is represented as single line without indentation.\n\nReturns JSON string or raises `JsonError`.\n\n### typ.json.dump\n\n`typ.json.dump(fp: IO[str], value: T, typ: Optional[Type[T]] = None, case: CaseConverter = None, encoders: List[EncodeFunc] = [], indent: Optional[int] = None) -> None`\n\nSerialize value as a JSON formatted stream.\n\n`fp` stream to write JSON to.\n\nOther arguments have the same meaning as in [typ.json.dumps](#typjsondumps).\n\n### typ.json.loads\n\n`typ.json.loads(typ: Type[T], json_str: str, case: CaseConverter = None, decoders: List[DecodeFunc] = []) -> T`\n\nDeserialize json_str to a Python object of specified type.\n\n`typ` type to deserialize JSON into.\n\n`json_str` string containing JSON.\n\n`case` case converter, see [fields case](#fields-case).\n\n`decoders` list of custom decoders, see [custom encoding](#custom-encoding).\n\nReturns instance of `M` or raises `JsonError`.\n\n### typ.json.load\n\n`typ.json.load(fp: IO[str], typ: Type[T], case: CaseConverter = None, decoders: List[DecodeFunc] = []) -> T`\n\nDeserialize stream to a Python object of specified type.\n\n`fp` stream to read JSON from.\n\nOther arguments have the same meaning as in [typ.json.loads](#typjsonloads)\n\n### typ.json.JsonError (defined as typ.encoding.JsonError)\n\n`JsonError` raised in case of any issue during encoding/decoding JSON data according to type information provided.\n',
    'author': 'Vladimir Sapronov',
    'author_email': 'vladimir.sapronov@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
